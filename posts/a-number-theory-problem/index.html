<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Un problema di Teoria dei Numeri | LCS.Developer</title><meta name=keywords content><meta name=description content="Finding coprime quadruples: An algorithmic analysis of &ldquo;Sea, you & copriMe&rdquo;
Abstract
This article presents a comprehensive algorithmic analysis and solution to the problem of finding quadruples of distinct indices in an integer array that form two coprime pairs. While originating from competitive programming, this problem offers an excellent opportunity to explore the intersections between number theory, graph theory, and efficient algorithm design. We demonstrate how the combination of concepts such as the Sieve of Eratosthenes, the Möbius function, the inclusion-exclusion principle, and heuristic search strategies enables the development of a robust and elegant solution. The final implementation demonstrates how deep understanding of underlying mathematical properties is fundamental to achieving decisive algorithmic optimizations."><meta name=author content="LCS.Dev"><link rel=canonical href=https://lcs-developer.com/posts/a-number-theory-problem/><meta name=google-site-verification content="CPQPKX3QPR"><link crossorigin=anonymous href=/assets/css/stylesheet.2bbe49b8fd26e9b2a1b26e6ef8e0785cc8918c0cdbe6afaeed0d49cef5feffa4.css integrity="sha256-K75JuP0m6bKhsm5u+OB4XMiRjAzb5q+u7Q1JzvX+/6Q=" rel="preload stylesheet" as=style><link rel=icon href=https://lcs-developer.com/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lcs-developer.com/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lcs-developer.com/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://lcs-developer.com/favicon/apple-touch-icon.png><link rel=mask-icon href=https://lcs-developer.com/favicon/safari-pinned-tab.svg><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#ffffff"><link rel=alternate hreflang=en href=https://lcs-developer.com/posts/a-number-theory-problem/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-CPQPKX3QPR"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-CPQPKX3QPR")}</script><meta property="og:url" content="https://lcs-developer.com/posts/a-number-theory-problem/"><meta property="og:site_name" content="LCS.Developer"><meta property="og:title" content="Un problema di Teoria dei Numeri"><meta property="og:description" content="Finding coprime quadruples: An algorithmic analysis of “Sea, you & copriMe” Abstract This article presents a comprehensive algorithmic analysis and solution to the problem of finding quadruples of distinct indices in an integer array that form two coprime pairs. While originating from competitive programming, this problem offers an excellent opportunity to explore the intersections between number theory, graph theory, and efficient algorithm design. We demonstrate how the combination of concepts such as the Sieve of Eratosthenes, the Möbius function, the inclusion-exclusion principle, and heuristic search strategies enables the development of a robust and elegant solution. The final implementation demonstrates how deep understanding of underlying mathematical properties is fundamental to achieving decisive algorithmic optimizations."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-08-26T22:10:00+00:00"><meta property="article:modified_time" content="2025-08-26T22:10:00+00:00"><meta property="og:image" content="https://lcs-developer.com/images/LCS.Dev-Logo.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://lcs-developer.com/images/LCS.Dev-Logo.jpg"><meta name=twitter:title content="Un problema di Teoria dei Numeri"><meta name=twitter:description content="Finding coprime quadruples: An algorithmic analysis of &ldquo;Sea, you & copriMe&rdquo;
Abstract
This article presents a comprehensive algorithmic analysis and solution to the problem of finding quadruples of distinct indices in an integer array that form two coprime pairs. While originating from competitive programming, this problem offers an excellent opportunity to explore the intersections between number theory, graph theory, and efficient algorithm design. We demonstrate how the combination of concepts such as the Sieve of Eratosthenes, the Möbius function, the inclusion-exclusion principle, and heuristic search strategies enables the development of a robust and elegant solution. The final implementation demonstrates how deep understanding of underlying mathematical properties is fundamental to achieving decisive algorithmic optimizations."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://lcs-developer.com/posts/"},{"@type":"ListItem","position":2,"name":"Un problema di Teoria dei Numeri","item":"https://lcs-developer.com/posts/a-number-theory-problem/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Un problema di Teoria dei Numeri","name":"Un problema di Teoria dei Numeri","description":"Finding coprime quadruples: An algorithmic analysis of \u0026ldquo;Sea, you \u0026amp; copriMe\u0026rdquo; Abstract This article presents a comprehensive algorithmic analysis and solution to the problem of finding quadruples of distinct indices in an integer array that form two coprime pairs. While originating from competitive programming, this problem offers an excellent opportunity to explore the intersections between number theory, graph theory, and efficient algorithm design. We demonstrate how the combination of concepts such as the Sieve of Eratosthenes, the Möbius function, the inclusion-exclusion principle, and heuristic search strategies enables the development of a robust and elegant solution. The final implementation demonstrates how deep understanding of underlying mathematical properties is fundamental to achieving decisive algorithmic optimizations.\n","keywords":[null],"articleBody":"Finding coprime quadruples: An algorithmic analysis of “Sea, you \u0026 copriMe” Abstract This article presents a comprehensive algorithmic analysis and solution to the problem of finding quadruples of distinct indices in an integer array that form two coprime pairs. While originating from competitive programming, this problem offers an excellent opportunity to explore the intersections between number theory, graph theory, and efficient algorithm design. We demonstrate how the combination of concepts such as the Sieve of Eratosthenes, the Möbius function, the inclusion-exclusion principle, and heuristic search strategies enables the development of a robust and elegant solution. The final implementation demonstrates how deep understanding of underlying mathematical properties is fundamental to achieving decisive algorithmic optimizations.\n1. Problem formulation and introduction In the realm of algorithmic problem solving, certain challenges distinguish themselves through an apparently simple formulation that conceals considerable computational complexity. The problem under examination, titled “Sea, You \u0026 copriMe,” belongs entirely to this category. Its formal definition is as follows:\nInput:\nAn array $a$ of $n$ integers, where $4 \\leq n \\leq 200,000$ Each element $a_i$ of the array is within the interval $[1, m]$, where $1 \\leq m \\leq 1,000,000$ Output:\nFour distinct indices $(p, q, r, s)$ such that the greatest common divisor of the corresponding element pairs is unity: $\\gcd(a_p, a_q) = 1$ $\\gcd(a_r, a_s) = 1$ If no such quadruple exists, the output should be 0 The primary challenge lies in the dimensional constraints of the input. A brute force approach examining all possible combinations of four indices would result in $O(n^4)$ time complexity, a prohibitive value for $n$ on the order of $2 \\times 10^5$. It is therefore imperative to develop a strategy that exploits the intrinsic mathematical structure of the problem to drastically reduce the solution space to be explored.\n2. The coprimality graph: a structural perspective A fundamental initial insight for approaching this problem consists of reformulating it in terms of graph theory. We can model the coprimality relationships between array elements through an undirected graph $G = (V, E)$, defined as follows:\nThe vertex set $V = {1, 2, \\ldots, n}$ represents the indices of array $a$ An edge $(i, j)$ belongs to the edge set $E$ if and only if the corresponding elements are coprime, i.e., $\\gcd(a_i, a_j) = 1$ In this new perspective, the problem translates to finding two edges in $G$ that share no vertices, essentially a matching of size two. This abstraction not only clarifies the problem structure but also opens the way to various algorithmic strategies based on graph properties.\nWe define the coprimality degree of a vertex $i$ as the number of edges incident to it, which corresponds to the number of elements in the array that are coprime with $a_i$:\n$$\\deg(i) = |{j \\in V, j \\neq i \\mid \\gcd(a_i, a_j) = 1}|$$\nElements with low coprimality degree represent “scarce resources” in our graph. For example, a vertex with degree 1 (a “leaf vertex”) has only one potential partner to form a coprime pair. Prioritized management of such vertices will prove to be an effective heuristic strategy.\n3. Fundamental tools from number theory To navigate efficiently in the coprimality graph, particularly to calculate vertex degrees, it is necessary to resort to advanced tools from number theory.\n3.1 The inclusion-exclusion principle and the möbius function The efficient calculation of the number of elements in a set that are coprime with a given integer $x$ is a classic problem. The most elegant solution employs the inclusion-exclusion principle, formalized through the Möbius function, $\\mu(n)$. This function is defined for every positive integer $n$ as follows:\n$$\\mu(n) = \\begin{cases} 1 \u0026 \\text{if } n \\text{ is square-free with an even number of distinct prime factors} \\ -1 \u0026 \\text{if } n \\text{ is square-free with an odd number of distinct prime factors} \\ 0 \u0026 \\text{if } n \\text{ has a squared prime factor} \\end{cases}$$\nAn integer is called “square-free” if it is not divisible by any perfect square other than 1.\nThe theorem linking the Möbius function to our problem states that, given an integer $x$ and a multiset $S$ of integers, the number of elements in $S$ that are coprime with $x$ is given by:\n$$\\text{count_coprime}(x, S) = \\sum_{d \\mid x, \\mu(d) \\neq 0} \\mu(d) \\cdot |{s \\in S : d \\mid s}|$$\nThis formula allows us to calculate the coprimality degree of an element without having to test every individual pair. Instead of $O(n)$ gcd operations, we can perform the calculation based on the divisors of $x$.\n3.2 Concrete example Suppose we want to calculate the number of elements coprime with $x = 6$ in a multiset $S$ where the counts of multiples are already known: $|S_1|=10, |S_2|=5, |S_3|=3, |S_6|=1$.\nThe square-free divisors of 6 are ${1, 2, 3, 6}$.\nThe Möbius function values are: $\\mu(1)=1, \\mu(2)=-1, \\mu(3)=-1, \\mu(6)=1$.\nApplying the formula:\n$$\\text{count_coprime}(6, S) = \\mu(1)|S_1| + \\mu(2)|S_2| + \\mu(3)|S_3| + \\mu(6)|S_6|$$\n$$\\text{count_coprime}(6, S) = (1 \\cdot 10) + (-1 \\cdot 5) + (-1 \\cdot 3) + (1 \\cdot 1) = 10 - 5 - 3 + 1 = 3$$\n3.3 Implementation of the linear sieve To use the previous formula, we need the values of the Möbius function and the prime factors of integers up to $m$. A linear sieve is the ideal tool for this precomputation in $O(m)$ time.\nstruct NumberTheoryEngine { static constexpr size_t LIMIT = 1000001; array\u003cint, LIMIT\u003e minimal_prime; array\u003cint, LIMIT\u003e moebius; NumberTheoryEngine() { iota(minimal_prime.begin(), minimal_prime.end(), 0); fill(moebius.begin(), moebius.end(), 0); moebius[1] = 1; vector\u003cint\u003e prime_list; prime_list.reserve(80000); // Approximate prime count for (size_t i = 2; i \u003c LIMIT; ++i) { if (minimal_prime[i] == static_cast\u003cint\u003e(i)) { prime_list.push_back(i); moebius[i] = -1; } for (int prime : prime_list) { if (prime \u003e minimal_prime[i] || static_cast\u003cll\u003e(i) * prime \u003e= static_cast\u003cll\u003e(LIMIT)) break; minimal_prime[i * prime] = prime; moebius[i * prime] = (prime == minimal_prime[i]) ? 0 : -moebius[i]; } } } }; This linear sieve implementation efficiently computes both the smallest prime factor and Möbius function values for all numbers up to the limit, enabling fast factorization and coprimality calculations.\n4. A stratified algorithmic strategy The algorithm adopts a multi-phase approach designed to solve the problem as efficiently as possible.\nPhase 0: Preprocessing and data structures The first step consists of preparing the data structures that will support subsequent phases:\nLinear sieve execution: Computing Möbius values and prime factorizations Frequency and divisibility counting: Building frequency arrays for efficient lookups Value compression: Identifying unique values and storing their properties class ValueCompressor { public: struct CompressedValue { int original; int compressed_id; vector\u003cint\u003e occurrence_indices; vector\u003cint\u003e squarefree_factors; }; private: unordered_map\u003cint, size_t\u003e compression_map; vector\u003cCompressedValue\u003e compressed_data; public: void compress(span\u003cconst int\u003e input_sequence) { compression_map.clear(); compressed_data.clear(); compression_map.reserve(input_sequence.size()); for (size_t idx = 0; idx \u003c input_sequence.size(); ++idx) { int value = input_sequence[idx]; auto [iter, inserted] = compression_map.try_emplace(value, compressed_data.size()); if (inserted) { compressed_data.push_back({ .original = value, .compressed_id = static_cast\u003cint\u003e(compressed_data.size() - 1), .occurrence_indices = {static_cast\u003cint\u003e(idx + 1)}, // 1-indexed .squarefree_factors = NT_ENGINE.factorize_squarefree(value) }); } else { compressed_data[iter-\u003esecond].occurrence_indices.push_back(static_cast\u003cint\u003e(idx + 1)); } } } }; Phase 1: Handling unit values The value 1 is exceptional since $\\gcd(1, k) = 1$ for any $k$. Its presence simplifies the search significantly:\nstruct UnitValueStrategy { static auto execute(span\u003cconst int\u003e unit_indices, span\u003cconst int\u003e sequence) -\u003e MaybeSolution { size_t unit_count = unit_indices.size(); if (unit_count \u003e= 4) { return Quadruple{unit_indices[0], unit_indices[1], unit_indices[2], unit_indices[3]}; } if (unit_count == 3) { for (size_t i = 1; i \u003c sequence.size(); ++i) { if (sequence[i] != 1) { return Quadruple{unit_indices[0], unit_indices[1], unit_indices[2], static_cast\u003cint\u003e(i)}; } } return nullopt; } if (unit_count == 2) { vector\u003cint\u003e non_units; for (size_t i = 1; i \u003c sequence.size() \u0026\u0026 non_units.size() \u003c 2; ++i) { if (sequence[i] != 1) { non_units.push_back(static_cast\u003cint\u003e(i)); } } if (non_units.size() \u003e= 2) { return Quadruple{unit_indices[0], non_units[0], unit_indices[1], non_units[1]}; } } return nullopt; } }; Phase 2: Exploiting duplicate values If a value $v \u003e 1$ appears multiple times and has sufficient coprimes, the solution becomes straightforward:\n// Phase 2: Duplicate value exploitation for (size_t id = 0; id \u003c compressor.unique_count(); ++id) { if (cached_occurrences[id].size() \u003e= 2 \u0026\u0026 cached_original_values[id] != 1) { int coprime_candidates = cached_coprime_degrees[id]; if (coprime_candidates \u003e= 2) { vector\u003cint\u003e partners; for (int i = 1; i \u003c= spec.element_count \u0026\u0026 partners.size() \u003c 2; ++i) { if (gcd(cached_original_values[id], spec.sequence[i]) == 1) { partners.push_back(i); } } if (partners.size() \u003e= 2) { output_solution({cached_occurrences[id][0], partners[0], cached_occurrences[id][1], partners[1]}); return; } } } } Phase 3: Single unit case When exactly one ‘1’ exists in the array, it guarantees one coprime pair. The problem reduces to finding a second coprime pair among the remaining elements:\nauto handle_single_unit_case(int unit_index) -\u003e MaybeSolution { // Find any coprime pair among non-unit values for (size_t id = 0; id \u003c compressor.unique_count(); ++id) { if (cached_original_values[id] == 1) continue; int non_unit_coprimes = cached_coprime_degrees[id] - 1; // Exclude the unit if (non_unit_coprimes \u003c 1) continue; int first_index = cached_occurrences[id][0]; for (int partner = 1; partner \u003c= spec.element_count; ++partner) { if (partner == unit_index || partner == first_index) continue; if (gcd(cached_original_values[id], spec.sequence[partner]) == 1) { for (int fourth = 1; fourth \u003c= spec.element_count; ++fourth) { if (fourth != unit_index \u0026\u0026 fourth != first_index \u0026\u0026 fourth != partner) { return Quadruple{first_index, partner, unit_index, fourth}; } } } } } return nullopt; } Phase 4: Degree-based heuristic search When special cases fail, we resort to a more sophisticated search based on coprimality degrees.\n4.1 Prioritizing leaf vertices Vertices with degree 1 (leaves in the graph) are critical: they have only one possible partner. If we don’t pair them immediately, they might block future solutions:\n// Handle leaf vertices (degree 1) for (size_t value_id = 0; value_id \u003c compressor.unique_count(); ++value_id) { if (cached_coprime_degrees[value_id] == 1) { int leaf_index = cached_occurrences[value_id][0]; for (int partner = 1; partner \u003c= spec.element_count; ++partner) { if (partner != leaf_index \u0026\u0026 gcd(cached_original_values[value_id], spec.sequence[partner]) == 1) { // Temporarily remove both from consideration analyzer-\u003emodify_element_presence(cached_squarefree_factors[value_id], -1); analyzer-\u003emodify_element_presence(cached_squarefree_factors[partner_id], -1); auto [third, fourth] = filtered_coprime_search(leaf_index, partner); if (third != -1) { return Quadruple{leaf_index, partner, third, fourth}; } // Restore analyzer-\u003emodify_element_presence(cached_squarefree_factors[value_id], +1); analyzer-\u003emodify_element_presence(cached_squarefree_factors[partner_id], +1); // Leaf can't form solution - no solution exists return nullopt; } } } } 4.2 Bounded search with degree ordering For remaining elements, we sort by increasing degree and apply bounded search:\n// Build list of ALL indices sorted by degree of their VALUE vector\u003cint\u003e sorted_indices; sorted_indices.reserve(spec.element_count); for (size_t value_id = 0; value_id \u003c compressor.unique_count(); ++value_id) { if (cached_coprime_degrees[value_id] \u003e= 1) { for (int idx : cached_occurrences[value_id]) { sorted_indices.push_back(idx); } } } // Sort by degree of the value, then by index sort(sorted_indices.begin(), sorted_indices.end(), [this](int a, int b) { int id_a = sequence_to_compressed_id[a]; int id_b = sequence_to_compressed_id[b]; if (cached_coprime_degrees[id_a] != cached_coprime_degrees[id_b]) { return cached_coprime_degrees[id_a] \u003c cached_coprime_degrees[id_b]; } return a \u003c b; }); // Try combinations with bounded search constexpr int SEARCH_WIDTH = 30; for (int primary_index : sorted_indices) { vector\u003cint\u003e candidates; candidates.reserve(SEARCH_WIDTH); for (int partner = 1; partner \u003c= spec.element_count \u0026\u0026 static_cast\u003cint\u003e(candidates.size()) \u003c SEARCH_WIDTH; ++partner) { if (partner != primary_index \u0026\u0026 gcd(spec.sequence[primary_index], spec.sequence[partner]) == 1) { candidates.push_back(partner); } } for (int secondary_index : candidates) { // Try this pair and search for remaining coprime pair // ... implementation details ... } } 5. Modern C++ implementation choices The implementation leverages several modern C++ features and idioms for improved performance and readability.\n5.1 Structured bindings and auto declarations Modern C++ structured bindings enhance code readability:\nauto [iter, inserted] = compression_map.try_emplace(value, compressed_data.size()); auto [third, fourth] = filtered_coprime_search(leaf_index, partner); 5.2 std::span For zero-copy views Using std::span (C++20) allows passing array views without copying:\nvoid compress(span\u003cconst int\u003e input_sequence) { // Process without copying the input data } 5.3 Designated initializers C++20 designated initializers improve struct initialization clarity:\ncompressed_data.push_back({ .original = value, .compressed_id = static_cast\u003cint\u003e(compressed_data.size() - 1), .occurrence_indices = {static_cast\u003cint\u003e(idx + 1)}, .squarefree_factors = NT_ENGINE.factorize_squarefree(value) }); 5.4 Constexpr and compile-time optimization Using constexpr enables compile-time computation where possible:\nstatic constexpr size_t LIMIT = 1000001; constexpr int SEARCH_WIDTH = 30; 5.5 Memory management and cache optimization Strategic use of reserve() prevents vector reallocations:\nprime_list.reserve(80000); // Approximate prime count for better cache locality candidates.reserve(SEARCH_WIDTH); 6. Complexity Analysis 6.1 Time complexity Analyzing each component:\nSieve Preprocessing: $O(m)$ using linear sieve Square-free Divisor Computation: $O(U \\times 2^{\\omega(\\text{max})})$ where $\\omega(n)$ is the number of distinct primes Divisibility Counting: $O(m \\log m)$ Phases 1-3: $O(n)$ each Phase 4: $O(n \\times \\min(n, 30)) = O(n \\times 30)$ with bounded search Total Complexity: $O(m \\log m + n \\times 30 + U \\times 2^{\\omega(\\text{max})})$\nIn practice, for the problem constraints ($m \\leq 10^6$, $n \\leq 2 \\times 10^5$), the algorithm operates in near-linear time for most inputs.\n6.2 Space complexity The main data structures require:\nSieve: $O(m)$ Square-free divisors: $O(U \\times d(\\text{max}))$ Divisibility counts: $O(m)$ Auxiliary structures: $O(n)$ Total Space: $O(m + n + U \\times d(\\text{max}))$\n7. Performance considerations and optimizations 7.1 Incremental updates Instead of recalculating degrees after each element “removal,” we update incrementally:\nvoid modify_element_presence(const vector\u003cint\u003e\u0026 squarefree_factors, int delta) { for (int divisor : squarefree_factors) { divisor_multiplicities[divisor] += delta; } } This reduces the cost of each update from $O(m)$ to $O(d(\\text{value}))$, typically very small.\n7.2 Precomputation and caching All values depending only on unique values are computed once:\nvector\u003cint\u003e cached_coprime_degrees; // Precomputed coprime degrees per unique value vector\u003cint\u003e cached_original_values; // Original values per compressed ID vector\u003cvector\u003cint\u003e\u003e cached_occurrences; // Occurrence indices per compressed ID 7.3 Early termination Each phase terminates as soon as it finds a solution, avoiding unnecessary computations:\nvoid solve() { if (handle_unit_values()) return; if (exploit_duplicates()) return; if (handle_single_unit()) return; if (process_leaf_vertices()) return; if (general_search()) return; cout \u003c\u003c \"0\\n\"; // No solution } 8. Conclusion The resolution of the “Sea, You \u0026 copriMe” problem constitutes an excellent example of how the synergistic application of concepts from different areas of mathematics and computer science can lead to efficient solutions for computationally challenging problems. The pillars of this solution have been:\nProblem Abstraction: Translating the problem into a graph model provided the conceptual framework for reasoning about its structure.\nPower of Number Theory: The employment of the Möbius function and inclusion-exclusion principle proved fundamental for performing otherwise prohibitive calculations.\nStratified Algorithm Design: Prioritized handling of special and simple cases allowed avoiding complex computations for a vast class of inputs.\nEffective Heuristics: The use of heuristics, such as priority to low-degree vertices and bounded search, drastically reduced the search space while maintaining solution correctness.\nModern C++ Implementation: Leveraging modern C++ features like structured bindings, std::span, and designated initializers improved both performance and code readability.\nThis approach demonstrates that, even in the modern context, mastery of classical algorithms and fundamental mathematical structures remains an irreplaceable and highly powerful tool for software engineering and complex problem solving. The combination of theoretical insights with practical implementation considerations showcases the elegance that can be achieved when mathematical rigor meets engineering pragmatism.\n","wordCount":"2423","inLanguage":"en","image":"https://lcs-developer.com/images/LCS.Dev-Logo.jpg","datePublished":"2025-08-26T22:10:00.000535Z","dateModified":"2025-08-26T22:10:00.000535Z","author":{"@type":"Person","name":"LCS.Dev"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lcs-developer.com/posts/a-number-theory-problem/"},"publisher":{"@type":"Organization","name":"LCS.Developer","logo":{"@type":"ImageObject","url":"https://lcs-developer.com/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://lcs-developer.com/ accesskey=h title="LCS.Dev - CS Topics (Alt + H)"><img src=https://lcs-developer.com/%F0%9F%91%A8%E2%80%8D%F0%9F%92%BB alt aria-label=logo height=35>LCS.Dev - CS Topics</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://lcs-developer.com/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://lcs-developer.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://lcs-developer.com/about/ title=About><span>About</span></a></li><li><a href=https://lcs-developer.com/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://lcs-developer.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://lcs-developer.com/>Home</a>&nbsp;»&nbsp;<a href=https://lcs-developer.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Un problema di Teoria dei Numeri</h1><div class=post-meta><span title='2025-08-26 22:10:00.000535 +0000 UTC'>August 26, 2025</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;2423 words&nbsp;·&nbsp;LCS.Dev&nbsp;|&nbsp;<a href=https://github.com/XtremeXSPC/LCS.Dev-Blog/tree/hostinger//posts/A%20Number%20Theory%20Problem.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#abstract>Abstract</a></li><li><a href=#1-problem-formulation-and-introduction>1. Problem formulation and introduction</a></li><li><a href=#2-the-coprimality-graph-a-structural-perspective>2. The coprimality graph: a structural perspective</a></li><li><a href=#3-fundamental-tools-from-number-theory>3. Fundamental tools from number theory</a><ul><li><a href=#31-the-inclusion-exclusion-principle-and-the-möbius-function>3.1 The inclusion-exclusion principle and the möbius function</a></li><li><a href=#32-concrete-example>3.2 Concrete example</a></li><li><a href=#33-implementation-of-the-linear-sieve>3.3 Implementation of the linear sieve</a></li></ul></li><li><a href=#4-a-stratified-algorithmic-strategy>4. A stratified algorithmic strategy</a><ul><li><a href=#phase-0-preprocessing-and-data-structures>Phase 0: Preprocessing and data structures</a></li><li><a href=#phase-1-handling-unit-values>Phase 1: Handling unit values</a></li><li><a href=#phase-2-exploiting-duplicate-values>Phase 2: Exploiting duplicate values</a></li><li><a href=#phase-3-single-unit-case>Phase 3: Single unit case</a></li><li><a href=#phase-4-degree-based-heuristic-search>Phase 4: Degree-based heuristic search</a></li></ul></li><li><a href=#5-modern-c-implementation-choices>5. Modern C++ implementation choices</a><ul><li><a href=#51-structured-bindings-and-auto-declarations>5.1 Structured bindings and auto declarations</a></li><li><a href=#52-stdspan-for-zero-copy-views>5.2 std::span For zero-copy views</a></li><li><a href=#53-designated-initializers>5.3 Designated initializers</a></li><li><a href=#54-constexpr-and-compile-time-optimization>5.4 Constexpr and compile-time optimization</a></li><li><a href=#55-memory-management-and-cache-optimization>5.5 Memory management and cache optimization</a></li></ul></li><li><a href=#6-complexity-analysis>6. Complexity Analysis</a><ul><li><a href=#61-time-complexity>6.1 Time complexity</a></li><li><a href=#62-space-complexity>6.2 Space complexity</a></li></ul></li><li><a href=#7-performance-considerations-and-optimizations>7. Performance considerations and optimizations</a><ul><li><a href=#71-incremental-updates>7.1 Incremental updates</a></li><li><a href=#72-precomputation-and-caching>7.2 Precomputation and caching</a></li><li><a href=#73-early-termination>7.3 Early termination</a></li></ul></li><li><a href=#8-conclusion>8. Conclusion</a></li></ul></nav></div></details></div><div class=post-content><h1 id=finding-coprime-quadruples-an-algorithmic-analysis-of-sea-you--coprime>Finding coprime quadruples: An algorithmic analysis of &ldquo;Sea, you & copriMe&rdquo;<a hidden class=anchor aria-hidden=true href=#finding-coprime-quadruples-an-algorithmic-analysis-of-sea-you--coprime>#</a></h1><h2 id=abstract>Abstract<a hidden class=anchor aria-hidden=true href=#abstract>#</a></h2><p>This article presents a comprehensive algorithmic analysis and solution to the problem of finding quadruples of distinct indices in an integer array that form two coprime pairs. While originating from competitive programming, this problem offers an excellent opportunity to explore the intersections between number theory, graph theory, and efficient algorithm design. We demonstrate how the combination of concepts such as the Sieve of Eratosthenes, the Möbius function, the inclusion-exclusion principle, and heuristic search strategies enables the development of a robust and elegant solution. The final implementation demonstrates how deep understanding of underlying mathematical properties is fundamental to achieving decisive algorithmic optimizations.</p><hr><h2 id=1-problem-formulation-and-introduction>1. Problem formulation and introduction<a hidden class=anchor aria-hidden=true href=#1-problem-formulation-and-introduction>#</a></h2><p>In the realm of algorithmic problem solving, certain challenges distinguish themselves through an apparently simple formulation that conceals considerable computational complexity. The problem under examination, titled &ldquo;Sea, You & copriMe,&rdquo; belongs entirely to this category. Its formal definition is as follows:</p><p><strong>Input:</strong></p><ul><li>An array $a$ of $n$ integers, where $4 \leq n \leq 200,000$</li><li>Each element $a_i$ of the array is within the interval $[1, m]$, where $1 \leq m \leq 1,000,000$</li></ul><p><strong>Output:</strong></p><ul><li>Four distinct indices $(p, q, r, s)$ such that the greatest common divisor of the corresponding element pairs is unity:<ul><li>$\gcd(a_p, a_q) = 1$</li><li>$\gcd(a_r, a_s) = 1$</li></ul></li><li>If no such quadruple exists, the output should be <code>0</code></li></ul><p>The primary challenge lies in the dimensional constraints of the input. A brute force approach examining all possible combinations of four indices would result in $O(n^4)$ time complexity, a prohibitive value for $n$ on the order of $2 \times 10^5$. It is therefore imperative to develop a strategy that exploits the intrinsic mathematical structure of the problem to drastically reduce the solution space to be explored.</p><hr><h2 id=2-the-coprimality-graph-a-structural-perspective>2. The coprimality graph: a structural perspective<a hidden class=anchor aria-hidden=true href=#2-the-coprimality-graph-a-structural-perspective>#</a></h2><p>A fundamental initial insight for approaching this problem consists of reformulating it in terms of graph theory. We can model the coprimality relationships between array elements through an undirected graph $G = (V, E)$, defined as follows:</p><ul><li>The vertex set $V = {1, 2, \ldots, n}$ represents the indices of array $a$</li><li>An edge $(i, j)$ belongs to the edge set $E$ if and only if the corresponding elements are coprime, i.e., $\gcd(a_i, a_j) = 1$</li></ul><p>In this new perspective, the problem translates to finding two edges in $G$ that share no vertices, essentially a <strong>matching</strong> of size two. This abstraction not only clarifies the problem structure but also opens the way to various algorithmic strategies based on graph properties.</p><p>We define the <strong>coprimality degree</strong> of a vertex $i$ as the number of edges incident to it, which corresponds to the number of elements in the array that are coprime with $a_i$:</p><p>$$\deg(i) = |{j \in V, j \neq i \mid \gcd(a_i, a_j) = 1}|$$</p><p>Elements with low coprimality degree represent &ldquo;scarce resources&rdquo; in our graph. For example, a vertex with degree 1 (a &ldquo;leaf vertex&rdquo;) has only one potential partner to form a coprime pair. Prioritized management of such vertices will prove to be an effective heuristic strategy.</p><hr><h2 id=3-fundamental-tools-from-number-theory>3. Fundamental tools from number theory<a hidden class=anchor aria-hidden=true href=#3-fundamental-tools-from-number-theory>#</a></h2><p>To navigate efficiently in the coprimality graph, particularly to calculate vertex degrees, it is necessary to resort to advanced tools from number theory.</p><h3 id=31-the-inclusion-exclusion-principle-and-the-möbius-function>3.1 The inclusion-exclusion principle and the möbius function<a hidden class=anchor aria-hidden=true href=#31-the-inclusion-exclusion-principle-and-the-möbius-function>#</a></h3><p>The efficient calculation of the number of elements in a set that are coprime with a given integer $x$ is a classic problem. The most elegant solution employs the inclusion-exclusion principle, formalized through the <strong>Möbius function</strong>, $\mu(n)$. This function is defined for every positive integer $n$ as follows:</p><p>$$\mu(n) = \begin{cases} 1 & \text{if } n \text{ is square-free with an even number of distinct prime factors} \ -1 & \text{if } n \text{ is square-free with an odd number of distinct prime factors} \ 0 & \text{if } n \text{ has a squared prime factor} \end{cases}$$</p><p>An integer is called &ldquo;square-free&rdquo; if it is not divisible by any perfect square other than 1.</p><p>The theorem linking the Möbius function to our problem states that, given an integer $x$ and a multiset $S$ of integers, the number of elements in $S$ that are coprime with $x$ is given by:</p><p>$$\text{count_coprime}(x, S) = \sum_{d \mid x, \mu(d) \neq 0} \mu(d) \cdot |{s \in S : d \mid s}|$$</p><p>This formula allows us to calculate the coprimality degree of an element without having to test every individual pair. Instead of $O(n)$ gcd operations, we can perform the calculation based on the divisors of $x$.</p><h3 id=32-concrete-example>3.2 Concrete example<a hidden class=anchor aria-hidden=true href=#32-concrete-example>#</a></h3><p>Suppose we want to calculate the number of elements coprime with $x = 6$ in a multiset $S$ where the counts of multiples are already known: $|S_1|=10, |S_2|=5, |S_3|=3, |S_6|=1$.</p><p>The square-free divisors of 6 are ${1, 2, 3, 6}$.</p><p>The Möbius function values are: $\mu(1)=1, \mu(2)=-1, \mu(3)=-1, \mu(6)=1$.</p><p>Applying the formula:</p><p>$$\text{count_coprime}(6, S) = \mu(1)|S_1| + \mu(2)|S_2| + \mu(3)|S_3| + \mu(6)|S_6|$$</p><p>$$\text{count_coprime}(6, S) = (1 \cdot 10) + (-1 \cdot 5) + (-1 \cdot 3) + (1 \cdot 1) = 10 - 5 - 3 + 1 = 3$$</p><h3 id=33-implementation-of-the-linear-sieve>3.3 Implementation of the linear sieve<a hidden class=anchor aria-hidden=true href=#33-implementation-of-the-linear-sieve>#</a></h3><p>To use the previous formula, we need the values of the Möbius function and the prime factors of integers up to $m$. A <strong>linear sieve</strong> is the ideal tool for this precomputation in $O(m)$ time.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>NumberTheoryEngine</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>static</span> <span class=k>constexpr</span> <span class=n>size_t</span> <span class=n>LIMIT</span> <span class=o>=</span> <span class=mi>1000001</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>array</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>LIMIT</span><span class=o>&gt;</span> <span class=n>minimal_prime</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>array</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>LIMIT</span><span class=o>&gt;</span> <span class=n>moebius</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>NumberTheoryEngine</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>iota</span><span class=p>(</span><span class=n>minimal_prime</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>minimal_prime</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fill</span><span class=p>(</span><span class=n>moebius</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>moebius</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>moebius</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>prime_list</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>prime_list</span><span class=p>.</span><span class=n>reserve</span><span class=p>(</span><span class=mi>80000</span><span class=p>);</span> <span class=c1>// Approximate prime count
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>LIMIT</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>minimal_prime</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>i</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>prime_list</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>moebius</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=nl>prime</span> <span class=p>:</span> <span class=n>prime_list</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>prime</span> <span class=o>&gt;</span> <span class=n>minimal_prime</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>||</span> 
</span></span><span class=line><span class=cl>            <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>ll</span><span class=o>&gt;</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=o>*</span> <span class=n>prime</span> <span class=o>&gt;=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>ll</span><span class=o>&gt;</span><span class=p>(</span><span class=n>LIMIT</span><span class=p>))</span>
</span></span><span class=line><span class=cl>          <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>minimal_prime</span><span class=p>[</span><span class=n>i</span> <span class=o>*</span> <span class=n>prime</span><span class=p>]</span> <span class=o>=</span> <span class=n>prime</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>moebius</span><span class=p>[</span><span class=n>i</span> <span class=o>*</span> <span class=n>prime</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>prime</span> <span class=o>==</span> <span class=n>minimal_prime</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=o>?</span> <span class=mi>0</span> <span class=o>:</span> <span class=o>-</span><span class=n>moebius</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>This linear sieve implementation efficiently computes both the smallest prime factor and Möbius function values for all numbers up to the limit, enabling fast factorization and coprimality calculations.</p><hr><h2 id=4-a-stratified-algorithmic-strategy>4. A stratified algorithmic strategy<a hidden class=anchor aria-hidden=true href=#4-a-stratified-algorithmic-strategy>#</a></h2><p>The algorithm adopts a multi-phase approach designed to solve the problem as efficiently as possible.</p><h3 id=phase-0-preprocessing-and-data-structures>Phase 0: Preprocessing and data structures<a hidden class=anchor aria-hidden=true href=#phase-0-preprocessing-and-data-structures>#</a></h3><p>The first step consists of preparing the data structures that will support subsequent phases:</p><ol><li><strong>Linear sieve execution</strong>: Computing Möbius values and prime factorizations</li><li><strong>Frequency and divisibility counting</strong>: Building frequency arrays for efficient lookups</li><li><strong>Value compression</strong>: Identifying unique values and storing their properties</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>ValueCompressor</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=nc>CompressedValue</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>original</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>compressed_id</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>occurrence_indices</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>squarefree_factors</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>unordered_map</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>size_t</span><span class=o>&gt;</span> <span class=n>compression_map</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>vector</span><span class=o>&lt;</span><span class=n>CompressedValue</span><span class=o>&gt;</span> <span class=n>compressed_data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=n>compress</span><span class=p>(</span><span class=n>span</span><span class=o>&lt;</span><span class=k>const</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>input_sequence</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>compression_map</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>compressed_data</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>compression_map</span><span class=p>.</span><span class=n>reserve</span><span class=p>(</span><span class=n>input_sequence</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>idx</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>idx</span> <span class=o>&lt;</span> <span class=n>input_sequence</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=o>++</span><span class=n>idx</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=kt>int</span> <span class=n>value</span> <span class=o>=</span> <span class=n>input_sequence</span><span class=p>[</span><span class=n>idx</span><span class=p>];</span>
</span></span><span class=line><span class=cl>      
</span></span><span class=line><span class=cl>      <span class=k>auto</span> <span class=p>[</span><span class=n>iter</span><span class=p>,</span> <span class=n>inserted</span><span class=p>]</span> <span class=o>=</span> <span class=n>compression_map</span><span class=p>.</span><span class=n>try_emplace</span><span class=p>(</span><span class=n>value</span><span class=p>,</span> <span class=n>compressed_data</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>inserted</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>compressed_data</span><span class=p>.</span><span class=n>push_back</span><span class=p>({</span>
</span></span><span class=line><span class=cl>          <span class=p>.</span><span class=n>original</span> <span class=o>=</span> <span class=n>value</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=p>.</span><span class=n>compressed_id</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>compressed_data</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>-</span> <span class=mi>1</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=p>.</span><span class=n>occurrence_indices</span> <span class=o>=</span> <span class=p>{</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>idx</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)},</span> <span class=c1>// 1-indexed
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=p>.</span><span class=n>squarefree_factors</span> <span class=o>=</span> <span class=n>NT_ENGINE</span><span class=p>.</span><span class=n>factorize_squarefree</span><span class=p>(</span><span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>});</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>compressed_data</span><span class=p>[</span><span class=n>iter</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>].</span><span class=n>occurrence_indices</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>idx</span> <span class=o>+</span> <span class=mi>1</span><span class=p>));</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=phase-1-handling-unit-values>Phase 1: Handling unit values<a hidden class=anchor aria-hidden=true href=#phase-1-handling-unit-values>#</a></h3><p>The value 1 is exceptional since $\gcd(1, k) = 1$ for any $k$. Its presence simplifies the search significantly:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>UnitValueStrategy</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>static</span> <span class=k>auto</span> <span class=nf>execute</span><span class=p>(</span><span class=n>span</span><span class=o>&lt;</span><span class=k>const</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>unit_indices</span><span class=p>,</span> <span class=n>span</span><span class=o>&lt;</span><span class=k>const</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>sequence</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>MaybeSolution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=n>unit_count</span> <span class=o>=</span> <span class=n>unit_indices</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>unit_count</span> <span class=o>&gt;=</span> <span class=mi>4</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>Quadruple</span><span class=p>{</span><span class=n>unit_indices</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>unit_indices</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>unit_indices</span><span class=p>[</span><span class=mi>2</span><span class=p>],</span> <span class=n>unit_indices</span><span class=p>[</span><span class=mi>3</span><span class=p>]};</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>unit_count</span> <span class=o>==</span> <span class=mi>3</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>sequence</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>sequence</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>!=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=k>return</span> <span class=n>Quadruple</span><span class=p>{</span><span class=n>unit_indices</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>unit_indices</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>unit_indices</span><span class=p>[</span><span class=mi>2</span><span class=p>],</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>i</span><span class=p>)};</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>nullopt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>unit_count</span> <span class=o>==</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>non_units</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>sequence</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=n>non_units</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>&lt;</span> <span class=mi>2</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>sequence</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>!=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=n>non_units</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>i</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>non_units</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>&gt;=</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>Quadruple</span><span class=p>{</span><span class=n>unit_indices</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>non_units</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>unit_indices</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>non_units</span><span class=p>[</span><span class=mi>1</span><span class=p>]};</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>nullopt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=phase-2-exploiting-duplicate-values>Phase 2: Exploiting duplicate values<a hidden class=anchor aria-hidden=true href=#phase-2-exploiting-duplicate-values>#</a></h3><p>If a value $v > 1$ appears multiple times and has sufficient coprimes, the solution becomes straightforward:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Phase 2: Duplicate value exploitation
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>id</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>id</span> <span class=o>&lt;</span> <span class=n>compressor</span><span class=p>.</span><span class=n>unique_count</span><span class=p>();</span> <span class=o>++</span><span class=n>id</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>cached_occurrences</span><span class=p>[</span><span class=n>id</span><span class=p>].</span><span class=n>size</span><span class=p>()</span> <span class=o>&gt;=</span> <span class=mi>2</span> <span class=o>&amp;&amp;</span> <span class=n>cached_original_values</span><span class=p>[</span><span class=n>id</span><span class=p>]</span> <span class=o>!=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>coprime_candidates</span> <span class=o>=</span> <span class=n>cached_coprime_degrees</span><span class=p>[</span><span class=n>id</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>coprime_candidates</span> <span class=o>&gt;=</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>partners</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>spec</span><span class=p>.</span><span class=n>element_count</span> <span class=o>&amp;&amp;</span> <span class=n>partners</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>&lt;</span> <span class=mi>2</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>gcd</span><span class=p>(</span><span class=n>cached_original_values</span><span class=p>[</span><span class=n>id</span><span class=p>],</span> <span class=n>spec</span><span class=p>.</span><span class=n>sequence</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=n>partners</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>partners</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>&gt;=</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>output_solution</span><span class=p>({</span><span class=n>cached_occurrences</span><span class=p>[</span><span class=n>id</span><span class=p>][</span><span class=mi>0</span><span class=p>],</span> <span class=n>partners</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> 
</span></span><span class=line><span class=cl>                        <span class=n>cached_occurrences</span><span class=p>[</span><span class=n>id</span><span class=p>][</span><span class=mi>1</span><span class=p>],</span> <span class=n>partners</span><span class=p>[</span><span class=mi>1</span><span class=p>]});</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=phase-3-single-unit-case>Phase 3: Single unit case<a hidden class=anchor aria-hidden=true href=#phase-3-single-unit-case>#</a></h3><p>When exactly one &lsquo;1&rsquo; exists in the array, it guarantees one coprime pair. The problem reduces to finding a second coprime pair among the remaining elements:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=nf>handle_single_unit_case</span><span class=p>(</span><span class=kt>int</span> <span class=n>unit_index</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>MaybeSolution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Find any coprime pair among non-unit values
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>id</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>id</span> <span class=o>&lt;</span> <span class=n>compressor</span><span class=p>.</span><span class=n>unique_count</span><span class=p>();</span> <span class=o>++</span><span class=n>id</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>cached_original_values</span><span class=p>[</span><span class=n>id</span><span class=p>]</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>non_unit_coprimes</span> <span class=o>=</span> <span class=n>cached_coprime_degrees</span><span class=p>[</span><span class=n>id</span><span class=p>]</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>// Exclude the unit
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>non_unit_coprimes</span> <span class=o>&lt;</span> <span class=mi>1</span><span class=p>)</span> <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>first_index</span> <span class=o>=</span> <span class=n>cached_occurrences</span><span class=p>[</span><span class=n>id</span><span class=p>][</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>partner</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>partner</span> <span class=o>&lt;=</span> <span class=n>spec</span><span class=p>.</span><span class=n>element_count</span><span class=p>;</span> <span class=o>++</span><span class=n>partner</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>partner</span> <span class=o>==</span> <span class=n>unit_index</span> <span class=o>||</span> <span class=n>partner</span> <span class=o>==</span> <span class=n>first_index</span><span class=p>)</span> <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>gcd</span><span class=p>(</span><span class=n>cached_original_values</span><span class=p>[</span><span class=n>id</span><span class=p>],</span> <span class=n>spec</span><span class=p>.</span><span class=n>sequence</span><span class=p>[</span><span class=n>partner</span><span class=p>])</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>fourth</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>fourth</span> <span class=o>&lt;=</span> <span class=n>spec</span><span class=p>.</span><span class=n>element_count</span><span class=p>;</span> <span class=o>++</span><span class=n>fourth</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=k>if</span> <span class=p>(</span><span class=n>fourth</span> <span class=o>!=</span> <span class=n>unit_index</span> <span class=o>&amp;&amp;</span> <span class=n>fourth</span> <span class=o>!=</span> <span class=n>first_index</span> <span class=o>&amp;&amp;</span> <span class=n>fourth</span> <span class=o>!=</span> <span class=n>partner</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>Quadruple</span><span class=p>{</span><span class=n>first_index</span><span class=p>,</span> <span class=n>partner</span><span class=p>,</span> <span class=n>unit_index</span><span class=p>,</span> <span class=n>fourth</span><span class=p>};</span>
</span></span><span class=line><span class=cl>          <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>nullopt</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=phase-4-degree-based-heuristic-search>Phase 4: Degree-based heuristic search<a hidden class=anchor aria-hidden=true href=#phase-4-degree-based-heuristic-search>#</a></h3><p>When special cases fail, we resort to a more sophisticated search based on coprimality degrees.</p><h4 id=41-prioritizing-leaf-vertices>4.1 Prioritizing leaf vertices<a hidden class=anchor aria-hidden=true href=#41-prioritizing-leaf-vertices>#</a></h4><p>Vertices with degree 1 (leaves in the graph) are critical: they have only one possible partner. If we don&rsquo;t pair them immediately, they might block future solutions:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Handle leaf vertices (degree 1)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>value_id</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>value_id</span> <span class=o>&lt;</span> <span class=n>compressor</span><span class=p>.</span><span class=n>unique_count</span><span class=p>();</span> <span class=o>++</span><span class=n>value_id</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>cached_coprime_degrees</span><span class=p>[</span><span class=n>value_id</span><span class=p>]</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>leaf_index</span> <span class=o>=</span> <span class=n>cached_occurrences</span><span class=p>[</span><span class=n>value_id</span><span class=p>][</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>partner</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>partner</span> <span class=o>&lt;=</span> <span class=n>spec</span><span class=p>.</span><span class=n>element_count</span><span class=p>;</span> <span class=o>++</span><span class=n>partner</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>partner</span> <span class=o>!=</span> <span class=n>leaf_index</span> <span class=o>&amp;&amp;</span> 
</span></span><span class=line><span class=cl>          <span class=n>gcd</span><span class=p>(</span><span class=n>cached_original_values</span><span class=p>[</span><span class=n>value_id</span><span class=p>],</span> <span class=n>spec</span><span class=p>.</span><span class=n>sequence</span><span class=p>[</span><span class=n>partner</span><span class=p>])</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// Temporarily remove both from consideration
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>analyzer</span><span class=o>-&gt;</span><span class=n>modify_element_presence</span><span class=p>(</span><span class=n>cached_squarefree_factors</span><span class=p>[</span><span class=n>value_id</span><span class=p>],</span> <span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>analyzer</span><span class=o>-&gt;</span><span class=n>modify_element_presence</span><span class=p>(</span><span class=n>cached_squarefree_factors</span><span class=p>[</span><span class=n>partner_id</span><span class=p>],</span> <span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=p>[</span><span class=n>third</span><span class=p>,</span> <span class=n>fourth</span><span class=p>]</span> <span class=o>=</span> <span class=n>filtered_coprime_search</span><span class=p>(</span><span class=n>leaf_index</span><span class=p>,</span> <span class=n>partner</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>third</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=k>return</span> <span class=n>Quadruple</span><span class=p>{</span><span class=n>leaf_index</span><span class=p>,</span> <span class=n>partner</span><span class=p>,</span> <span class=n>third</span><span class=p>,</span> <span class=n>fourth</span><span class=p>};</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// Restore
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>analyzer</span><span class=o>-&gt;</span><span class=n>modify_element_presence</span><span class=p>(</span><span class=n>cached_squarefree_factors</span><span class=p>[</span><span class=n>value_id</span><span class=p>],</span> <span class=o>+</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>analyzer</span><span class=o>-&gt;</span><span class=n>modify_element_presence</span><span class=p>(</span><span class=n>cached_squarefree_factors</span><span class=p>[</span><span class=n>partner_id</span><span class=p>],</span> <span class=o>+</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// Leaf can&#39;t form solution - no solution exists
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=n>nullopt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=42-bounded-search-with-degree-ordering>4.2 Bounded search with degree ordering<a hidden class=anchor aria-hidden=true href=#42-bounded-search-with-degree-ordering>#</a></h4><p>For remaining elements, we sort by increasing degree and apply bounded search:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Build list of ALL indices sorted by degree of their VALUE
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>sorted_indices</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>sorted_indices</span><span class=p>.</span><span class=n>reserve</span><span class=p>(</span><span class=n>spec</span><span class=p>.</span><span class=n>element_count</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>value_id</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>value_id</span> <span class=o>&lt;</span> <span class=n>compressor</span><span class=p>.</span><span class=n>unique_count</span><span class=p>();</span> <span class=o>++</span><span class=n>value_id</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>cached_coprime_degrees</span><span class=p>[</span><span class=n>value_id</span><span class=p>]</span> <span class=o>&gt;=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=nl>idx</span> <span class=p>:</span> <span class=n>cached_occurrences</span><span class=p>[</span><span class=n>value_id</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>sorted_indices</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>idx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Sort by degree of the value, then by index
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>sort</span><span class=p>(</span><span class=n>sorted_indices</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>sorted_indices</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=p>[</span><span class=k>this</span><span class=p>](</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>id_a</span> <span class=o>=</span> <span class=n>sequence_to_compressed_id</span><span class=p>[</span><span class=n>a</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>id_b</span> <span class=o>=</span> <span class=n>sequence_to_compressed_id</span><span class=p>[</span><span class=n>b</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>cached_coprime_degrees</span><span class=p>[</span><span class=n>id_a</span><span class=p>]</span> <span class=o>!=</span> <span class=n>cached_coprime_degrees</span><span class=p>[</span><span class=n>id_b</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>cached_coprime_degrees</span><span class=p>[</span><span class=n>id_a</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>cached_coprime_degrees</span><span class=p>[</span><span class=n>id_b</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>a</span> <span class=o>&lt;</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Try combinations with bounded search
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>constexpr</span> <span class=kt>int</span> <span class=n>SEARCH_WIDTH</span> <span class=o>=</span> <span class=mi>30</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=nl>primary_index</span> <span class=p>:</span> <span class=n>sorted_indices</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>candidates</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>candidates</span><span class=p>.</span><span class=n>reserve</span><span class=p>(</span><span class=n>SEARCH_WIDTH</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>partner</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>partner</span> <span class=o>&lt;=</span> <span class=n>spec</span><span class=p>.</span><span class=n>element_count</span> <span class=o>&amp;&amp;</span> 
</span></span><span class=line><span class=cl>       <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>candidates</span><span class=p>.</span><span class=n>size</span><span class=p>())</span> <span class=o>&lt;</span> <span class=n>SEARCH_WIDTH</span><span class=p>;</span> <span class=o>++</span><span class=n>partner</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>partner</span> <span class=o>!=</span> <span class=n>primary_index</span> <span class=o>&amp;&amp;</span> 
</span></span><span class=line><span class=cl>        <span class=n>gcd</span><span class=p>(</span><span class=n>spec</span><span class=p>.</span><span class=n>sequence</span><span class=p>[</span><span class=n>primary_index</span><span class=p>],</span> <span class=n>spec</span><span class=p>.</span><span class=n>sequence</span><span class=p>[</span><span class=n>partner</span><span class=p>])</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>candidates</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>partner</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=nl>secondary_index</span> <span class=p>:</span> <span class=n>candidates</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Try this pair and search for remaining coprime pair
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// ... implementation details ...
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><hr><h2 id=5-modern-c-implementation-choices>5. Modern C++ implementation choices<a hidden class=anchor aria-hidden=true href=#5-modern-c-implementation-choices>#</a></h2><p>The implementation leverages several modern C++ features and idioms for improved performance and readability.</p><h3 id=51-structured-bindings-and-auto-declarations>5.1 Structured bindings and auto declarations<a hidden class=anchor aria-hidden=true href=#51-structured-bindings-and-auto-declarations>#</a></h3><p>Modern C++ structured bindings enhance code readability:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=p>[</span><span class=n>iter</span><span class=p>,</span> <span class=n>inserted</span><span class=p>]</span> <span class=o>=</span> <span class=n>compression_map</span><span class=p>.</span><span class=n>try_emplace</span><span class=p>(</span><span class=n>value</span><span class=p>,</span> <span class=n>compressed_data</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=p>[</span><span class=n>third</span><span class=p>,</span> <span class=n>fourth</span><span class=p>]</span> <span class=o>=</span> <span class=n>filtered_coprime_search</span><span class=p>(</span><span class=n>leaf_index</span><span class=p>,</span> <span class=n>partner</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=52-stdspan-for-zero-copy-views>5.2 std::span For zero-copy views<a hidden class=anchor aria-hidden=true href=#52-stdspan-for-zero-copy-views>#</a></h3><p>Using <code>std::span</code> (C++20) allows passing array views without copying:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>compress</span><span class=p>(</span><span class=n>span</span><span class=o>&lt;</span><span class=k>const</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>input_sequence</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Process without copying the input data
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=53-designated-initializers>5.3 Designated initializers<a hidden class=anchor aria-hidden=true href=#53-designated-initializers>#</a></h3><p>C++20 designated initializers improve struct initialization clarity:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>compressed_data</span><span class=p>.</span><span class=n>push_back</span><span class=p>({</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=n>original</span> <span class=o>=</span> <span class=n>value</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=n>compressed_id</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>compressed_data</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>-</span> <span class=mi>1</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=n>occurrence_indices</span> <span class=o>=</span> <span class=p>{</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>idx</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)},</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=n>squarefree_factors</span> <span class=o>=</span> <span class=n>NT_ENGINE</span><span class=p>.</span><span class=n>factorize_squarefree</span><span class=p>(</span><span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></div><h3 id=54-constexpr-and-compile-time-optimization>5.4 Constexpr and compile-time optimization<a hidden class=anchor aria-hidden=true href=#54-constexpr-and-compile-time-optimization>#</a></h3><p>Using <code>constexpr</code> enables compile-time computation where possible:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>static</span> <span class=k>constexpr</span> <span class=n>size_t</span> <span class=n>LIMIT</span> <span class=o>=</span> <span class=mi>1000001</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=kt>int</span> <span class=n>SEARCH_WIDTH</span> <span class=o>=</span> <span class=mi>30</span><span class=p>;</span>
</span></span></code></pre></div><h3 id=55-memory-management-and-cache-optimization>5.5 Memory management and cache optimization<a hidden class=anchor aria-hidden=true href=#55-memory-management-and-cache-optimization>#</a></h3><p>Strategic use of <code>reserve()</code> prevents vector reallocations:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>prime_list</span><span class=p>.</span><span class=n>reserve</span><span class=p>(</span><span class=mi>80000</span><span class=p>);</span> <span class=c1>// Approximate prime count for better cache locality
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>candidates</span><span class=p>.</span><span class=n>reserve</span><span class=p>(</span><span class=n>SEARCH_WIDTH</span><span class=p>);</span>
</span></span></code></pre></div><hr><h2 id=6-complexity-analysis>6. Complexity Analysis<a hidden class=anchor aria-hidden=true href=#6-complexity-analysis>#</a></h2><h3 id=61-time-complexity>6.1 Time complexity<a hidden class=anchor aria-hidden=true href=#61-time-complexity>#</a></h3><p>Analyzing each component:</p><ol><li><strong>Sieve Preprocessing</strong>: $O(m)$ using linear sieve</li><li><strong>Square-free Divisor Computation</strong>: $O(U \times 2^{\omega(\text{max})})$ where $\omega(n)$ is the number of distinct primes</li><li><strong>Divisibility Counting</strong>: $O(m \log m)$</li><li><strong>Phases 1-3</strong>: $O(n)$ each</li><li><strong>Phase 4</strong>: $O(n \times \min(n, 30)) = O(n \times 30)$ with bounded search</li></ol><p><strong>Total Complexity</strong>: $O(m \log m + n \times 30 + U \times 2^{\omega(\text{max})})$</p><p>In practice, for the problem constraints ($m \leq 10^6$, $n \leq 2 \times 10^5$), the algorithm operates in near-linear time for most inputs.</p><h3 id=62-space-complexity>6.2 Space complexity<a hidden class=anchor aria-hidden=true href=#62-space-complexity>#</a></h3><p>The main data structures require:</p><ul><li>Sieve: $O(m)$</li><li>Square-free divisors: $O(U \times d(\text{max}))$</li><li>Divisibility counts: $O(m)$</li><li>Auxiliary structures: $O(n)$</li></ul><p><strong>Total Space</strong>: $O(m + n + U \times d(\text{max}))$</p><hr><h2 id=7-performance-considerations-and-optimizations>7. Performance considerations and optimizations<a hidden class=anchor aria-hidden=true href=#7-performance-considerations-and-optimizations>#</a></h2><h3 id=71-incremental-updates>7.1 Incremental updates<a hidden class=anchor aria-hidden=true href=#71-incremental-updates>#</a></h3><p>Instead of recalculating degrees after each element &ldquo;removal,&rdquo; we update incrementally:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>modify_element_presence</span><span class=p>(</span><span class=k>const</span> <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>squarefree_factors</span><span class=p>,</span> <span class=kt>int</span> <span class=n>delta</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=nl>divisor</span> <span class=p>:</span> <span class=n>squarefree_factors</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>divisor_multiplicities</span><span class=p>[</span><span class=n>divisor</span><span class=p>]</span> <span class=o>+=</span> <span class=n>delta</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This reduces the cost of each update from $O(m)$ to $O(d(\text{value}))$, typically very small.</p><h3 id=72-precomputation-and-caching>7.2 Precomputation and caching<a hidden class=anchor aria-hidden=true href=#72-precomputation-and-caching>#</a></h3><p>All values depending only on unique values are computed once:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>cached_coprime_degrees</span><span class=p>;</span>    <span class=c1>// Precomputed coprime degrees per unique value
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>cached_original_values</span><span class=p>;</span>    <span class=c1>// Original values per compressed ID
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>vector</span><span class=o>&lt;</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>cached_occurrences</span><span class=p>;</span> <span class=c1>// Occurrence indices per compressed ID
</span></span></span></code></pre></div><h3 id=73-early-termination>7.3 Early termination<a hidden class=anchor aria-hidden=true href=#73-early-termination>#</a></h3><p>Each phase terminates as soon as it finds a solution, avoiding unnecessary computations:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>solve</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>handle_unit_values</span><span class=p>())</span> <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>exploit_duplicates</span><span class=p>())</span> <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>handle_single_unit</span><span class=p>())</span> <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>process_leaf_vertices</span><span class=p>())</span> <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>general_search</span><span class=p>())</span> <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;0</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>  <span class=c1>// No solution
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><hr><h2 id=8-conclusion>8. Conclusion<a hidden class=anchor aria-hidden=true href=#8-conclusion>#</a></h2><p>The resolution of the &ldquo;Sea, You & copriMe&rdquo; problem constitutes an excellent example of how the synergistic application of concepts from different areas of mathematics and computer science can lead to efficient solutions for computationally challenging problems. The pillars of this solution have been:</p><ol><li><p><strong>Problem Abstraction</strong>: Translating the problem into a graph model provided the conceptual framework for reasoning about its structure.</p></li><li><p><strong>Power of Number Theory</strong>: The employment of the Möbius function and inclusion-exclusion principle proved fundamental for performing otherwise prohibitive calculations.</p></li><li><p><strong>Stratified Algorithm Design</strong>: Prioritized handling of special and simple cases allowed avoiding complex computations for a vast class of inputs.</p></li><li><p><strong>Effective Heuristics</strong>: The use of heuristics, such as priority to low-degree vertices and bounded search, drastically reduced the search space while maintaining solution correctness.</p></li><li><p><strong>Modern C++ Implementation</strong>: Leveraging modern C++ features like structured bindings, <code>std::span</code>, and designated initializers improved both performance and code readability.</p></li></ol><p>This approach demonstrates that, even in the modern context, mastery of classical algorithms and fundamental mathematical structures remains an irreplaceable and highly powerful tool for software engineering and complex problem solving. The combination of theoretical insights with practical implementation considerations showcases the elegance that can be achieved when mathematical rigor meets engineering pragmatism.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://lcs-developer.com/posts/the-central-limit-theorem/><span class=title>Next »</span><br><span>The Central Limit Theorem</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Un problema di Teoria dei Numeri on x" href="https://x.com/intent/tweet/?text=Un%20problema%20di%20Teoria%20dei%20Numeri&amp;url=https%3a%2f%2flcs-developer.com%2fposts%2fa-number-theory-problem%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Un problema di Teoria dei Numeri on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flcs-developer.com%2fposts%2fa-number-theory-problem%2f&amp;title=Un%20problema%20di%20Teoria%20dei%20Numeri&amp;summary=Un%20problema%20di%20Teoria%20dei%20Numeri&amp;source=https%3a%2f%2flcs-developer.com%2fposts%2fa-number-theory-problem%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Un problema di Teoria dei Numeri on reddit" href="https://reddit.com/submit?url=https%3a%2f%2flcs-developer.com%2fposts%2fa-number-theory-problem%2f&title=Un%20problema%20di%20Teoria%20dei%20Numeri"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Un problema di Teoria dei Numeri on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flcs-developer.com%2fposts%2fa-number-theory-problem%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Un problema di Teoria dei Numeri on whatsapp" href="https://api.whatsapp.com/send?text=Un%20problema%20di%20Teoria%20dei%20Numeri%20-%20https%3a%2f%2flcs-developer.com%2fposts%2fa-number-theory-problem%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Un problema di Teoria dei Numeri on telegram" href="https://telegram.me/share/url?text=Un%20problema%20di%20Teoria%20dei%20Numeri&amp;url=https%3a%2f%2flcs-developer.com%2fposts%2fa-number-theory-problem%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Un problema di Teoria dei Numeri on ycombinator" href="https://news.ycombinator.com/submitlink?t=Un%20problema%20di%20Teoria%20dei%20Numeri&u=https%3a%2f%2flcs-developer.com%2fposts%2fa-number-theory-problem%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://lcs-developer.com/>LCS.Developer</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/XtremeXSPC/ rel=noopener target=_blank>Made with ❤️ by XtremeXSPC</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>