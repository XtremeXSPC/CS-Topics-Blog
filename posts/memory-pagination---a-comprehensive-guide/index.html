<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Memory Pagination - A Comprehensive Guide | LCS.Developer</title>
<meta name=keywords content="Operating-Systems,Virtual-Memory,Coding"><meta name=description content="A detailed explanation of virtual memory pagination with C implementation examples."><meta name=author content="LCS.Dev"><link rel=canonical href=https://lcs-developer.com/posts/memory-pagination---a-comprehensive-guide/><meta name=google-site-verification content="CPQPKX3QPR"><link crossorigin=anonymous href=/assets/css/stylesheet.2bbe49b8fd26e9b2a1b26e6ef8e0785cc8918c0cdbe6afaeed0d49cef5feffa4.css integrity="sha256-K75JuP0m6bKhsm5u+OB4XMiRjAzb5q+u7Q1JzvX+/6Q=" rel="preload stylesheet" as=style><link rel=icon href=https://lcs-developer.com/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lcs-developer.com/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lcs-developer.com/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://lcs-developer.com/favicon/apple-touch-icon.png><link rel=mask-icon href=https://lcs-developer.com/favicon/safari-pinned-tab.svg><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#ffffff"><link rel=alternate hreflang=en href=https://lcs-developer.com/posts/memory-pagination---a-comprehensive-guide/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.18/dist/katex.min.css integrity=sha384-veTAhWILPOotXm+kbR5uY7dRamYLJf58I7P+hJhjeuc7hsMAkJHTsPahAl0hBST0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.18/dist/katex.min.js integrity=sha384-v6mkHYHfY/4BWq54f7lQAdtIsoZZIByznQ3ZqN38OL4KCsrxo31SLlPiak7cj/Mg crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.18/dist/contrib/auto-render.min.js integrity=sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!0})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-CPQPKX3QPR"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-CPQPKX3QPR")}</script><meta property="og:url" content="https://lcs-developer.com/posts/memory-pagination---a-comprehensive-guide/"><meta property="og:site_name" content="LCS.Developer"><meta property="og:title" content="Memory Pagination - A Comprehensive Guide"><meta property="og:description" content="A detailed explanation of virtual memory pagination with C implementation examples."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-19T00:36:58+00:00"><meta property="article:modified_time" content="2024-12-19T00:36:58+00:00"><meta property="article:tag" content="Operating-Systems"><meta property="article:tag" content="Virtual-Memory"><meta property="article:tag" content="Coding"><meta property="og:image" content="https://lcs-developer.com/images/LCS.Dev-Logo.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://lcs-developer.com/images/LCS.Dev-Logo.jpg"><meta name=twitter:title content="Memory Pagination - A Comprehensive Guide"><meta name=twitter:description content="A detailed explanation of virtual memory pagination with C implementation examples."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://lcs-developer.com/posts/"},{"@type":"ListItem","position":2,"name":"Memory Pagination - A Comprehensive Guide","item":"https://lcs-developer.com/posts/memory-pagination---a-comprehensive-guide/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Memory Pagination - A Comprehensive Guide","name":"Memory Pagination - A Comprehensive Guide","description":"A detailed explanation of virtual memory pagination with C implementation examples.","keywords":["Operating-Systems","Virtual-Memory","Coding"],"articleBody":"\nMemory Pagination: Understanding the Virtual Memory Abstraction Imagine trying to run dozens of modern applications simultaneously on a computer with limited physical memory. Without some clever mechanisms in place, your system would quickly grind to a halt. This is where memory pagination comes in—one of the most elegant solutions in operating system design that allows computers to run programs requiring more memory than physically available.\nMemory Abstraction: Paging and Its Role in Modern Systems What is Paging? Let’s start with a simple analogy. Think of computer memory like a large library. In a library without any organization system, finding a specific book would require searching through every shelf. Similarly, in early computing systems, memory allocation was a continuous, unorganized space where finding and allocating memory was inefficient.\nPaging is like introducing a card catalog system to that library. The logical address space (what programs “see”) is divided into fixed-size units called pages, while the physical memory is divided into equally-sized blocks called frames. This division creates a structured approach to memory management.\nWhat makes paging particularly powerful is that a page from the logical address space can be mapped to any available frame in physical memory. It’s like being able to store books from the same author on different shelves throughout the library, yet still having a catalog that tells you exactly where each book is located.\nThe beauty of paging is its transparency—application developers don’t need to worry about where in physical memory their code will run. The operating system, through its memory management unit (MMU), handles all the translation behind the scenes.\nWhy is Paging Used? When I first learned about memory management, I wondered why we needed such a complex system. Couldn’t we just allocate memory sequentially? The answer lies in several critical advantages that paging offers:\nElimination of External Fragmentation\nExternal fragmentation occurs when free memory exists in small, non-contiguous chunks that can’t be used effectively. Imagine trying to park a bus in a parking lot that has enough total free space, but spread across individual car spots—it simply won’t fit.\nWith paging, since both logical and physical memory are divided into fixed-size chunks, any free frame can accommodate any page. It’s like having a parking lot where all spaces are the same size, and you can park anywhere there’s an opening.\nSimplification of Memory Allocation\nMemory allocation becomes remarkably simpler with paging. The operating system needs only to find any available frame for a new page, rather than searching for a contiguous block of memory large enough for an entire process.\nConsider how much easier it is to find a single empty shelf for a book versus finding several adjacent empty shelves for a multi-volume encyclopedia.\nEfficient Use of Physical Memory\nModern systems use techniques like demand paging, where pages are loaded into memory only when accessed. This is like a library that only retrieves books from storage when someone actually requests them, rather than keeping all books on display at all times.\nThis approach dramatically reduces memory overhead and allows systems to run more processes simultaneously than would otherwise be possible.\nSupport for Virtual Memory\nPaging is the cornerstone of virtual memory implementation. Virtual memory creates the illusion of having more memory than physically available by using disk storage as an extension of RAM.\nIt’s comparable to a library that maintains a small display area but has a vast storage warehouse. Books (pages) can be moved between display (RAM) and storage (disk) as needed, giving the impression of an almost unlimited display capacity.\nProcess Isolation\nSecurity in multi-user, multi-process environments is paramount. Paging provides robust isolation by ensuring that each process can only access its own memory pages.\nThink of it as having separate, private reading rooms in our library where each reader can only access the books assigned to them, preventing them from interfering with others’ materials.\nHow Does Paging Work? Now, let’s dive deeper into the mechanics of paging:\nLogical Addresses vs. Physical Addresses\nWhen an application runs, it generates logical addresses—locations in memory from the application’s perspective. These logical addresses must be translated to physical addresses—actual locations in hardware memory—before any data can be accessed.\nIn paging systems, logical addresses consist of two parts:\nPage Number: Identifies which page in the logical address space Offset: Specifies the exact byte position within that page For example, with a page size of 4KB (4,096 bytes), a logical address of 12,345 would be broken down as:\nPage Number: 12,345 ÷ 4,096 = 3 (integer division) Offset: 12,345 % 4,096 = 57 This means the address refers to the 57th byte of page 3.\nTranslation via Page Table\nThe operating system maintains a page table for each process. This table is essentially a mapping directory that converts page numbers to frame numbers.\nWhen the CPU encounters a logical address, the memory management unit (MMU) extracts the page number and looks it up in the page table. This lookup returns the corresponding frame number in physical memory. The physical address is then constructed by combining this frame number with the original offset.\nFormula for Address Translation:\nPhysical Address = (Frame Number × Page Size) + Offset\nUsing our previous example:\nPage Number: 3 Offset: 57 If the page table indicates Page 3 maps to Frame 8 Physical Address = (8 × 4,096) + 57 = 32,825 This translation happens automatically in hardware for every memory access, making it extremely fast despite its complexity.\nLet’s visualize this with a simple diagram:\nLogical Address (12,345) ┌─────────────┬───────────┐ │ Page Number │ Offset │ │ 3 │ 57 │ └─────────────┴───────────┘ │ │ ▼ │ ┌─────────────┐ │ │ Page Table │ │ ├─────────────┤ │ │ Page 0 → 11 │ │ │ Page 1 → 5 │ │ │ Page 2 → 9 │ │ │ Page 3 → 8 │ │ │ Page 4 → 14 │ │ └─────────────┘ │ │ │ ▼ ▼ ┌─────────────┬───────────┐ │Frame Number │ Offset │ │ 8 │ 57 │ └─────────────┴───────────┘ Physical Address (32,825) Implementing Paging in C: A Practical Example Let’s explore how we might implement a simplified paging system in C. This example won’t be a complete operating system implementation, but it will demonstrate the core concepts.\nBasic Paging Structure First, let’s define the structures we’ll need:\n#include #include #include // Define sizes (in bytes) #define PAGE_SIZE 4096 #define PHYSICAL_MEMORY_SIZE (64 * PAGE_SIZE) // 64 frames #define VIRTUAL_MEMORY_SIZE (128 * PAGE_SIZE) // 128 pages // Define page table entry structure typedef struct { uint32_t frame_number : 12; // 12 bits for frame number (4096 possible frames) uint8_t present : 1; // Is this page in physical memory? uint8_t writable : 1; // Can this page be written to? uint8_t user_accessible : 1; // Can user-mode processes access this page? uint8_t accessed : 1; // Has this page been accessed? uint8_t dirty : 1; // Has this page been modified? } PageTableEntry; // Define process structure typedef struct { PageTableEntry* page_table; // Each process has its own page table uint32_t page_table_size; // Number of pages in the virtual address space // Other process information would go here } Process; // Simulate physical memory uint8_t physical_memory[PHYSICAL_MEMORY_SIZE]; // Track which frames are free uint8_t frame_allocation_map[PHYSICAL_MEMORY_SIZE / PAGE_SIZE]; Now, let’s implement some basic functions to handle memory allocation and address translation:\n// Initialize a new process with its own page table Process* create_process() { Process* process = (Process*)malloc(sizeof(Process)); // Calculate number of pages needed for this process process-\u003epage_table_size = VIRTUAL_MEMORY_SIZE / PAGE_SIZE; // Allocate page table process-\u003epage_table = (PageTableEntry*)calloc(process-\u003epage_table_size, sizeof(PageTableEntry)); // Initialize all pages as not present in physical memory for (uint32_t i = 0; i \u003c process-\u003epage_table_size; i++) { process-\u003epage_table[i].present = 0; } return process; } // Find a free frame in physical memory int find_free_frame() { for (int i = 0; i \u003c PHYSICAL_MEMORY_SIZE / PAGE_SIZE; i++) { if (frame_allocation_map[i] == 0) { frame_allocation_map[i] = 1; // Mark as allocated return i; } } return -1; // No free frames } // Allocate a physical frame for a virtual page int allocate_page(Process* process, uint32_t page_number) { // Check if page is already allocated if (process-\u003epage_table[page_number].present) { return process-\u003epage_table[page_number].frame_number; } // Find a free frame int frame = find_free_frame(); if (frame == -1) { // No free frames, would need to implement page replacement printf(\"Error: No free frames available\\n\"); return -1; } // Update page table process-\u003epage_table[page_number].frame_number = frame; process-\u003epage_table[page_number].present = 1; process-\u003epage_table[page_number].writable = 1; process-\u003epage_table[page_number].user_accessible = 1; process-\u003epage_table[page_number].accessed = 0; process-\u003epage_table[page_number].dirty = 0; return frame; } // Translate virtual address to physical address uint32_t translate_address(Process* process, uint32_t virtual_address) { // Extract page number and offset uint32_t page_number = virtual_address / PAGE_SIZE; uint32_t offset = virtual_address % PAGE_SIZE; // Check if page is in bounds if (page_number \u003e= process-\u003epage_table_size) { printf(\"Error: Page number out of bounds\\n\"); return -1; } // Check if page is present in physical memory if (!process-\u003epage_table[page_number].present) { // Page fault: Allocate a frame for this page printf(\"Page fault: Allocating frame for page %u\\n\", page_number); int frame = allocate_page(process, page_number); if (frame == -1) { return -1; // Allocation failed } } // Mark page as accessed process-\u003epage_table[page_number].accessed = 1; // Calculate physical address uint32_t frame_number = process-\u003epage_table[page_number].frame_number; uint32_t physical_address = (frame_number * PAGE_SIZE) + offset; return physical_address; } Now let’s add functions to read and write memory:\n// Write a byte to a virtual address void write_byte(Process* process, uint32_t virtual_address, uint8_t value) { uint32_t physical_address = translate_address(process, virtual_address); if (physical_address == -1) { return; // Translation failed } // Check if page is writable uint32_t page_number = virtual_address / PAGE_SIZE; if (!process-\u003epage_table[page_number].writable) { printf(\"Error: Page is not writable\\n\"); return; } // Mark page as dirty (modified) process-\u003epage_table[page_number].dirty = 1; // Write to physical memory physical_memory[physical_address] = value; } // Read a byte from a virtual address uint8_t read_byte(Process* process, uint32_t virtual_address) { uint32_t physical_address = translate_address(process, virtual_address); if (physical_address == -1) { return 0; // Translation failed } // Read from physical memory return physical_memory[physical_address]; } Finally, let’s add a simple example of how to use this paging system:\n// Example usage int main() { // Initialize frame allocation map for (int i = 0; i \u003c PHYSICAL_MEMORY_SIZE / PAGE_SIZE; i++) { frame_allocation_map[i] = 0; // All frames free initially } // Create a process Process* process = create_process(); // Write some values to memory printf(\"Writing values to virtual memory...\\n\"); for (uint32_t i = 0; i \u003c 5; i++) { uint32_t addr = i * PAGE_SIZE + i; // Access different pages write_byte(process, addr, 65 + i); // ASCII 'A', 'B', 'C', etc. printf(\"Wrote '%c' to virtual address %u\\n\", 65 + i, addr); } // Read the values back printf(\"\\nReading values from virtual memory...\\n\"); for (uint32_t i = 0; i \u003c 5; i++) { uint32_t addr = i * PAGE_SIZE + i; uint8_t value = read_byte(process, addr); printf(\"Read '%c' from virtual address %u\\n\", value, addr); } // Clean up free(process-\u003epage_table); free(process); return 0; } This code demonstrates the basic concepts of paging:\nEach process has its own page table mapping virtual pages to physical frames Address translation breaks an address into page number and offset Page faults occur when accessing a page not currently in physical memory Pages can have attributes like present, writable, accessed, and dirty Enhancing Our Implementation with TLB In real systems, page table lookups would be extremely slow if done for every memory access. To speed things up, processors use a Translation Lookaside Buffer (TLB)—a small, specialized cache that stores recent address translations.\nLet’s extend our example to include a simple TLB:\n// Define TLB entry structure typedef struct { uint32_t page_number; uint32_t frame_number; uint8_t valid; } TLBEntry; // Define TLB #define TLB_SIZE 16 TLBEntry tlb[TLB_SIZE]; uint32_t tlb_next_entry = 0; // Initialize TLB void init_tlb() { for (int i = 0; i \u003c TLB_SIZE; i++) { tlb[i].valid = 0; } } // Look up address in TLB int tlb_lookup(uint32_t page_number, uint32_t* frame_number) { for (int i = 0; i \u003c TLB_SIZE; i++) { if (tlb[i].valid \u0026\u0026 tlb[i].page_number == page_number) { *frame_number = tlb[i].frame_number; return 1; // TLB hit } } return 0; // TLB miss } // Update TLB with new mapping void tlb_update(uint32_t page_number, uint32_t frame_number) { // Use simple round-robin replacement tlb[tlb_next_entry].page_number = page_number; tlb[tlb_next_entry].frame_number = frame_number; tlb[tlb_next_entry].valid = 1; // Move to next entry tlb_next_entry = (tlb_next_entry + 1) % TLB_SIZE; } Now, let’s modify our address translation function to use the TLB:\n// Translate virtual address to physical address with TLB uint32_t translate_address(Process* process, uint32_t virtual_address) { // Extract page number and offset uint32_t page_number = virtual_address / PAGE_SIZE; uint32_t offset = virtual_address % PAGE_SIZE; uint32_t frame_number; // Check if page is in bounds if (page_number \u003e= process-\u003epage_table_size) { printf(\"Error: Page number out of bounds\\n\"); return -1; } // Try TLB first if (tlb_lookup(page_number, \u0026frame_number)) { printf(\"TLB hit for page %u\\n\", page_number); } else { // TLB miss: Check page table printf(\"TLB miss for page %u\\n\", page_number); // Check if page is present in physical memory if (!process-\u003epage_table[page_number].present) { // Page fault: Allocate a frame for this page printf(\"Page fault: Allocating frame for page %u\\n\", page_number); int frame = allocate_page(process, page_number); if (frame == -1) { return -1; // Allocation failed } frame_number = frame; } else { frame_number = process-\u003epage_table[page_number].frame_number; } // Update TLB with this translation tlb_update(page_number, frame_number); } // Mark page as accessed process-\u003epage_table[page_number].accessed = 1; // Calculate physical address uint32_t physical_address = (frame_number * PAGE_SIZE) + offset; return physical_address; } And we would need to initialize the TLB in our main function:\nint main() { // Initialize frame allocation map for (int i = 0; i \u003c PHYSICAL_MEMORY_SIZE / PAGE_SIZE; i++) { frame_allocation_map[i] = 0; // All frames free initially } // Initialize TLB init_tlb(); // Create a process Process* process = create_process(); // Rest of the function remains the same... } Paging vs. Segmentation: A Deeper Comparison Now that we understand paging better, let’s compare it more thoroughly with segmentation, another memory management approach:\nFundamental Philosophy Paging is based on a fixed-size division approach. It’s like dividing a book into pages of equal length, regardless of where chapters begin or end. This regularity simplifies physical memory management but doesn’t align with how programs are naturally structured.\nSegmentation, on the other hand, divides memory based on logical program units—like having chapters in a book that can be any length but represent cohesive sections. Programs naturally consist of distinct sections like code, data, stack, and heap, which segmentation preserves as separate units.\nMemory Utilization Challenges Paging eliminates external fragmentation (unusable gaps between allocated memory blocks) but introduces internal fragmentation. Since pages have fixed sizes, the last page of a process might not be fully utilized, wasting some memory. For example, if a process needs 4.5 pages, it will be allocated 5 full pages, wasting half a page.\nSegmentation has the opposite problem. It eliminates internal fragmentation since segments can be exactly the size needed, but it creates external fragmentation as segments of different sizes are allocated and deallocated over time.\nLet’s visualize this with memory diagrams:\nFor paging:\nPhysical Memory with Paging (4KB pages) ┌───────┬───────┬───────┬───────┬───────┬───────┐ │Frame 0│Frame 1│Frame 2│Frame 3│Frame 4│Frame 5│... │Process│Process│Process│Process│Process│ Free │ │ A │ A │ B │ C │ A │ │ │ (Full)│ (Full)│ (Full)│ (Full)│(Half) │ │ └───────┴───────┴───────┴───────┴───────┴───────┘ ▲ │ Internal Fragmentation (Half of Frame 4 wasted) For segmentation:\nPhysical Memory with Segmentation ┌────────────┬──────┬──────────────┬──────┬────────┐ │ Process A │ Free │ Process B │ Free │Process │... │ Code Seg │Space │ Data Seg │Space │ C │ │ (1.2 MB) │(0.1MB│ (0.8 MB) │(0.2MB│(0.5 MB)│ └────────────┴──────┴──────────────┴──────┴────────┘ ▲ ▲ │ │ External Fragmentation (Small free spaces that can't be used) Address Translation Complexity Paging has a straightforward address translation: divide the address into page number and offset, look up the page number in the page table to get the frame number, then combine the frame number with the offset.\nSegmentation requires more complex translation: the address includes a segment number and an offset, and segments can have different sizes. The system must check that the offset is within the segment’s length bounds before calculating the physical address.\nProtection and Sharing Paging makes sharing code between processes simple. If two processes use the same code (like a shared library), that code can be loaded into memory once and mapped into both processes’ address spaces through their respective page tables.\nSegmentation naturally aligns with protection needs—different segments can have different access permissions (read, write, execute). For example, code segments can be marked as read-only and executable, while data segments can be writable but not executable.\nImplementation in Modern Systems Most modern systems use a hybrid approach called paged segmentation or segmented paging. Let’s explore how this works:\nCombining Paging and Segmentation: The Best of Both Worlds In modern systems, we often see a hybrid approach that leverages the benefits of both paging and segmentation. Let’s examine how this works in practice:\nSegmented Paging In segmented paging, the address space is first divided into segments that represent logical units of the program (like code, data, stack). Then, each segment is further divided into pages of fixed size.\nThe logical address in this scheme consists of three components:\nSegment Number Page Number (within the segment) Offset (within the page) Address translation becomes a two-step process:\nThe segment number is used to locate the segment’s page table The page number is used to find the corresponding frame in physical memory Here’s a C structure that could represent this:\ntypedef struct { uint32_t base_address; // Base address of the segment's page table uint32_t limit; // Size of the segment in pages uint8_t present : 1; // Is this segment in memory? uint8_t privilege : 2; // Privilege level (0-3) uint8_t readable : 1; // Can be read uint8_t writable : 1; // Can be written uint8_t executable : 1; // Can be executed } SegmentDescriptor; typedef struct { SegmentDescriptor* segment_table; // Segment descriptor table uint32_t segment_count; // Number of segments PageTableEntry** page_tables; // Array of page tables, one for each segment } ProcessMemoryMap; The address translation might look like this:\nuint32_t translate_segmented_paging_address(ProcessMemoryMap* memory_map, uint32_t segment, uint32_t page, uint32_t offset) { // Check if segment is valid if (segment \u003e= memory_map-\u003esegment_count) { printf(\"Error: Segment number out of bounds\\n\"); return -1; } // Check segment permissions and limits SegmentDescriptor* seg_desc = \u0026memory_map-\u003esegment_table[segment]; if (!seg_desc-\u003epresent) { printf(\"Error: Segment not present in memory\\n\"); return -1; } if (page \u003e= seg_desc-\u003elimit) { printf(\"Error: Page number exceeds segment limit\\n\"); return -1; } // Get page table for this segment PageTableEntry* page_table = memory_map-\u003epage_tables[segment]; // Check if page is present if (!page_table[page].present) { // Handle page fault printf(\"Page fault: Segment %u, Page %u\\n\", segment, page); // Page fault handling code would go here return -1; } // Get frame number uint32_t frame = page_table[page].frame_number; // Calculate physical address uint32_t physical_address = (frame * PAGE_SIZE) + offset; return physical_address; } Intel x86 Memory Model: A Real-World Example The Intel x86 architecture uses a form of segmented paging that has evolved over time. In protected mode, the processor uses segment registers to select segment descriptors from descriptor tables (GDT or LDT). The segmentation unit produces a linear address, which is then translated by the paging unit into a physical address.\nHere’s a simplified version of how it works:\nThe application generates a logical address: (Segment Selector, Offset) The processor uses the segment selector to retrieve the segment descriptor The base address from the segment descriptor is added to the offset to form a linear address The paging unit translates the linear address to a physical address: The upper bits form the page directory index The middle bits form the page table index The lower bits form the offset within the page This is a complex but powerful approach that has supported decades of backward compatibility while allowing modern operating systems to implement efficient memory management.\nPractical Implementations: Page Replacement Algorithms When physical memory is full and a new page needs to be loaded, the operating system must choose a page to evict. Several algorithms exist for this purpose, each with different characteristics. Let’s implement a few in C:\nFirst-In-First-Out (FIFO) #define MAX_FRAMES 64 // FIFO queue typedef struct { uint32_t frames[MAX_FRAMES]; int front; int rear; int count; } FIFOQueue; void fifo_init(FIFOQueue* queue) { queue-\u003efront = 0; queue-\u003erear = -1; queue-\u003ecount = 0; } void fifo_enqueue(FIFOQueue* queue, uint32_t frame) { if (queue-\u003ecount \u003e= MAX_FRAMES) { printf(\"Queue is full\\n\"); return; } queue-\u003erear = (queue-\u003erear + 1) % MAX_FRAMES; queue-\u003eframes[queue-\u003erear] = frame; queue-\u003ecount++; } uint32_t fifo_dequeue(FIFOQueue* queue) { if (queue-\u003ecount \u003c= 0) { printf(\"Queue is empty\\n\"); return -1; } uint32_t frame = queue-\u003eframes[queue-\u003efront]; queue-\u003efront = (queue-\u003efront + 1) % MAX_FRAMES; queue-\u003ecount--; return frame; } // Page replacement using FIFO uint32_t replace_page_fifo(FIFOQueue* queue) { return fifo_dequeue(queue); } Least Recently Used (LRU) // Simplified LRU implementation using a counter typedef struct { uint32_t frame; uint64_t last_used_time; } FrameUsage; typedef struct { FrameUsage frames[MAX_FRAMES]; int count; uint64_t clock; // Global clock for timestamp } LRUTracker; void lru_init(LRUTracker* tracker) { tracker-\u003ecount = 0; tracker-\u003eclock = 0; } void lru_access(LRUTracker* tracker, uint32_t frame) { // Find frame in tracker for (int i = 0; i \u003c tracker-\u003ecount; i++) { if (tracker-\u003eframes[i].frame == frame) { // Update last used time tracker-\u003eframes[i].last_used_time = tracker-\u003eclock++; return; } } // Frame not found, add it if (tracker-\u003ecount \u003c MAX_FRAMES) { tracker-\u003eframes[tracker-\u003ecount].frame = frame; tracker-\u003eframes[tracker-\u003ecount].last_used_time = tracker-\u003eclock++; tracker-\u003ecount++; } else { printf(\"Error: LRU tracker full\\n\"); } } uint32_t replace_page_lru(LRUTracker* tracker) { if (tracker-\u003ecount == 0) { printf(\"Error: No frames to replace\\n\"); return -1; } // Find least recently used frame int lru_index = 0; uint64_t min_time = tracker-\u003eframes[0].last_used_time; for (int i = 1; i \u003c tracker-\u003ecount; i++) { if (tracker-\u003eframes[i].last_used_time \u003c min_time) { min_time = tracker-\u003eframes[i].last_used_time; lru_index = i; } } uint32_t frame_to_replace = tracker-\u003eframes[lru_index].frame; // Remove the frame from tracker (or just update it when reused) for (int i = lru_index; i \u003c tracker-\u003ecount - 1; i++) { tracker-\u003eframes[i] = tracker-\u003eframes[i + 1]; } tracker-\u003ecount--; return frame_to_replace; } The Second Chance Algorithm (Clock) // Clock algorithm implementation typedef struct { uint32_t frames[MAX_FRAMES]; uint8_t referenced[MAX_FRAMES]; int count; int hand; // Clock hand } ClockAlgorithm; void clock_init(ClockAlgorithm* clock) { clock-\u003ecount = 0; clock-\u003ehand = 0; for (int i = 0; i \u003c MAX_FRAMES; i++) { clock-\u003ereferenced[i] = 0; } } void clock_access(ClockAlgorithm* clock, uint32_t frame) { // Find frame in clock for (int i = 0; i \u003c clock-\u003ecount; i++) { if (clock-\u003eframes[i] == frame) { // Set referenced bit clock-\u003ereferenced[i] = 1; return; } } // Frame not found, add it if (clock-\u003ecount \u003c MAX_FRAMES) { clock-\u003eframes[clock-\u003ecount] = frame; clock-\u003ereferenced[clock-\u003ecount] = 1; clock-\u003ecount++; } else { printf(\"Error: Clock algorithm tracker full\\n\"); } } uint32_t replace_page_clock(ClockAlgorithm* clock) { if (clock-\u003ecount == 0) { printf(\"Error: No frames to replace\\n\"); return -1; } // Find a frame to replace while (1) { if (clock-\u003ereferenced[clock-\u003ehand] == 0) { // Found a non-referenced frame to replace uint32_t frame_to_replace = clock-\u003eframes[clock-\u003ehand]; // Move hand to next position clock-\u003ehand = (clock-\u003ehand + 1) % clock-\u003ecount; return frame_to_replace; } // Give second chance by clearing referenced bit clock-\u003ereferenced[clock-\u003ehand] = 0; // Move hand to next position clock-\u003ehand = (clock-\u003ehand + 1) % clock-\u003ecount; } } Real-World Considerations and Challenges Large Page Tables As virtual address spaces grow larger, page tables can become enormous. For a 32-bit address space with 4KB pages, the page table would have 2^20 (over 1 million) entries. For 64-bit systems, this problem is exponentially worse.\nModern systems address this with multi-level page tables or inverted page tables:\nMulti-level Page Tables: The page table is itself paged, creating a tree-like structure. This approach only requires the parts of the page table that are actually being used to be in memory.\nInverted Page Tables: Instead of having one entry for each virtual page, an inverted page table has one entry for each physical frame, mapping back to which process and virtual page owns it. This reduces table size but makes lookups more complex.\nHere’s a simplified implementation of a two-level page table:\n#define PAGE_TABLE_ENTRIES 1024 // 2^10 entries in each table #define PAGE_DIRECTORY_ENTRIES 1024 // 2^10 entries in directory typedef struct { uint32_t frame_number : 20; uint8_t present : 1; uint8_t writable : 1; uint8_t user_accessible : 1; uint8_t accessed : 1; uint8_t dirty : 1; uint8_t reserved : 7; } PageTableEntry; typedef struct { PageTableEntry* table_address; uint8_t present : 1; uint8_t writable : 1; uint8_t user_accessible : 1; uint8_t reserved : 9; } PageDirectoryEntry; typedef struct { PageDirectoryEntry* page_directory; } ProcessMemoryMap; // Allocate a two-level page table ProcessMemoryMap* create_two_level_page_table() { ProcessMemoryMap* memory_map = (ProcessMemoryMap*)malloc(sizeof(ProcessMemoryMap)); // Allocate page directory memory_map-\u003epage_directory = (PageDirectoryEntry*)calloc(PAGE_DIRECTORY_ENTRIES, sizeof(PageDirectoryEntry)); return memory_map; } // Translate address using two-level page table uint32_t translate_two_level_address(ProcessMemoryMap* memory_map, uint32_t virtual_address) { // Extract directory index, page table index, and offset uint32_t directory_index = (virtual_address \u003e\u003e 22) \u0026 0x3FF; // Top 10 bits uint32_t page_table_index = (virtual_address \u003e\u003e 12) \u0026 0x3FF; // Middle 10 bits uint32_t offset = virtual_address \u0026 0xFFF; // Bottom 12 bits // Check if page directory entry is present PageDirectoryEntry* dir_entry = \u0026memory_map-\u003epage_directory[directory_index]; if (!dir_entry-\u003epresent) { printf(\"Page directory entry not present\\n\"); return -1; } // Get page table PageTableEntry* page_table = dir_entry-\u003etable_address; // Check if page table entry is present PageTableEntry* page_entry = \u0026page_table[page_table_index]; if (!page_entry-\u003epresent) { printf(\"Page table entry not present\\n\"); return -1; } // Calculate physical address uint32_t physical_address = (page_entry-\u003eframe_number \u003c\u003c 12) | offset; return physical_address; } Huge Pages and Page Size Considerations While 4KB is the standard page size for many systems, larger pages (2MB or 1GB) are becoming more common, especially in systems with large amounts of RAM. These “huge pages” reduce the number of TLB entries needed to cover a given amount of memory, improving performance for large, contiguous memory accesses.\nThe tradeoff is that larger pages can lead to more internal fragmentation. It’s a classic space-time tradeoff in computing.\nConclusion Paging is a foundational technique in modern computing that enables efficient memory management, process isolation, and the illusion of unlimited memory through virtual memory. By dividing memory into fixed-size chunks, operating systems can allocate and manage memory with remarkable efficiency, even under the complex demands of multitasking environments.\nThe examples we’ve explored in C provide a glimpse into how memory pagination might be implemented, though real-world operating systems are considerably more complex. Modern systems typically employ multi-level page tables, TLBs, huge pages, and sophisticated page replacement algorithms to optimize both performance and memory utilization.\nUnderstanding paging is essential for anyone working in systems programming, operating system development, or performance optimization. The concepts we’ve covered—from basic address translation to page replacement algorithms—form the foundation of virtually all modern computing environments.\nFor a deeper dive into practical implementations, I encourage exploring the memory management code in open-source operating systems like Linux or FreeBSD. These real-world systems showcase the elegant solutions that have evolved to address the challenges of memory management in complex computing environments.\n","wordCount":"4464","inLanguage":"en","image":"https://lcs-developer.com/images/LCS.Dev-Logo.jpg","datePublished":"2024-12-19T00:36:58.464578Z","dateModified":"2024-12-19T00:36:58.464578Z","author":{"@type":"Person","name":"LCS.Dev"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lcs-developer.com/posts/memory-pagination---a-comprehensive-guide/"},"publisher":{"@type":"Organization","name":"LCS.Developer","logo":{"@type":"ImageObject","url":"https://lcs-developer.com/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://lcs-developer.com/ accesskey=h title="LCS.Dev - CS Topics (Alt + H)"><img src=https://lcs-developer.com/%F0%9F%91%A8%E2%80%8D%F0%9F%92%BB alt aria-label=logo height=35>LCS.Dev - CS Topics</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://lcs-developer.com/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://lcs-developer.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://lcs-developer.com/about/ title=About><span>About</span></a></li><li><a href=https://lcs-developer.com/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://lcs-developer.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://lcs-developer.com/>Home</a>&nbsp;»&nbsp;<a href=https://lcs-developer.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Memory Pagination - A Comprehensive Guide</h1><div class=post-description>A detailed explanation of virtual memory pagination with C implementation examples.</div><div class=post-meta><span title='2024-12-19 00:36:58.464578 +0000 UTC'>December 19, 2024</span>&nbsp;·&nbsp;21 min&nbsp;·&nbsp;4464 words&nbsp;·&nbsp;LCS.Dev&nbsp;|&nbsp;<a href=https://github.com/XtremeXSPC/LCS.Dev-Blog/tree/hostinger//posts/Memory%20Pagination%20-%20A%20Comprehensive%20Guide.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#memory-abstraction-paging-and-its-role-in-modern-systems>Memory Abstraction: Paging and Its Role in Modern Systems</a><ul><li><a href=#what-is-paging>What is Paging?</a></li><li><a href=#why-is-paging-used>Why is Paging Used?</a></li><li><a href=#how-does-paging-work>How Does Paging Work?</a></li></ul></li><li><a href=#implementing-paging-in-c-a-practical-example>Implementing Paging in C: A Practical Example</a><ul><li><a href=#basic-paging-structure>Basic Paging Structure</a></li><li><a href=#enhancing-our-implementation-with-tlb>Enhancing Our Implementation with TLB</a></li></ul></li><li><a href=#paging-vs-segmentation-a-deeper-comparison>Paging vs. Segmentation: A Deeper Comparison</a><ul><li><a href=#fundamental-philosophy>Fundamental Philosophy</a></li><li><a href=#memory-utilization-challenges>Memory Utilization Challenges</a></li><li><a href=#address-translation-complexity>Address Translation Complexity</a></li><li><a href=#protection-and-sharing>Protection and Sharing</a></li><li><a href=#implementation-in-modern-systems>Implementation in Modern Systems</a></li></ul></li><li><a href=#combining-paging-and-segmentation-the-best-of-both-worlds>Combining Paging and Segmentation: The Best of Both Worlds</a><ul><li><a href=#segmented-paging>Segmented Paging</a></li><li><a href=#intel-x86-memory-model-a-real-world-example>Intel x86 Memory Model: A Real-World Example</a></li></ul></li><li><a href=#practical-implementations-page-replacement-algorithms>Practical Implementations: Page Replacement Algorithms</a><ul><li><a href=#first-in-first-out-fifo>First-In-First-Out (FIFO)</a></li><li><a href=#least-recently-used-lru>Least Recently Used (LRU)</a></li><li><a href=#the-second-chance-algorithm-clock>The Second Chance Algorithm (Clock)</a></li></ul></li><li><a href=#real-world-considerations-and-challenges>Real-World Considerations and Challenges</a><ul><li><a href=#large-page-tables>Large Page Tables</a></li><li><a href=#huge-pages-and-page-size-considerations>Huge Pages and Page Size Considerations</a></li></ul></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></details></div><div class=post-content><p><img alt="Image Description" loading=lazy src=/images/virtual_memory_translation.png></p><hr><h1 id=memory-pagination-understanding-the-virtual-memory-abstraction>Memory Pagination: Understanding the Virtual Memory Abstraction<a hidden class=anchor aria-hidden=true href=#memory-pagination-understanding-the-virtual-memory-abstraction>#</a></h1><p>Imagine trying to run dozens of modern applications simultaneously on a computer with limited physical memory. Without some clever mechanisms in place, your system would quickly grind to a halt. This is where memory pagination comes in—one of the most elegant solutions in operating system design that allows computers to run programs requiring more memory than physically available.</p><h2 id=memory-abstraction-paging-and-its-role-in-modern-systems>Memory Abstraction: Paging and Its Role in Modern Systems<a hidden class=anchor aria-hidden=true href=#memory-abstraction-paging-and-its-role-in-modern-systems>#</a></h2><h3 id=what-is-paging>What is Paging?<a hidden class=anchor aria-hidden=true href=#what-is-paging>#</a></h3><p>Let&rsquo;s start with a simple analogy. Think of computer memory like a large library. In a library without any organization system, finding a specific book would require searching through every shelf. Similarly, in early computing systems, memory allocation was a continuous, unorganized space where finding and allocating memory was inefficient.</p><p>Paging is like introducing a card catalog system to that library. The logical address space (what programs &ldquo;see&rdquo;) is divided into fixed-size units called <em>pages</em>, while the physical memory is divided into equally-sized blocks called <em>frames</em>. This division creates a structured approach to memory management.</p><p>What makes paging particularly powerful is that a page from the logical address space can be mapped to any available frame in physical memory. It&rsquo;s like being able to store books from the same author on different shelves throughout the library, yet still having a catalog that tells you exactly where each book is located.</p><p>The beauty of paging is its transparency—application developers don&rsquo;t need to worry about where in physical memory their code will run. The operating system, through its memory management unit (MMU), handles all the translation behind the scenes.</p><h3 id=why-is-paging-used>Why is Paging Used?<a hidden class=anchor aria-hidden=true href=#why-is-paging-used>#</a></h3><p>When I first learned about memory management, I wondered why we needed such a complex system. Couldn&rsquo;t we just allocate memory sequentially? The answer lies in several critical advantages that paging offers:</p><ol><li><p><strong>Elimination of External Fragmentation</strong></p><p>External fragmentation occurs when free memory exists in small, non-contiguous chunks that can&rsquo;t be used effectively. Imagine trying to park a bus in a parking lot that has enough total free space, but spread across individual car spots—it simply won&rsquo;t fit.</p><p>With paging, since both logical and physical memory are divided into fixed-size chunks, any free frame can accommodate any page. It&rsquo;s like having a parking lot where all spaces are the same size, and you can park anywhere there&rsquo;s an opening.</p></li><li><p><strong>Simplification of Memory Allocation</strong></p><p>Memory allocation becomes remarkably simpler with paging. The operating system needs only to find any available frame for a new page, rather than searching for a contiguous block of memory large enough for an entire process.</p><p>Consider how much easier it is to find a single empty shelf for a book versus finding several adjacent empty shelves for a multi-volume encyclopedia.</p></li><li><p><strong>Efficient Use of Physical Memory</strong></p><p>Modern systems use techniques like demand paging, where pages are loaded into memory only when accessed. This is like a library that only retrieves books from storage when someone actually requests them, rather than keeping all books on display at all times.</p><p>This approach dramatically reduces memory overhead and allows systems to run more processes simultaneously than would otherwise be possible.</p></li><li><p><strong>Support for Virtual Memory</strong></p><p>Paging is the cornerstone of virtual memory implementation. Virtual memory creates the illusion of having more memory than physically available by using disk storage as an extension of RAM.</p><p>It&rsquo;s comparable to a library that maintains a small display area but has a vast storage warehouse. Books (pages) can be moved between display (RAM) and storage (disk) as needed, giving the impression of an almost unlimited display capacity.</p></li><li><p><strong>Process Isolation</strong></p><p>Security in multi-user, multi-process environments is paramount. Paging provides robust isolation by ensuring that each process can only access its own memory pages.</p><p>Think of it as having separate, private reading rooms in our library where each reader can only access the books assigned to them, preventing them from interfering with others&rsquo; materials.</p></li></ol><h3 id=how-does-paging-work>How Does Paging Work?<a hidden class=anchor aria-hidden=true href=#how-does-paging-work>#</a></h3><p>Now, let&rsquo;s dive deeper into the mechanics of paging:</p><ol><li><p><strong>Logical Addresses vs. Physical Addresses</strong></p><p>When an application runs, it generates logical addresses—locations in memory from the application&rsquo;s perspective. These logical addresses must be translated to physical addresses—actual locations in hardware memory—before any data can be accessed.</p><p>In paging systems, logical addresses consist of two parts:</p><ul><li><strong>Page Number</strong>: Identifies which page in the logical address space</li><li><strong>Offset</strong>: Specifies the exact byte position within that page</li></ul><p>For example, with a page size of 4KB (4,096 bytes), a logical address of 12,345 would be broken down as:</p><ul><li>Page Number: 12,345 ÷ 4,096 = 3 (integer division)</li><li>Offset: 12,345 % 4,096 = 57</li></ul><p>This means the address refers to the 57th byte of page 3.</p></li><li><p><strong>Translation via Page Table</strong></p><p>The operating system maintains a page table for each process. This table is essentially a mapping directory that converts page numbers to frame numbers.</p><p>When the CPU encounters a logical address, the memory management unit (MMU) extracts the page number and looks it up in the page table. This lookup returns the corresponding frame number in physical memory. The physical address is then constructed by combining this frame number with the original offset.</p><p><strong>Formula for Address Translation:</strong></p><p>Physical Address = (Frame Number × Page Size) + Offset</p><p>Using our previous example:</p><ul><li>Page Number: 3</li><li>Offset: 57</li><li>If the page table indicates Page 3 maps to Frame 8</li><li>Physical Address = (8 × 4,096) + 57 = 32,825</li></ul><p>This translation happens automatically in hardware for every memory access, making it extremely fast despite its complexity.</p></li></ol><p>Let&rsquo;s visualize this with a simple diagram:</p><pre tabindex=0><code>Logical Address (12,345)
┌─────────────┬───────────┐
│ Page Number │   Offset  │
│      3      │     57    │
└─────────────┴───────────┘
        │             │
        ▼             │
┌─────────────┐       │
│ Page Table  │       │
├─────────────┤       │
│ Page 0 → 11 │       │
│ Page 1 → 5  │       │
│ Page 2 → 9  │       │
│ Page 3 → 8  │       │
│ Page 4 → 14 │       │
└─────────────┘       │
        │             │
        ▼             ▼
┌─────────────┬───────────┐
│Frame Number │   Offset  │
│      8      │     57    │
└─────────────┴───────────┘
Physical Address (32,825)
</code></pre><hr><h2 id=implementing-paging-in-c-a-practical-example>Implementing Paging in C: A Practical Example<a hidden class=anchor aria-hidden=true href=#implementing-paging-in-c-a-practical-example>#</a></h2><p>Let&rsquo;s explore how we might implement a simplified paging system in C. This example won&rsquo;t be a complete operating system implementation, but it will demonstrate the core concepts.</p><h3 id=basic-paging-structure>Basic Paging Structure<a hidden class=anchor aria-hidden=true href=#basic-paging-structure>#</a></h3><p>First, let&rsquo;s define the structures we&rsquo;ll need:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// Define sizes (in bytes)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define PAGE_SIZE 4096
</span></span></span><span class=line><span class=cl><span class=cp>#define PHYSICAL_MEMORY_SIZE (64 * PAGE_SIZE)  </span><span class=c1>// 64 frames
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define VIRTUAL_MEMORY_SIZE (128 * PAGE_SIZE)  </span><span class=c1>// 128 pages
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// Define page table entry structure
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=nl>frame_number</span> <span class=p>:</span> <span class=mi>12</span><span class=p>;</span>  <span class=c1>// 12 bits for frame number (4096 possible frames)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint8_t</span> <span class=nl>present</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>         <span class=c1>// Is this page in physical memory?
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint8_t</span> <span class=nl>writable</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>        <span class=c1>// Can this page be written to?
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint8_t</span> <span class=nl>user_accessible</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>// Can user-mode processes access this page?
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint8_t</span> <span class=nl>accessed</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>        <span class=c1>// Has this page been accessed?
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint8_t</span> <span class=nl>dirty</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>           <span class=c1>// Has this page been modified?
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>PageTableEntry</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Define process structure
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>PageTableEntry</span><span class=o>*</span> <span class=n>page_table</span><span class=p>;</span>  <span class=c1>// Each process has its own page table
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint32_t</span> <span class=n>page_table_size</span><span class=p>;</span>    <span class=c1>// Number of pages in the virtual address space
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Other process information would go here
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>Process</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Simulate physical memory
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>uint8_t</span> <span class=n>physical_memory</span><span class=p>[</span><span class=n>PHYSICAL_MEMORY_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Track which frames are free
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>uint8_t</span> <span class=n>frame_allocation_map</span><span class=p>[</span><span class=n>PHYSICAL_MEMORY_SIZE</span> <span class=o>/</span> <span class=n>PAGE_SIZE</span><span class=p>];</span>
</span></span></code></pre></div><p>Now, let&rsquo;s implement some basic functions to handle memory allocation and address translation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Initialize a new process with its own page table
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Process</span><span class=o>*</span> <span class=nf>create_process</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Process</span><span class=o>*</span> <span class=n>process</span> <span class=o>=</span> <span class=p>(</span><span class=n>Process</span><span class=o>*</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>Process</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Calculate number of pages needed for this process
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>process</span><span class=o>-&gt;</span><span class=n>page_table_size</span> <span class=o>=</span> <span class=n>VIRTUAL_MEMORY_SIZE</span> <span class=o>/</span> <span class=n>PAGE_SIZE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Allocate page table
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>process</span><span class=o>-&gt;</span><span class=n>page_table</span> <span class=o>=</span> <span class=p>(</span><span class=n>PageTableEntry</span><span class=o>*</span><span class=p>)</span><span class=nf>calloc</span><span class=p>(</span><span class=n>process</span><span class=o>-&gt;</span><span class=n>page_table_size</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>PageTableEntry</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Initialize all pages as not present in physical memory
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>process</span><span class=o>-&gt;</span><span class=n>page_table_size</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>process</span><span class=o>-&gt;</span><span class=n>page_table</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>present</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>process</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Find a free frame in physical memory
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>find_free_frame</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>PHYSICAL_MEMORY_SIZE</span> <span class=o>/</span> <span class=n>PAGE_SIZE</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>frame_allocation_map</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>frame_allocation_map</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>  <span class=c1>// Mark as allocated
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>return</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>  <span class=c1>// No free frames
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Allocate a physical frame for a virtual page
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>allocate_page</span><span class=p>(</span><span class=n>Process</span><span class=o>*</span> <span class=n>process</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>page_number</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Check if page is already allocated
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>process</span><span class=o>-&gt;</span><span class=n>page_table</span><span class=p>[</span><span class=n>page_number</span><span class=p>].</span><span class=n>present</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>process</span><span class=o>-&gt;</span><span class=n>page_table</span><span class=p>[</span><span class=n>page_number</span><span class=p>].</span><span class=n>frame_number</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Find a free frame
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>frame</span> <span class=o>=</span> <span class=nf>find_free_frame</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>frame</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// No free frames, would need to implement page replacement
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Error: No free frames available</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Update page table
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>process</span><span class=o>-&gt;</span><span class=n>page_table</span><span class=p>[</span><span class=n>page_number</span><span class=p>].</span><span class=n>frame_number</span> <span class=o>=</span> <span class=n>frame</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>process</span><span class=o>-&gt;</span><span class=n>page_table</span><span class=p>[</span><span class=n>page_number</span><span class=p>].</span><span class=n>present</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>process</span><span class=o>-&gt;</span><span class=n>page_table</span><span class=p>[</span><span class=n>page_number</span><span class=p>].</span><span class=n>writable</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>process</span><span class=o>-&gt;</span><span class=n>page_table</span><span class=p>[</span><span class=n>page_number</span><span class=p>].</span><span class=n>user_accessible</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>process</span><span class=o>-&gt;</span><span class=n>page_table</span><span class=p>[</span><span class=n>page_number</span><span class=p>].</span><span class=n>accessed</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>process</span><span class=o>-&gt;</span><span class=n>page_table</span><span class=p>[</span><span class=n>page_number</span><span class=p>].</span><span class=n>dirty</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>frame</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Translate virtual address to physical address
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>uint32_t</span> <span class=nf>translate_address</span><span class=p>(</span><span class=n>Process</span><span class=o>*</span> <span class=n>process</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>virtual_address</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Extract page number and offset
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint32_t</span> <span class=n>page_number</span> <span class=o>=</span> <span class=n>virtual_address</span> <span class=o>/</span> <span class=n>PAGE_SIZE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>offset</span> <span class=o>=</span> <span class=n>virtual_address</span> <span class=o>%</span> <span class=n>PAGE_SIZE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Check if page is in bounds
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>page_number</span> <span class=o>&gt;=</span> <span class=n>process</span><span class=o>-&gt;</span><span class=n>page_table_size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Error: Page number out of bounds</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Check if page is present in physical memory
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>process</span><span class=o>-&gt;</span><span class=n>page_table</span><span class=p>[</span><span class=n>page_number</span><span class=p>].</span><span class=n>present</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Page fault: Allocate a frame for this page
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Page fault: Allocating frame for page %u</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>page_number</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>frame</span> <span class=o>=</span> <span class=nf>allocate_page</span><span class=p>(</span><span class=n>process</span><span class=p>,</span> <span class=n>page_number</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>frame</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>  <span class=c1>// Allocation failed
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Mark page as accessed
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>process</span><span class=o>-&gt;</span><span class=n>page_table</span><span class=p>[</span><span class=n>page_number</span><span class=p>].</span><span class=n>accessed</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Calculate physical address
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint32_t</span> <span class=n>frame_number</span> <span class=o>=</span> <span class=n>process</span><span class=o>-&gt;</span><span class=n>page_table</span><span class=p>[</span><span class=n>page_number</span><span class=p>].</span><span class=n>frame_number</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>physical_address</span> <span class=o>=</span> <span class=p>(</span><span class=n>frame_number</span> <span class=o>*</span> <span class=n>PAGE_SIZE</span><span class=p>)</span> <span class=o>+</span> <span class=n>offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>physical_address</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Now let&rsquo;s add functions to read and write memory:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Write a byte to a virtual address
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>write_byte</span><span class=p>(</span><span class=n>Process</span><span class=o>*</span> <span class=n>process</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>virtual_address</span><span class=p>,</span> <span class=kt>uint8_t</span> <span class=n>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>physical_address</span> <span class=o>=</span> <span class=nf>translate_address</span><span class=p>(</span><span class=n>process</span><span class=p>,</span> <span class=n>virtual_address</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>physical_address</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>  <span class=c1>// Translation failed
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Check if page is writable
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint32_t</span> <span class=n>page_number</span> <span class=o>=</span> <span class=n>virtual_address</span> <span class=o>/</span> <span class=n>PAGE_SIZE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>process</span><span class=o>-&gt;</span><span class=n>page_table</span><span class=p>[</span><span class=n>page_number</span><span class=p>].</span><span class=n>writable</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Error: Page is not writable</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Mark page as dirty (modified)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>process</span><span class=o>-&gt;</span><span class=n>page_table</span><span class=p>[</span><span class=n>page_number</span><span class=p>].</span><span class=n>dirty</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Write to physical memory
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>physical_memory</span><span class=p>[</span><span class=n>physical_address</span><span class=p>]</span> <span class=o>=</span> <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Read a byte from a virtual address
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>uint8_t</span> <span class=nf>read_byte</span><span class=p>(</span><span class=n>Process</span><span class=o>*</span> <span class=n>process</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>virtual_address</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>physical_address</span> <span class=o>=</span> <span class=nf>translate_address</span><span class=p>(</span><span class=n>process</span><span class=p>,</span> <span class=n>virtual_address</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>physical_address</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>  <span class=c1>// Translation failed
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Read from physical memory
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>physical_memory</span><span class=p>[</span><span class=n>physical_address</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Finally, let&rsquo;s add a simple example of how to use this paging system:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Example usage
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Initialize frame allocation map
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>PHYSICAL_MEMORY_SIZE</span> <span class=o>/</span> <span class=n>PAGE_SIZE</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>frame_allocation_map</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>  <span class=c1>// All frames free initially
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Create a process
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Process</span><span class=o>*</span> <span class=n>process</span> <span class=o>=</span> <span class=nf>create_process</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Write some values to memory
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Writing values to virtual memory...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>5</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint32_t</span> <span class=n>addr</span> <span class=o>=</span> <span class=n>i</span> <span class=o>*</span> <span class=n>PAGE_SIZE</span> <span class=o>+</span> <span class=n>i</span><span class=p>;</span>  <span class=c1>// Access different pages
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>write_byte</span><span class=p>(</span><span class=n>process</span><span class=p>,</span> <span class=n>addr</span><span class=p>,</span> <span class=mi>65</span> <span class=o>+</span> <span class=n>i</span><span class=p>);</span>  <span class=c1>// ASCII &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, etc.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Wrote &#39;%c&#39; to virtual address %u</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=mi>65</span> <span class=o>+</span> <span class=n>i</span><span class=p>,</span> <span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Read the values back
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Reading values from virtual memory...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>5</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint32_t</span> <span class=n>addr</span> <span class=o>=</span> <span class=n>i</span> <span class=o>*</span> <span class=n>PAGE_SIZE</span> <span class=o>+</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint8_t</span> <span class=n>value</span> <span class=o>=</span> <span class=nf>read_byte</span><span class=p>(</span><span class=n>process</span><span class=p>,</span> <span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Read &#39;%c&#39; from virtual address %u</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>value</span><span class=p>,</span> <span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Clean up
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>free</span><span class=p>(</span><span class=n>process</span><span class=o>-&gt;</span><span class=n>page_table</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>process</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This code demonstrates the basic concepts of paging:</p><ol><li>Each process has its own page table mapping virtual pages to physical frames</li><li>Address translation breaks an address into page number and offset</li><li>Page faults occur when accessing a page not currently in physical memory</li><li>Pages can have attributes like present, writable, accessed, and dirty</li></ol><h3 id=enhancing-our-implementation-with-tlb>Enhancing Our Implementation with TLB<a hidden class=anchor aria-hidden=true href=#enhancing-our-implementation-with-tlb>#</a></h3><p>In real systems, page table lookups would be extremely slow if done for every memory access. To speed things up, processors use a Translation Lookaside Buffer (TLB)—a small, specialized cache that stores recent address translations.</p><p>Let&rsquo;s extend our example to include a simple TLB:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Define TLB entry structure
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>page_number</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>frame_number</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=n>valid</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>TLBEntry</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Define TLB
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define TLB_SIZE 16
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=n>TLBEntry</span> <span class=n>tlb</span><span class=p>[</span><span class=n>TLB_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=n>tlb_next_entry</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Initialize TLB
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>init_tlb</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>TLB_SIZE</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>tlb</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>valid</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Look up address in TLB
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>tlb_lookup</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>page_number</span><span class=p>,</span> <span class=kt>uint32_t</span><span class=o>*</span> <span class=n>frame_number</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>TLB_SIZE</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>tlb</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>valid</span> <span class=o>&amp;&amp;</span> <span class=n>tlb</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>page_number</span> <span class=o>==</span> <span class=n>page_number</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=o>*</span><span class=n>frame_number</span> <span class=o>=</span> <span class=n>tlb</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>frame_number</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>  <span class=c1>// TLB hit
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>  <span class=c1>// TLB miss
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Update TLB with new mapping
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>tlb_update</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>page_number</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>frame_number</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Use simple round-robin replacement
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>tlb</span><span class=p>[</span><span class=n>tlb_next_entry</span><span class=p>].</span><span class=n>page_number</span> <span class=o>=</span> <span class=n>page_number</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>tlb</span><span class=p>[</span><span class=n>tlb_next_entry</span><span class=p>].</span><span class=n>frame_number</span> <span class=o>=</span> <span class=n>frame_number</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>tlb</span><span class=p>[</span><span class=n>tlb_next_entry</span><span class=p>].</span><span class=n>valid</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Move to next entry
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>tlb_next_entry</span> <span class=o>=</span> <span class=p>(</span><span class=n>tlb_next_entry</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=n>TLB_SIZE</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Now, let&rsquo;s modify our address translation function to use the TLB:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Translate virtual address to physical address with TLB
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>uint32_t</span> <span class=nf>translate_address</span><span class=p>(</span><span class=n>Process</span><span class=o>*</span> <span class=n>process</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>virtual_address</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Extract page number and offset
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint32_t</span> <span class=n>page_number</span> <span class=o>=</span> <span class=n>virtual_address</span> <span class=o>/</span> <span class=n>PAGE_SIZE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>offset</span> <span class=o>=</span> <span class=n>virtual_address</span> <span class=o>%</span> <span class=n>PAGE_SIZE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>frame_number</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Check if page is in bounds
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>page_number</span> <span class=o>&gt;=</span> <span class=n>process</span><span class=o>-&gt;</span><span class=n>page_table_size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Error: Page number out of bounds</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Try TLB first
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nf>tlb_lookup</span><span class=p>(</span><span class=n>page_number</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>frame_number</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;TLB hit for page %u</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>page_number</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// TLB miss: Check page table
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;TLB miss for page %u</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>page_number</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// Check if page is present in physical memory
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>process</span><span class=o>-&gt;</span><span class=n>page_table</span><span class=p>[</span><span class=n>page_number</span><span class=p>].</span><span class=n>present</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Page fault: Allocate a frame for this page
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Page fault: Allocating frame for page %u</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>page_number</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>frame</span> <span class=o>=</span> <span class=nf>allocate_page</span><span class=p>(</span><span class=n>process</span><span class=p>,</span> <span class=n>page_number</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>frame</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>  <span class=c1>// Allocation failed
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>frame_number</span> <span class=o>=</span> <span class=n>frame</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>frame_number</span> <span class=o>=</span> <span class=n>process</span><span class=o>-&gt;</span><span class=n>page_table</span><span class=p>[</span><span class=n>page_number</span><span class=p>].</span><span class=n>frame_number</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// Update TLB with this translation
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>tlb_update</span><span class=p>(</span><span class=n>page_number</span><span class=p>,</span> <span class=n>frame_number</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Mark page as accessed
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>process</span><span class=o>-&gt;</span><span class=n>page_table</span><span class=p>[</span><span class=n>page_number</span><span class=p>].</span><span class=n>accessed</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Calculate physical address
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint32_t</span> <span class=n>physical_address</span> <span class=o>=</span> <span class=p>(</span><span class=n>frame_number</span> <span class=o>*</span> <span class=n>PAGE_SIZE</span><span class=p>)</span> <span class=o>+</span> <span class=n>offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>physical_address</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>And we would need to initialize the TLB in our main function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Initialize frame allocation map
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>PHYSICAL_MEMORY_SIZE</span> <span class=o>/</span> <span class=n>PAGE_SIZE</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>frame_allocation_map</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>  <span class=c1>// All frames free initially
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Initialize TLB
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>init_tlb</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Create a process
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Process</span><span class=o>*</span> <span class=n>process</span> <span class=o>=</span> <span class=nf>create_process</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Rest of the function remains the same...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><hr><h2 id=paging-vs-segmentation-a-deeper-comparison>Paging vs. Segmentation: A Deeper Comparison<a hidden class=anchor aria-hidden=true href=#paging-vs-segmentation-a-deeper-comparison>#</a></h2><p>Now that we understand paging better, let&rsquo;s compare it more thoroughly with segmentation, another memory management approach:</p><h3 id=fundamental-philosophy>Fundamental Philosophy<a hidden class=anchor aria-hidden=true href=#fundamental-philosophy>#</a></h3><p><strong>Paging</strong> is based on a fixed-size division approach. It&rsquo;s like dividing a book into pages of equal length, regardless of where chapters begin or end. This regularity simplifies physical memory management but doesn&rsquo;t align with how programs are naturally structured.</p><p><strong>Segmentation</strong>, on the other hand, divides memory based on logical program units—like having chapters in a book that can be any length but represent cohesive sections. Programs naturally consist of distinct sections like code, data, stack, and heap, which segmentation preserves as separate units.</p><h3 id=memory-utilization-challenges>Memory Utilization Challenges<a hidden class=anchor aria-hidden=true href=#memory-utilization-challenges>#</a></h3><p><strong>Paging</strong> eliminates external fragmentation (unusable gaps between allocated memory blocks) but introduces internal fragmentation. Since pages have fixed sizes, the last page of a process might not be fully utilized, wasting some memory. For example, if a process needs 4.5 pages, it will be allocated 5 full pages, wasting half a page.</p><p><strong>Segmentation</strong> has the opposite problem. It eliminates internal fragmentation since segments can be exactly the size needed, but it creates external fragmentation as segments of different sizes are allocated and deallocated over time.</p><p>Let&rsquo;s visualize this with memory diagrams:</p><p>For paging:</p><pre tabindex=0><code>Physical Memory with Paging (4KB pages)
┌───────┬───────┬───────┬───────┬───────┬───────┐
│Frame 0│Frame 1│Frame 2│Frame 3│Frame 4│Frame 5│...
│Process│Process│Process│Process│Process│  Free │
│   A   │   A   │   B   │   C   │   A   │       │
│ (Full)│ (Full)│ (Full)│ (Full)│(Half) │       │
└───────┴───────┴───────┴───────┴───────┴───────┘
                           ▲
                           │
                   Internal Fragmentation
                   (Half of Frame 4 wasted)
</code></pre><p>For segmentation:</p><pre tabindex=0><code>Physical Memory with Segmentation
┌────────────┬──────┬──────────────┬──────┬────────┐
│ Process A  │ Free │  Process B   │ Free │Process │...
│ Code Seg   │Space │  Data Seg    │Space │   C    │
│ (1.2 MB)   │(0.1MB│  (0.8 MB)    │(0.2MB│(0.5 MB)│
└────────────┴──────┴──────────────┴──────┴────────┘
                ▲           ▲
                │           │
         External Fragmentation
         (Small free spaces that can&#39;t be used)
</code></pre><h3 id=address-translation-complexity>Address Translation Complexity<a hidden class=anchor aria-hidden=true href=#address-translation-complexity>#</a></h3><p><strong>Paging</strong> has a straightforward address translation: divide the address into page number and offset, look up the page number in the page table to get the frame number, then combine the frame number with the offset.</p><p><strong>Segmentation</strong> requires more complex translation: the address includes a segment number and an offset, and segments can have different sizes. The system must check that the offset is within the segment&rsquo;s length bounds before calculating the physical address.</p><h3 id=protection-and-sharing>Protection and Sharing<a hidden class=anchor aria-hidden=true href=#protection-and-sharing>#</a></h3><p><strong>Paging</strong> makes sharing code between processes simple. If two processes use the same code (like a shared library), that code can be loaded into memory once and mapped into both processes&rsquo; address spaces through their respective page tables.</p><p><strong>Segmentation</strong> naturally aligns with protection needs—different segments can have different access permissions (read, write, execute). For example, code segments can be marked as read-only and executable, while data segments can be writable but not executable.</p><h3 id=implementation-in-modern-systems>Implementation in Modern Systems<a hidden class=anchor aria-hidden=true href=#implementation-in-modern-systems>#</a></h3><p>Most modern systems use a hybrid approach called <strong>paged segmentation</strong> or <strong>segmented paging</strong>. Let&rsquo;s explore how this works:</p><hr><h2 id=combining-paging-and-segmentation-the-best-of-both-worlds>Combining Paging and Segmentation: The Best of Both Worlds<a hidden class=anchor aria-hidden=true href=#combining-paging-and-segmentation-the-best-of-both-worlds>#</a></h2><p>In modern systems, we often see a hybrid approach that leverages the benefits of both paging and segmentation. Let&rsquo;s examine how this works in practice:</p><h3 id=segmented-paging>Segmented Paging<a hidden class=anchor aria-hidden=true href=#segmented-paging>#</a></h3><p>In segmented paging, the address space is first divided into segments that represent logical units of the program (like code, data, stack). Then, each segment is further divided into pages of fixed size.</p><p>The logical address in this scheme consists of three components:</p><ol><li>Segment Number</li><li>Page Number (within the segment)</li><li>Offset (within the page)</li></ol><p>Address translation becomes a two-step process:</p><ol><li>The segment number is used to locate the segment&rsquo;s page table</li><li>The page number is used to find the corresponding frame in physical memory</li></ol><p>Here&rsquo;s a C structure that could represent this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>base_address</span><span class=p>;</span>   <span class=c1>// Base address of the segment&#39;s page table
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint32_t</span> <span class=n>limit</span><span class=p>;</span>          <span class=c1>// Size of the segment in pages
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint8_t</span> <span class=nl>present</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>     <span class=c1>// Is this segment in memory?
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint8_t</span> <span class=nl>privilege</span> <span class=p>:</span> <span class=mi>2</span><span class=p>;</span>   <span class=c1>// Privilege level (0-3)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint8_t</span> <span class=nl>readable</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>    <span class=c1>// Can be read
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint8_t</span> <span class=nl>writable</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>    <span class=c1>// Can be written
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint8_t</span> <span class=nl>executable</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>  <span class=c1>// Can be executed
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>SegmentDescriptor</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>SegmentDescriptor</span><span class=o>*</span> <span class=n>segment_table</span><span class=p>;</span>  <span class=c1>// Segment descriptor table
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint32_t</span> <span class=n>segment_count</span><span class=p>;</span>           <span class=c1>// Number of segments
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>PageTableEntry</span><span class=o>**</span> <span class=n>page_tables</span><span class=p>;</span>     <span class=c1>// Array of page tables, one for each segment
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>ProcessMemoryMap</span><span class=p>;</span>
</span></span></code></pre></div><p>The address translation might look like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=nf>translate_segmented_paging_address</span><span class=p>(</span><span class=n>ProcessMemoryMap</span><span class=o>*</span> <span class=n>memory_map</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                            <span class=kt>uint32_t</span> <span class=n>segment</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                            <span class=kt>uint32_t</span> <span class=n>page</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                            <span class=kt>uint32_t</span> <span class=n>offset</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Check if segment is valid
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>segment</span> <span class=o>&gt;=</span> <span class=n>memory_map</span><span class=o>-&gt;</span><span class=n>segment_count</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Error: Segment number out of bounds</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Check segment permissions and limits
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>SegmentDescriptor</span><span class=o>*</span> <span class=n>seg_desc</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>memory_map</span><span class=o>-&gt;</span><span class=n>segment_table</span><span class=p>[</span><span class=n>segment</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>seg_desc</span><span class=o>-&gt;</span><span class=n>present</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Error: Segment not present in memory</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>page</span> <span class=o>&gt;=</span> <span class=n>seg_desc</span><span class=o>-&gt;</span><span class=n>limit</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Error: Page number exceeds segment limit</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Get page table for this segment
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>PageTableEntry</span><span class=o>*</span> <span class=n>page_table</span> <span class=o>=</span> <span class=n>memory_map</span><span class=o>-&gt;</span><span class=n>page_tables</span><span class=p>[</span><span class=n>segment</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Check if page is present
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>page_table</span><span class=p>[</span><span class=n>page</span><span class=p>].</span><span class=n>present</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Handle page fault
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Page fault: Segment %u, Page %u</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>segment</span><span class=p>,</span> <span class=n>page</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Page fault handling code would go here
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Get frame number
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint32_t</span> <span class=n>frame</span> <span class=o>=</span> <span class=n>page_table</span><span class=p>[</span><span class=n>page</span><span class=p>].</span><span class=n>frame_number</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Calculate physical address
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint32_t</span> <span class=n>physical_address</span> <span class=o>=</span> <span class=p>(</span><span class=n>frame</span> <span class=o>*</span> <span class=n>PAGE_SIZE</span><span class=p>)</span> <span class=o>+</span> <span class=n>offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>physical_address</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=intel-x86-memory-model-a-real-world-example>Intel x86 Memory Model: A Real-World Example<a hidden class=anchor aria-hidden=true href=#intel-x86-memory-model-a-real-world-example>#</a></h3><p>The Intel x86 architecture uses a form of segmented paging that has evolved over time. In protected mode, the processor uses segment registers to select segment descriptors from descriptor tables (GDT or LDT). The segmentation unit produces a linear address, which is then translated by the paging unit into a physical address.</p><p>Here&rsquo;s a simplified version of how it works:</p><ol><li>The application generates a logical address: (Segment Selector, Offset)</li><li>The processor uses the segment selector to retrieve the segment descriptor</li><li>The base address from the segment descriptor is added to the offset to form a linear address</li><li>The paging unit translates the linear address to a physical address:<ul><li>The upper bits form the page directory index</li><li>The middle bits form the page table index</li><li>The lower bits form the offset within the page</li></ul></li></ol><p>This is a complex but powerful approach that has supported decades of backward compatibility while allowing modern operating systems to implement efficient memory management.</p><hr><h2 id=practical-implementations-page-replacement-algorithms>Practical Implementations: Page Replacement Algorithms<a hidden class=anchor aria-hidden=true href=#practical-implementations-page-replacement-algorithms>#</a></h2><p>When physical memory is full and a new page needs to be loaded, the operating system must choose a page to evict. Several algorithms exist for this purpose, each with different characteristics. Let&rsquo;s implement a few in C:</p><h3 id=first-in-first-out-fifo>First-In-First-Out (FIFO)<a hidden class=anchor aria-hidden=true href=#first-in-first-out-fifo>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define MAX_FRAMES 64
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// FIFO queue
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>frames</span><span class=p>[</span><span class=n>MAX_FRAMES</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>front</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rear</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>FIFOQueue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>fifo_init</span><span class=p>(</span><span class=n>FIFOQueue</span><span class=o>*</span> <span class=n>queue</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span><span class=o>-&gt;</span><span class=n>front</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span><span class=o>-&gt;</span><span class=n>rear</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span><span class=o>-&gt;</span><span class=n>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>fifo_enqueue</span><span class=p>(</span><span class=n>FIFOQueue</span><span class=o>*</span> <span class=n>queue</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>frame</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>queue</span><span class=o>-&gt;</span><span class=n>count</span> <span class=o>&gt;=</span> <span class=n>MAX_FRAMES</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Queue is full</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span><span class=o>-&gt;</span><span class=n>rear</span> <span class=o>=</span> <span class=p>(</span><span class=n>queue</span><span class=o>-&gt;</span><span class=n>rear</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=n>MAX_FRAMES</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span><span class=o>-&gt;</span><span class=n>frames</span><span class=p>[</span><span class=n>queue</span><span class=o>-&gt;</span><span class=n>rear</span><span class=p>]</span> <span class=o>=</span> <span class=n>frame</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span><span class=o>-&gt;</span><span class=n>count</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=nf>fifo_dequeue</span><span class=p>(</span><span class=n>FIFOQueue</span><span class=o>*</span> <span class=n>queue</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>queue</span><span class=o>-&gt;</span><span class=n>count</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Queue is empty</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>frame</span> <span class=o>=</span> <span class=n>queue</span><span class=o>-&gt;</span><span class=n>frames</span><span class=p>[</span><span class=n>queue</span><span class=o>-&gt;</span><span class=n>front</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span><span class=o>-&gt;</span><span class=n>front</span> <span class=o>=</span> <span class=p>(</span><span class=n>queue</span><span class=o>-&gt;</span><span class=n>front</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=n>MAX_FRAMES</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span><span class=o>-&gt;</span><span class=n>count</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>frame</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Page replacement using FIFO
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>uint32_t</span> <span class=nf>replace_page_fifo</span><span class=p>(</span><span class=n>FIFOQueue</span><span class=o>*</span> <span class=n>queue</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>fifo_dequeue</span><span class=p>(</span><span class=n>queue</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=least-recently-used-lru>Least Recently Used (LRU)<a hidden class=anchor aria-hidden=true href=#least-recently-used-lru>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Simplified LRU implementation using a counter
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>frame</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>last_used_time</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>FrameUsage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>FrameUsage</span> <span class=n>frames</span><span class=p>[</span><span class=n>MAX_FRAMES</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>clock</span><span class=p>;</span>  <span class=c1>// Global clock for timestamp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>LRUTracker</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>lru_init</span><span class=p>(</span><span class=n>LRUTracker</span><span class=o>*</span> <span class=n>tracker</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>tracker</span><span class=o>-&gt;</span><span class=n>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>tracker</span><span class=o>-&gt;</span><span class=n>clock</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>lru_access</span><span class=p>(</span><span class=n>LRUTracker</span><span class=o>*</span> <span class=n>tracker</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>frame</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Find frame in tracker
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>tracker</span><span class=o>-&gt;</span><span class=n>count</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>tracker</span><span class=o>-&gt;</span><span class=n>frames</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>frame</span> <span class=o>==</span> <span class=n>frame</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Update last used time
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>tracker</span><span class=o>-&gt;</span><span class=n>frames</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>last_used_time</span> <span class=o>=</span> <span class=n>tracker</span><span class=o>-&gt;</span><span class=n>clock</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Frame not found, add it
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>tracker</span><span class=o>-&gt;</span><span class=n>count</span> <span class=o>&lt;</span> <span class=n>MAX_FRAMES</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>tracker</span><span class=o>-&gt;</span><span class=n>frames</span><span class=p>[</span><span class=n>tracker</span><span class=o>-&gt;</span><span class=n>count</span><span class=p>].</span><span class=n>frame</span> <span class=o>=</span> <span class=n>frame</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>tracker</span><span class=o>-&gt;</span><span class=n>frames</span><span class=p>[</span><span class=n>tracker</span><span class=o>-&gt;</span><span class=n>count</span><span class=p>].</span><span class=n>last_used_time</span> <span class=o>=</span> <span class=n>tracker</span><span class=o>-&gt;</span><span class=n>clock</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>tracker</span><span class=o>-&gt;</span><span class=n>count</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Error: LRU tracker full</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=nf>replace_page_lru</span><span class=p>(</span><span class=n>LRUTracker</span><span class=o>*</span> <span class=n>tracker</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>tracker</span><span class=o>-&gt;</span><span class=n>count</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Error: No frames to replace</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Find least recently used frame
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>lru_index</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>min_time</span> <span class=o>=</span> <span class=n>tracker</span><span class=o>-&gt;</span><span class=n>frames</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>last_used_time</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>tracker</span><span class=o>-&gt;</span><span class=n>count</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>tracker</span><span class=o>-&gt;</span><span class=n>frames</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>last_used_time</span> <span class=o>&lt;</span> <span class=n>min_time</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>min_time</span> <span class=o>=</span> <span class=n>tracker</span><span class=o>-&gt;</span><span class=n>frames</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>last_used_time</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>lru_index</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>frame_to_replace</span> <span class=o>=</span> <span class=n>tracker</span><span class=o>-&gt;</span><span class=n>frames</span><span class=p>[</span><span class=n>lru_index</span><span class=p>].</span><span class=n>frame</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Remove the frame from tracker (or just update it when reused)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>lru_index</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>tracker</span><span class=o>-&gt;</span><span class=n>count</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>tracker</span><span class=o>-&gt;</span><span class=n>frames</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>tracker</span><span class=o>-&gt;</span><span class=n>frames</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>tracker</span><span class=o>-&gt;</span><span class=n>count</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>frame_to_replace</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=the-second-chance-algorithm-clock>The Second Chance Algorithm (Clock)<a hidden class=anchor aria-hidden=true href=#the-second-chance-algorithm-clock>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Clock algorithm implementation
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>frames</span><span class=p>[</span><span class=n>MAX_FRAMES</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=n>referenced</span><span class=p>[</span><span class=n>MAX_FRAMES</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>hand</span><span class=p>;</span>  <span class=c1>// Clock hand
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>ClockAlgorithm</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>clock_init</span><span class=p>(</span><span class=n>ClockAlgorithm</span><span class=o>*</span> <span class=n>clock</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>clock</span><span class=o>-&gt;</span><span class=n>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>clock</span><span class=o>-&gt;</span><span class=n>hand</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>MAX_FRAMES</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>clock</span><span class=o>-&gt;</span><span class=n>referenced</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>clock_access</span><span class=p>(</span><span class=n>ClockAlgorithm</span><span class=o>*</span> <span class=n>clock</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>frame</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Find frame in clock
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>clock</span><span class=o>-&gt;</span><span class=n>count</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>clock</span><span class=o>-&gt;</span><span class=n>frames</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>frame</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Set referenced bit
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>clock</span><span class=o>-&gt;</span><span class=n>referenced</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Frame not found, add it
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>clock</span><span class=o>-&gt;</span><span class=n>count</span> <span class=o>&lt;</span> <span class=n>MAX_FRAMES</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>clock</span><span class=o>-&gt;</span><span class=n>frames</span><span class=p>[</span><span class=n>clock</span><span class=o>-&gt;</span><span class=n>count</span><span class=p>]</span> <span class=o>=</span> <span class=n>frame</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>clock</span><span class=o>-&gt;</span><span class=n>referenced</span><span class=p>[</span><span class=n>clock</span><span class=o>-&gt;</span><span class=n>count</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>clock</span><span class=o>-&gt;</span><span class=n>count</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Error: Clock algorithm tracker full</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=nf>replace_page_clock</span><span class=p>(</span><span class=n>ClockAlgorithm</span><span class=o>*</span> <span class=n>clock</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>clock</span><span class=o>-&gt;</span><span class=n>count</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Error: No frames to replace</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Find a frame to replace
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>clock</span><span class=o>-&gt;</span><span class=n>referenced</span><span class=p>[</span><span class=n>clock</span><span class=o>-&gt;</span><span class=n>hand</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Found a non-referenced frame to replace
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=kt>uint32_t</span> <span class=n>frame_to_replace</span> <span class=o>=</span> <span class=n>clock</span><span class=o>-&gt;</span><span class=n>frames</span><span class=p>[</span><span class=n>clock</span><span class=o>-&gt;</span><span class=n>hand</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1>// Move hand to next position
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>clock</span><span class=o>-&gt;</span><span class=n>hand</span> <span class=o>=</span> <span class=p>(</span><span class=n>clock</span><span class=o>-&gt;</span><span class=n>hand</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=n>clock</span><span class=o>-&gt;</span><span class=n>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>frame_to_replace</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// Give second chance by clearing referenced bit
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>clock</span><span class=o>-&gt;</span><span class=n>referenced</span><span class=p>[</span><span class=n>clock</span><span class=o>-&gt;</span><span class=n>hand</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// Move hand to next position
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>clock</span><span class=o>-&gt;</span><span class=n>hand</span> <span class=o>=</span> <span class=p>(</span><span class=n>clock</span><span class=o>-&gt;</span><span class=n>hand</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=n>clock</span><span class=o>-&gt;</span><span class=n>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><hr><h2 id=real-world-considerations-and-challenges>Real-World Considerations and Challenges<a hidden class=anchor aria-hidden=true href=#real-world-considerations-and-challenges>#</a></h2><h3 id=large-page-tables>Large Page Tables<a hidden class=anchor aria-hidden=true href=#large-page-tables>#</a></h3><p>As virtual address spaces grow larger, page tables can become enormous. For a 32-bit address space with 4KB pages, the page table would have 2^20 (over 1 million) entries. For 64-bit systems, this problem is exponentially worse.</p><p>Modern systems address this with multi-level page tables or inverted page tables:</p><ol><li><p><strong>Multi-level Page Tables</strong>: The page table is itself paged, creating a tree-like structure. This approach only requires the parts of the page table that are actually being used to be in memory.</p></li><li><p><strong>Inverted Page Tables</strong>: Instead of having one entry for each virtual page, an inverted page table has one entry for each physical frame, mapping back to which process and virtual page owns it. This reduces table size but makes lookups more complex.</p></li></ol><p>Here&rsquo;s a simplified implementation of a two-level page table:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define PAGE_TABLE_ENTRIES 1024  </span><span class=c1>// 2^10 entries in each table
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define PAGE_DIRECTORY_ENTRIES 1024  </span><span class=c1>// 2^10 entries in directory
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=nl>frame_number</span> <span class=p>:</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=nl>present</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=nl>writable</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=nl>user_accessible</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=nl>accessed</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=nl>dirty</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=nl>reserved</span> <span class=p>:</span> <span class=mi>7</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>PageTableEntry</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>PageTableEntry</span><span class=o>*</span> <span class=n>table_address</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=nl>present</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=nl>writable</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=nl>user_accessible</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=nl>reserved</span> <span class=p>:</span> <span class=mi>9</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>PageDirectoryEntry</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>PageDirectoryEntry</span><span class=o>*</span> <span class=n>page_directory</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>ProcessMemoryMap</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Allocate a two-level page table
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ProcessMemoryMap</span><span class=o>*</span> <span class=nf>create_two_level_page_table</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ProcessMemoryMap</span><span class=o>*</span> <span class=n>memory_map</span> <span class=o>=</span> <span class=p>(</span><span class=n>ProcessMemoryMap</span><span class=o>*</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>ProcessMemoryMap</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Allocate page directory
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>memory_map</span><span class=o>-&gt;</span><span class=n>page_directory</span> <span class=o>=</span> <span class=p>(</span><span class=n>PageDirectoryEntry</span><span class=o>*</span><span class=p>)</span><span class=nf>calloc</span><span class=p>(</span><span class=n>PAGE_DIRECTORY_ENTRIES</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>PageDirectoryEntry</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>memory_map</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Translate address using two-level page table
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>uint32_t</span> <span class=nf>translate_two_level_address</span><span class=p>(</span><span class=n>ProcessMemoryMap</span><span class=o>*</span> <span class=n>memory_map</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>virtual_address</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Extract directory index, page table index, and offset
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint32_t</span> <span class=n>directory_index</span> <span class=o>=</span> <span class=p>(</span><span class=n>virtual_address</span> <span class=o>&gt;&gt;</span> <span class=mi>22</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mh>0x3FF</span><span class=p>;</span>  <span class=c1>// Top 10 bits
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint32_t</span> <span class=n>page_table_index</span> <span class=o>=</span> <span class=p>(</span><span class=n>virtual_address</span> <span class=o>&gt;&gt;</span> <span class=mi>12</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mh>0x3FF</span><span class=p>;</span> <span class=c1>// Middle 10 bits
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint32_t</span> <span class=n>offset</span> <span class=o>=</span> <span class=n>virtual_address</span> <span class=o>&amp;</span> <span class=mh>0xFFF</span><span class=p>;</span>                  <span class=c1>// Bottom 12 bits
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=c1>// Check if page directory entry is present
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>PageDirectoryEntry</span><span class=o>*</span> <span class=n>dir_entry</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>memory_map</span><span class=o>-&gt;</span><span class=n>page_directory</span><span class=p>[</span><span class=n>directory_index</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>dir_entry</span><span class=o>-&gt;</span><span class=n>present</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Page directory entry not present</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Get page table
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>PageTableEntry</span><span class=o>*</span> <span class=n>page_table</span> <span class=o>=</span> <span class=n>dir_entry</span><span class=o>-&gt;</span><span class=n>table_address</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Check if page table entry is present
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>PageTableEntry</span><span class=o>*</span> <span class=n>page_entry</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>page_table</span><span class=p>[</span><span class=n>page_table_index</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>page_entry</span><span class=o>-&gt;</span><span class=n>present</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Page table entry not present</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Calculate physical address
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint32_t</span> <span class=n>physical_address</span> <span class=o>=</span> <span class=p>(</span><span class=n>page_entry</span><span class=o>-&gt;</span><span class=n>frame_number</span> <span class=o>&lt;&lt;</span> <span class=mi>12</span><span class=p>)</span> <span class=o>|</span> <span class=n>offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>physical_address</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=huge-pages-and-page-size-considerations>Huge Pages and Page Size Considerations<a hidden class=anchor aria-hidden=true href=#huge-pages-and-page-size-considerations>#</a></h3><p>While 4KB is the standard page size for many systems, larger pages (2MB or 1GB) are becoming more common, especially in systems with large amounts of RAM. These &ldquo;huge pages&rdquo; reduce the number of TLB entries needed to cover a given amount of memory, improving performance for large, contiguous memory accesses.</p><p>The tradeoff is that larger pages can lead to more internal fragmentation. It&rsquo;s a classic space-time tradeoff in computing.</p><hr><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Paging is a foundational technique in modern computing that enables efficient memory management, process isolation, and the illusion of unlimited memory through virtual memory. By dividing memory into fixed-size chunks, operating systems can allocate and manage memory with remarkable efficiency, even under the complex demands of multitasking environments.</p><p>The examples we&rsquo;ve explored in C provide a glimpse into how memory pagination might be implemented, though real-world operating systems are considerably more complex. Modern systems typically employ multi-level page tables, TLBs, huge pages, and sophisticated page replacement algorithms to optimize both performance and memory utilization.</p><p>Understanding paging is essential for anyone working in systems programming, operating system development, or performance optimization. The concepts we&rsquo;ve covered—from basic address translation to page replacement algorithms—form the foundation of virtually all modern computing environments.</p><p>For a deeper dive into practical implementations, I encourage exploring the memory management code in open-source operating systems like Linux or FreeBSD. These real-world systems showcase the elegant solutions that have evolved to address the challenges of memory management in complex computing environments.</p><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://lcs-developer.com/tags/operating-systems/>Operating-Systems</a></li><li><a href=https://lcs-developer.com/tags/virtual-memory/>Virtual-Memory</a></li><li><a href=https://lcs-developer.com/tags/coding/>Coding</a></li></ul><nav class=paginav><a class=prev href=https://lcs-developer.com/posts/the-central-limit-theorem/><span class=title>« Prev</span><br><span>The Central Limit Theorem</span>
</a><a class=next href=https://lcs-developer.com/posts/producer---consumer-posix/><span class=title>Next »</span><br><span>Producer-Consumer Problem with POSIX Synchronization</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Memory Pagination - A Comprehensive Guide on x" href="https://x.com/intent/tweet/?text=Memory%20Pagination%20-%20A%20Comprehensive%20Guide&amp;url=https%3a%2f%2flcs-developer.com%2fposts%2fmemory-pagination---a-comprehensive-guide%2f&amp;hashtags=Operating-Systems%2cVirtual-Memory%2cCoding"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Memory Pagination - A Comprehensive Guide on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flcs-developer.com%2fposts%2fmemory-pagination---a-comprehensive-guide%2f&amp;title=Memory%20Pagination%20-%20A%20Comprehensive%20Guide&amp;summary=Memory%20Pagination%20-%20A%20Comprehensive%20Guide&amp;source=https%3a%2f%2flcs-developer.com%2fposts%2fmemory-pagination---a-comprehensive-guide%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Memory Pagination - A Comprehensive Guide on reddit" href="https://reddit.com/submit?url=https%3a%2f%2flcs-developer.com%2fposts%2fmemory-pagination---a-comprehensive-guide%2f&title=Memory%20Pagination%20-%20A%20Comprehensive%20Guide"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Memory Pagination - A Comprehensive Guide on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flcs-developer.com%2fposts%2fmemory-pagination---a-comprehensive-guide%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Memory Pagination - A Comprehensive Guide on whatsapp" href="https://api.whatsapp.com/send?text=Memory%20Pagination%20-%20A%20Comprehensive%20Guide%20-%20https%3a%2f%2flcs-developer.com%2fposts%2fmemory-pagination---a-comprehensive-guide%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Memory Pagination - A Comprehensive Guide on telegram" href="https://telegram.me/share/url?text=Memory%20Pagination%20-%20A%20Comprehensive%20Guide&amp;url=https%3a%2f%2flcs-developer.com%2fposts%2fmemory-pagination---a-comprehensive-guide%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Memory Pagination - A Comprehensive Guide on ycombinator" href="https://news.ycombinator.com/submitlink?t=Memory%20Pagination%20-%20A%20Comprehensive%20Guide&u=https%3a%2f%2flcs-developer.com%2fposts%2fmemory-pagination---a-comprehensive-guide%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://lcs-developer.com/>LCS.Developer</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/XtremeXSPC/ rel=noopener target=_blank>Made with ❤️ by XtremeXSPC</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>