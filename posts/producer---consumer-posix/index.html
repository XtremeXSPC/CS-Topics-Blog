<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Producer-Consumer Problem with POSIX Synchronization | LCS.Developer</title>
<meta name=keywords content="Operating-Systems,Virtual-Memory,Coding"><meta name=description content="A robust solution to avoid race conditions in concurrent programming."><meta name=author content="LCS.Dev"><link rel=canonical href=https://lcs-developer.com/posts/producer---consumer-posix/><meta name=google-site-verification content="CPQPKX3QPR"><link crossorigin=anonymous href=/assets/css/stylesheet.15d0e6c72d5d9ab92a350006e113721b30916cb5e387bb09929270a6ba668526.css integrity="sha256-FdDmxy1dmrkqNQAG4RNyGzCRbLXjh7sJkpJwprpmhSY=" rel="preload stylesheet" as=style><link rel=icon href=https://lcs-developer.com/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lcs-developer.com/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lcs-developer.com/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://lcs-developer.com/favicon/apple-touch-icon.png><link rel=mask-icon href=https://lcs-developer.com/favicon/safari-pinned-tab.svg><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#ffffff"><link rel=alternate hreflang=en href=https://lcs-developer.com/posts/producer---consumer-posix/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.18/dist/katex.min.css integrity=sha384-veTAhWILPOotXm+kbR5uY7dRamYLJf58I7P+hJhjeuc7hsMAkJHTsPahAl0hBST0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.18/dist/katex.min.js integrity=sha384-v6mkHYHfY/4BWq54f7lQAdtIsoZZIByznQ3ZqN38OL4KCsrxo31SLlPiak7cj/Mg crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.18/dist/contrib/auto-render.min.js integrity=sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!0})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-CPQPKX3QPR"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-CPQPKX3QPR")}</script><meta property="og:url" content="https://lcs-developer.com/posts/producer---consumer-posix/"><meta property="og:site_name" content="LCS.Developer"><meta property="og:title" content="Producer-Consumer Problem with POSIX Synchronization"><meta property="og:description" content="A robust solution to avoid race conditions in concurrent programming."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-19T00:36:58+00:00"><meta property="article:modified_time" content="2024-12-19T00:36:58+00:00"><meta property="article:tag" content="Operating-Systems"><meta property="article:tag" content="Virtual-Memory"><meta property="article:tag" content="Coding"><meta property="og:image" content="https://lcs-developer.com/images/LCS.Dev-Logo.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://lcs-developer.com/images/LCS.Dev-Logo.jpg"><meta name=twitter:title content="Producer-Consumer Problem with POSIX Synchronization"><meta name=twitter:description content="A robust solution to avoid race conditions in concurrent programming."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://lcs-developer.com/posts/"},{"@type":"ListItem","position":2,"name":"Producer-Consumer Problem with POSIX Synchronization","item":"https://lcs-developer.com/posts/producer---consumer-posix/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Producer-Consumer Problem with POSIX Synchronization","name":"Producer-Consumer Problem with POSIX Synchronization","description":"A robust solution to avoid race conditions in concurrent programming.","keywords":["Operating-Systems","Virtual-Memory","Coding"],"articleBody":"Solving the Producer-Consumer Problem with Synchronization Imagine two processes working together: one creates data (the producer), while the other uses that data (the consumer). This classic scenario appears throughout computing systems - from operating system kernels managing device drivers to web servers handling client requests. However, when these processes run concurrently and share resources, we encounter a fundamental challenge in computer science: the producer-consumer problem.\nAt its heart, the producer-consumer problem involves coordinating these two types of processes when they share a fixed-size buffer. The producer generates data and places it into the buffer, while the consumer takes data from this same buffer for processing. This seemingly simple arrangement introduces several critical synchronization challenges:\nWhat happens when the producer tries to add data to a full buffer? What happens when the consumer tries to take data from an empty buffer? How do we prevent both processes from accessing the buffer simultaneously, which could corrupt the data? Without proper synchronization, our system could suffer from race conditions (where the final outcome depends on the unpredictable timing of operations), deadlocks (where processes wait indefinitely for each other), or starvation (where one process is perpetually denied access to needed resources).\nTo address these challenges, we’ll implement a solution using POSIX semaphores, which are synchronization primitives that help control access to shared resources. Our solution will use three key semaphores:\nThe empty semaphore acts as a counter for available slots in the buffer. Initially set to the buffer size, it decreases each time the producer adds an item and increases when the consumer removes one. When it reaches zero, the producer must wait until space becomes available.\nThe full semaphore tracks how many items are currently in the buffer. Starting at zero, it increases when the producer adds an item and decreases when the consumer removes one. When it’s zero, the consumer knows there’s nothing to consume and must wait.\nThe mutex semaphore serves as a gatekeeper, ensuring that only one process can modify the buffer at any given time. It prevents race conditions that could occur if both processes tried to update shared data structures simultaneously.\nFor storing the data itself, we’ll implement a circular buffer in shared memory that both processes can access. This circular design efficiently uses fixed memory by allowing the buffer positions to “wrap around” from the end back to the beginning.\nProducer Code (producer.c): #include #include #include #include #include #include #include #include #include #define BUFFER_SIZE 10 #define SHM_NAME \"/shm_buffer\" #define SEM_EMPTY_NAME \"/sem_empty\" #define SEM_FULL_NAME \"/sem_full\" #define SEM_MUTEX_NAME \"/sem_mutex\" /* Error handling macro */ #define CHECK(x, msg) \\ do { \\ if (!(x)) { \\ perror(msg); \\ exit(EXIT_FAILURE); \\ } \\ } while (0) typedef struct { int buffer[BUFFER_SIZE]; int in; /* Position where producer inserts next item */ int count; /* Current number of items in buffer */ } shared_data; int main() { /* Create or open shared memory */ int shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, 0666); CHECK(shm_fd != -1, \"shm_open failed\"); /* Set the size of the shared memory object */ CHECK(ftruncate(shm_fd, sizeof(shared_data)) != -1, \"ftruncate failed\"); /* Map the shared memory object into the address space */ shared_data *data = mmap(NULL, sizeof(shared_data), PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0); CHECK(data != MAP_FAILED, \"mmap failed\"); /* Initialize the buffer */ data-\u003ein = 0; data-\u003ecount = 0; printf(\"Producer starting. Buffer size: %d\\n\", BUFFER_SIZE); /* Create and initialize semaphores */ sem_t *empty = sem_open(SEM_EMPTY_NAME, O_CREAT, 0666, BUFFER_SIZE); CHECK(empty != SEM_FAILED, \"sem_open empty failed\"); sem_t *full = sem_open(SEM_FULL_NAME, O_CREAT, 0666, 0); CHECK(full != SEM_FAILED, \"sem_open full failed\"); sem_t *mutex = sem_open(SEM_MUTEX_NAME, O_CREAT, 0666, 1); CHECK(mutex != SEM_FAILED, \"sem_open mutex failed\"); /* Setup cleanup handler for graceful termination */ atexit(cleanup); signal(SIGINT, handle_signal); int item = 0; while(1) { /* Produce an item */ item++; printf(\"Producer is generating item: %d\\n\", item); /* Wait for an empty slot */ if (sem_wait(empty) == -1) { if (errno == EINTR) continue; /* Handle interruption by signal */ perror(\"sem_wait empty failed\"); break; } /* Enter critical section - access shared buffer */ if (sem_wait(mutex) == -1) { perror(\"sem_wait mutex failed\"); sem_post(empty); /* Give back the empty slot */ break; } /* Add item to buffer */ data-\u003ebuffer[data-\u003ein] = item; printf(\"Producer added item %d at position %d\\n\", item, data-\u003ein); /* Update buffer position */ data-\u003ein = (data-\u003ein + 1) % BUFFER_SIZE; data-\u003ecount++; /* Exit critical section */ sem_post(mutex); /* Signal that a new item is in the buffer */ sem_post(full); /* Simulate production time */ sleep(1); } /* Clean up resources - should not reach here due to infinite loop */ cleanup_resources(data, shm_fd, empty, full, mutex); return 0; } /* Signal handler for graceful termination */ void handle_signal(int sig) { printf(\"\\nProducer terminating...\\n\"); exit(EXIT_SUCCESS); } /* Clean up resources */ void cleanup_resources(shared_data *data, int shm_fd, sem_t *empty, sem_t *full, sem_t *mutex) { /* Unmap shared memory */ if (data != MAP_FAILED \u0026\u0026 munmap(data, sizeof(shared_data)) == -1) { perror(\"munmap failed\"); } /* Close shared memory */ if (shm_fd != -1 \u0026\u0026 close(shm_fd) == -1) { perror(\"close failed\"); } /* Close semaphores */ if (empty != SEM_FAILED \u0026\u0026 sem_close(empty) == -1) { perror(\"sem_close empty failed\"); } if (full != SEM_FAILED \u0026\u0026 sem_close(full) == -1) { perror(\"sem_close full failed\"); } if (mutex != SEM_FAILED \u0026\u0026 sem_close(mutex) == -1) { perror(\"sem_close mutex failed\"); } } /* Cleanup function registered with atexit */ void cleanup(void) { /* Unlink shared memory and semaphores */ shm_unlink(SHM_NAME); sem_unlink(SEM_EMPTY_NAME); sem_unlink(SEM_FULL_NAME); sem_unlink(SEM_MUTEX_NAME); printf(\"Producer cleaned up resources\\n\"); } Consumer Code (consumer.c): #include #include #include #include #include #include #include #include #include #define BUFFER_SIZE 10 #define SHM_NAME \"/shm_buffer\" #define SEM_EMPTY_NAME \"/sem_empty\" #define SEM_FULL_NAME \"/sem_full\" #define SEM_MUTEX_NAME \"/sem_mutex\" /* Error handling macro */ #define CHECK(x, msg) \\ do { \\ if (!(x)) { \\ perror(msg); \\ exit(EXIT_FAILURE); \\ } \\ } while (0) typedef struct { int buffer[BUFFER_SIZE]; int in; /* Position where producer inserts next item */ int count; /* Current number of items in buffer */ } shared_data; void handle_signal(int sig); void cleanup_resources(shared_data *data, int shm_fd, sem_t *empty, sem_t *full, sem_t *mutex); int main() { /* Open existing shared memory */ int shm_fd = shm_open(SHM_NAME, O_RDWR, 0666); CHECK(shm_fd != -1, \"shm_open failed - ensure producer is running\"); /* Map shared memory object */ shared_data *data = mmap(NULL, sizeof(shared_data), PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0); CHECK(data != MAP_FAILED, \"mmap failed\"); /* Open existing semaphores */ sem_t *empty = sem_open(SEM_EMPTY_NAME, 0); CHECK(empty != SEM_FAILED, \"sem_open empty failed\"); sem_t *full = sem_open(SEM_FULL_NAME, 0); CHECK(full != SEM_FAILED, \"sem_open full failed\"); sem_t *mutex = sem_open(SEM_MUTEX_NAME, 0); CHECK(mutex != SEM_FAILED, \"sem_open mutex failed\"); /* Setup signal handler for graceful termination */ signal(SIGINT, handle_signal); printf(\"Consumer starting. Waiting for items...\\n\"); int out = 0; /* Position where consumer removes items */ while(1) { /* Wait for an item to be available */ if (sem_wait(full) == -1) { if (errno == EINTR) continue; /* Handle interruption by signal */ perror(\"sem_wait full failed\"); break; } /* Enter critical section - access shared buffer */ if (sem_wait(mutex) == -1) { perror(\"sem_wait mutex failed\"); sem_post(full); /* Give back the full slot signal */ break; } /* Get item from buffer */ int item = data-\u003ebuffer[out]; printf(\"Consumer got item %d from position %d\\n\", item, out); /* Update buffer position */ out = (out + 1) % BUFFER_SIZE; data-\u003ecount--; /* Exit critical section */ sem_post(mutex); /* Signal that an empty slot is available */ sem_post(empty); /* Simulate consumption time */ sleep(2); printf(\"Consumer finished processing item %d\\n\", item); } /* Clean up resources - should not reach here due to infinite loop */ cleanup_resources(data, shm_fd, empty, full, mutex); return 0; } /* Signal handler for graceful termination */ void handle_signal(int sig) { printf(\"\\nConsumer terminating...\\n\"); exit(EXIT_SUCCESS); } /* Clean up resources */ void cleanup_resources(shared_data *data, int shm_fd, sem_t *empty, sem_t *full, sem_t *mutex) { /* Unmap shared memory */ if (data != MAP_FAILED \u0026\u0026 munmap(data, sizeof(shared_data)) == -1) { perror(\"munmap failed\"); } /* Close shared memory */ if (shm_fd != -1 \u0026\u0026 close(shm_fd) == -1) { perror(\"close failed\"); } /* Close semaphores */ if (empty != SEM_FAILED \u0026\u0026 sem_close(empty) == -1) { perror(\"sem_close empty failed\"); } if (full != SEM_FAILED \u0026\u0026 sem_close(full) == -1) { perror(\"sem_close full failed\"); } if (mutex != SEM_FAILED \u0026\u0026 sem_close(mutex) == -1) { perror(\"sem_close mutex failed\"); } printf(\"Consumer cleaned up resources\\n\"); } Understanding How the Solution Works Our implementation carefully orchestrates the producer and consumer processes to work harmoniously while avoiding common pitfalls in concurrent programming. Let’s explore how the various components work together to create a robust solution.\nThe Dance of Semaphores At the heart of our solution lies a system of three semaphores that coordinate access to the shared buffer. These semaphores act like traffic lights, telling processes when to proceed and when to wait.\nThe empty semaphore starts with a value equal to the buffer size (10 in our example). It represents the number of free slots available in the buffer. Each time the producer wants to add an item, it first calls sem_wait(empty), which decreases this counter by one. If the buffer is already full (meaning the counter has reached zero), this operation will block the producer until space becomes available. This elegant mechanism prevents buffer overflow without requiring the producer to constantly check the buffer’s state.\nThe full semaphore works in the opposite direction. Starting at zero (an empty buffer), it counts how many items are currently in the buffer. When the producer adds an item, it calls sem_post(full) to increment this counter. When the consumer wants to retrieve an item, it first calls sem_wait(full), which blocks if no items are available. This prevents the consumer from trying to access an empty buffer.\nThe mutex semaphore serves a different but equally critical role. While the other semaphores control the buffer capacity, the mutex ensures that only one process can modify the buffer at any given time. Both processes follow the same protocol: acquire the mutex before touching the buffer, then release it when done. This prevents race conditions where simultaneous access could lead to data corruption.\nThe Circular Buffer: An Elegant Data Structure Our shared data lives in a circular buffer, which is particularly well-suited for producer-consumer scenarios. Rather than a simple array where we might run out of space at the end, a circular buffer allows us to wrap around and reuse space from the beginning.\nWe track the current state with two indices: in (where the producer will add the next item) and out (where the consumer will remove the next item). As these indices reach the end of the buffer, they wrap around to the beginning using the modulo operation (position % BUFFER_SIZE). We’ve also added a count field that tracks the current number of items, which helps with debugging and monitoring.\nPreventing Concurrency Hazards Our solution carefully addresses three common hazards in concurrent programming:\nRace conditions occur when the outcome depends on the precise timing of operations. By using the mutex semaphore to guard all access to the shared buffer, we ensure that only one process can modify it at a time, making the operations atomic from the perspective of the other process.\nDeadlocks happen when processes are waiting for each other indefinitely. We prevent deadlocks by ensuring that the acquisition and release of semaphores follows a consistent order in both processes. Additionally, no process ever holds one semaphore while waiting for another, which is a common cause of deadlocks.\nStarvation occurs when a process is perpetually denied access to required resources. Our solution uses semaphores in a fair manner that naturally alternates access between producer and consumer, preventing any process from being indefinitely blocked while the other makes progress.\nRobustness Through Error Handling and Cleanup A production-quality solution must handle errors gracefully and clean up resources properly. Our implementation includes comprehensive error checking for all system calls, with a convenient CHECK macro that simplifies error handling code.\nWe’ve also implemented signal handlers that catch interruption signals (like when a user presses Ctrl+C), allowing for graceful termination. The cleanup_resources function ensures all resources are properly released, and the producer registers an atexit handler to clean up shared resources when terminated, preventing resource leaks even in unexpected scenarios.\nPutting It All Into Practice Now that we understand the theory and implementation details of our producer-consumer solution, let’s see how to build and run it on a real system. This section provides practical guidance for compiling, executing, and managing the code we’ve developed.\nCompiling the Programs Our solution uses POSIX shared memory and semaphores, which are part of the real-time extensions library (librt) and POSIX threads library (libpthread). To compile the programs with these dependencies, use:\ngcc -o producer producer.c -lrt -pthread gcc -o consumer consumer.c -lrt -pthread The -lrt flag links against the real-time library (needed for shared memory functions), while -pthread links against the POSIX threads library (needed for semaphores).\nRunning the Solution To see our producer-consumer solution in action, you’ll need to run the producer and consumer processes simultaneously. Open two terminal windows:\nIn the first terminal, start the producer:\n./producer You should see messages indicating that the producer is creating items and placing them in the buffer.\nIn the second terminal, start the consumer:\n./consumer The consumer will start retrieving items from the buffer and processing them.\nWatch both terminals to observe the interaction between the processes. You’ll see how the producer adds items to the buffer and the consumer removes them, all coordinated through our synchronization mechanisms.\nProper Resource Management One of the strengths of our implementation is its careful management of system resources. Even so, if a program is terminated abnormally (e.g., with Ctrl+C), there’s a small chance that some resources might not be cleaned up properly.\nIn such cases, you can manually remove the shared memory and semaphore resources:\nrm /dev/shm/shm_buffer rm /dev/shm/sem.sem_empty /dev/shm/sem.sem_full /dev/shm/sem.sem_mutex These commands remove the shared memory object and the three semaphores we created. It’s good practice to run these commands if you encounter any issues restarting the programs.\nBeyond the Basic Implementation The solution we’ve presented provides a solid foundation for understanding the producer-consumer problem and implementing a practical solution. However, real-world applications might require additional features:\nMultiple producers or consumers: Extending the solution to handle multiple producers and/or consumers would involve additional synchronization considerations. Dynamic buffer sizing: Implementing a buffer that can grow or shrink based on demand would require more sophisticated memory management. Priority scheduling: Adding priority to certain items in the buffer would require a more complex data structure than a simple circular buffer. These extensions would build upon the core principles we’ve covered: proper synchronization, careful memory management, and robust error handling.\nThe Architecture of Shared Memory Communication When two separate processes need to communicate, they face a fundamental challenge: by default, each process has its own isolated memory space. To bridge this gap, we use shared memory—a powerful inter-process communication mechanism that allows multiple processes to access the same region of memory.\nDesigning the Shared Data Structure The foundation of our solution is a carefully designed shared data structure that both processes can access and manipulate:\ntypedef struct { int buffer[BUFFER_SIZE]; int in; /* Position where producer inserts next item */ int count; /* Current number of items in buffer */ } shared_data; This seemingly simple structure embodies several important design decisions:\nThe buffer array forms the heart of our shared memory, providing the actual storage space where data flows from producer to consumer. By embedding this array directly within the structure (rather than using a pointer to an external array), we ensure that all the data resides within the shared memory region.\nThe in index tracks where the producer should place the next item. In the consumer code, we use a separate outvariable to track where items should be removed. This separation of concerns makes the code clearer and more maintainable.\nThe count field provides an additional safety mechanism that tracks how many items are currently in the buffer. While not strictly necessary for functionality (the semaphores handle the synchronization), it provides valuable information for debugging and monitoring the system’s state.\nWhat makes this structure special is that the entire thing—buffer, indices, and all—gets mapped into a shared memory region that both processes can see and modify. It becomes a shared whiteboard where our processes can coordinate their actions.\nCreating the Shared Memory Bridge Setting up shared memory involves three key steps that establish the communication channel between our processes:\n/* Create or open shared memory */ int shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, 0666); CHECK(shm_fd != -1, \"shm_open failed\"); /* Set the size of the shared memory object */ CHECK(ftruncate(shm_fd, sizeof(shared_data)) != -1, \"ftruncate failed\"); /* Map the shared memory object into the address space */ shared_data *data = mmap(NULL, sizeof(shared_data), PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0); CHECK(data != MAP_FAILED, \"mmap failed\"); First, we call shm_open to create a named shared memory object. This is like creating a file, but it lives in memory rather than on disk. The name (in our case, “/shm_buffer”) serves as an identifier that both processes can use to access the same memory region.\nNext, we use ftruncate to set the size of this memory object. This is a crucial step—we must ensure the region is large enough to hold our entire shared_data structure.\nFinally, the mmap call is where the magic happens. It maps the shared memory object into our process’s address space, returning a pointer that we can use just like any other pointer in our program. The key difference is that when we modify the memory this pointer points to, those changes are visible to any other process that has mapped the same shared memory object.\nThe producer creates this shared memory and initializes it, while the consumer simply opens and maps the existing region. Despite running as separate processes, they now have a common space where they can communicate and coordinate their actions.\nThe Pitfall of Pointers in Shared Memory In developing our solution, we made a critical design choice that might not be immediately obvious: embedding the buffer directly in our shared structure rather than using a pointer. This decision helps us avoid one of the most common and insidious traps in shared memory programming.\nThe Temptation of Pointers You might naturally consider defining our shared data structure like this:\ntypedef struct { int* buffer; // Pointer to a buffer allocated elsewhere int in; } shared_data; This approach might seem more flexible—after all, we could dynamically allocate the buffer to any size we need. However, it introduces a fundamental problem that stems from how operating systems manage process memory.\nWhy Pointers Break Across Process Boundaries The issue lies in the nature of virtual memory. Each process in a modern operating system has its own virtual address space—a mapping between the addresses a process “sees” and the actual physical memory locations. This provides isolation and protection between processes, but it means that the same virtual address in two different processes typically points to different physical memory locations.\nWhen process A stores a pointer (like buffer = malloc(...)) in shared memory, what it’s actually storing is an address that’s meaningful only within process A’s address space. When process B reads this pointer from shared memory, it gets the same numeric value—but in process B’s address space, this value points to an entirely different memory location (or possibly to none at all).\nLet’s visualize what happens:\nProducer process (Process A):\nAllocates memory with malloc(BUFFER_SIZE * sizeof(int)), getting address 0x7f8e42c00000 Stores this address in data-\u003ebuffer in shared memory In Process A’s memory map, 0x7f8e42c00000 points to the allocated buffer Consumer process (Process B):\nReads data-\u003ebuffer from shared memory, getting 0x7f8e42c00000 In Process B’s memory map, this address either points to completely different memory or is invalid When Process B tries to access data-\u003ebuffer[i], it either reads random data or crashes with a segmentation fault The Elegant Solution: Embedding the Array By embedding the buffer array directly within our shared structure:\ntypedef struct { int buffer[BUFFER_SIZE]; // The actual buffer, not a pointer int in; } shared_data; We ensure that the data itself—not just a reference to it—is part of the shared memory. When the entire structure is mapped into both processes’ address spaces, they both have direct access to the same physical memory locations representing the buffer. This sidesteps the virtual addressing problem entirely.\nAdvanced Techniques for Dynamic Memory in Shared Contexts For cases where more flexibility is needed (like a dynamically sized buffer), more advanced techniques exist but require careful implementation:\nOffset-based addressing: Instead of storing absolute pointers, store offsets from the beginning of the shared memory region. Both processes can then calculate the actual address in their own address space by adding the offset to the base address of their shared memory mapping.\nMemory pools: Allocate a large chunk of memory at the beginning of the shared region and implement a custom memory allocator that tracks allocations using offsets.\nShared memory allocation: Some systems provide specialized allocation functions (like shm_malloc) that work with shared memory, but these are non-standard and less portable.\nThe Principle of Simplicity For our producer-consumer implementation, embedding the buffer directly in the structure offers significant advantages:\nReliability: The code is less prone to subtle bugs that can occur with cross-process pointers. Simplicity: We avoid the need for complex offset calculations or custom allocators. Portability: The solution works across different operating systems and architectures that support POSIX shared memory. This design choice exemplifies an important principle in systems programming: sometimes the simplest approach is also the most robust. By avoiding pointers in our shared structure, we’ve created a solution that is both easier to understand and less likely to fail in unexpected ways.\n","wordCount":"3607","inLanguage":"en","image":"https://lcs-developer.com/images/LCS.Dev-Logo.jpg","datePublished":"2024-12-19T00:36:58.458443Z","dateModified":"2024-12-19T00:36:58.458443Z","author":{"@type":"Person","name":"LCS.Dev"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lcs-developer.com/posts/producer---consumer-posix/"},"publisher":{"@type":"Organization","name":"LCS.Developer","logo":{"@type":"ImageObject","url":"https://lcs-developer.com/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://lcs-developer.com/ accesskey=h title="LCS.Dev - CS Topics (Alt + H)"><img src=https://lcs-developer.com/%F0%9F%91%A8%E2%80%8D%F0%9F%92%BB alt aria-label=logo height=35>LCS.Dev - CS Topics</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://lcs-developer.com/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://lcs-developer.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://lcs-developer.com/about/ title=About><span>About</span></a></li><li><a href=https://lcs-developer.com/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://lcs-developer.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://lcs-developer.com/>Home</a>&nbsp;»&nbsp;<a href=https://lcs-developer.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Producer-Consumer Problem with POSIX Synchronization</h1><div class=post-description>A robust solution to avoid race conditions in concurrent programming.</div><div class=post-meta><span title='2024-12-19 00:36:58.458443 +0000 UTC'>December 19, 2024</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;3607 words&nbsp;·&nbsp;LCS.Dev&nbsp;|&nbsp;<a href=https://github.com/XtremeXSPC/LCS.Dev-Blog/tree/hostinger//posts/Producer%20-%20Consumer%20POSIX.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#solving-the-producer-consumer-problem-with-synchronization>Solving the Producer-Consumer Problem with Synchronization</a><ul><li><a href=#producer-code-producerc>Producer Code (<code>producer.c</code>):</a></li><li><a href=#consumer-code-consumerc>Consumer Code (<code>consumer.c</code>):</a></li></ul></li><li><a href=#understanding-how-the-solution-works>Understanding How the Solution Works</a><ul><li><a href=#the-dance-of-semaphores>The Dance of Semaphores</a></li><li><a href=#the-circular-buffer-an-elegant-data-structure>The Circular Buffer: An Elegant Data Structure</a></li><li><a href=#preventing-concurrency-hazards>Preventing Concurrency Hazards</a></li><li><a href=#robustness-through-error-handling-and-cleanup>Robustness Through Error Handling and Cleanup</a></li></ul></li><li><a href=#putting-it-all-into-practice>Putting It All Into Practice</a><ul><li><a href=#compiling-the-programs>Compiling the Programs</a></li><li><a href=#running-the-solution>Running the Solution</a></li><li><a href=#proper-resource-management>Proper Resource Management</a></li><li><a href=#beyond-the-basic-implementation>Beyond the Basic Implementation</a></li></ul></li><li><a href=#the-architecture-of-shared-memory-communication>The Architecture of Shared Memory Communication</a><ul><li><a href=#designing-the-shared-data-structure>Designing the Shared Data Structure</a></li><li><a href=#creating-the-shared-memory-bridge>Creating the Shared Memory Bridge</a></li></ul></li><li><a href=#the-pitfall-of-pointers-in-shared-memory>The Pitfall of Pointers in Shared Memory</a><ul><li><a href=#the-temptation-of-pointers>The Temptation of Pointers</a></li><li><a href=#why-pointers-break-across-process-boundaries>Why Pointers Break Across Process Boundaries</a></li><li><a href=#the-elegant-solution-embedding-the-array>The Elegant Solution: Embedding the Array</a></li><li><a href=#advanced-techniques-for-dynamic-memory-in-shared-contexts>Advanced Techniques for Dynamic Memory in Shared Contexts</a></li><li><a href=#the-principle-of-simplicity>The Principle of Simplicity</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=solving-the-producer-consumer-problem-with-synchronization>Solving the Producer-Consumer Problem with Synchronization<a hidden class=anchor aria-hidden=true href=#solving-the-producer-consumer-problem-with-synchronization>#</a></h2><p>Imagine two processes working together: one creates data (the producer), while the other uses that data (the consumer). This classic scenario appears throughout computing systems - from operating system kernels managing device drivers to web servers handling client requests. However, when these processes run concurrently and share resources, we encounter a fundamental challenge in computer science: the producer-consumer problem.</p><p>At its heart, the producer-consumer problem involves coordinating these two types of processes when they share a fixed-size buffer. The producer generates data and places it into the buffer, while the consumer takes data from this same buffer for processing. This seemingly simple arrangement introduces several critical synchronization challenges:</p><ol><li>What happens when the producer tries to add data to a full buffer?</li><li>What happens when the consumer tries to take data from an empty buffer?</li><li>How do we prevent both processes from accessing the buffer simultaneously, which could corrupt the data?</li></ol><p>Without proper synchronization, our system could suffer from race conditions (where the final outcome depends on the unpredictable timing of operations), deadlocks (where processes wait indefinitely for each other), or starvation (where one process is perpetually denied access to needed resources).</p><p>To address these challenges, we&rsquo;ll implement a solution using POSIX semaphores, which are synchronization primitives that help control access to shared resources. Our solution will use three key semaphores:</p><p>The <strong><code>empty</code> semaphore</strong> acts as a counter for available slots in the buffer. Initially set to the buffer size, it decreases each time the producer adds an item and increases when the consumer removes one. When it reaches zero, the producer must wait until space becomes available.</p><p>The <strong><code>full</code> semaphore</strong> tracks how many items are currently in the buffer. Starting at zero, it increases when the producer adds an item and decreases when the consumer removes one. When it&rsquo;s zero, the consumer knows there&rsquo;s nothing to consume and must wait.</p><p>The <strong><code>mutex</code> semaphore</strong> serves as a gatekeeper, ensuring that only one process can modify the buffer at any given time. It prevents race conditions that could occur if both processes tried to update shared data structures simultaneously.</p><p>For storing the data itself, we&rsquo;ll implement a circular buffer in shared memory that both processes can access. This circular design efficiently uses fixed memory by allowing the buffer positions to &ldquo;wrap around&rdquo; from the end back to the beginning.</p><hr><h3 id=producer-code-producerc>Producer Code (<code>producer.c</code>):<a hidden class=anchor aria-hidden=true href=#producer-code-producerc>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/mman.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;semaphore.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/stat.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;errno.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define BUFFER_SIZE 10
</span></span></span><span class=line><span class=cl><span class=cp>#define SHM_NAME &#34;/shm_buffer&#34;
</span></span></span><span class=line><span class=cl><span class=cp>#define SEM_EMPTY_NAME &#34;/sem_empty&#34;
</span></span></span><span class=line><span class=cl><span class=cp>#define SEM_FULL_NAME &#34;/sem_full&#34;
</span></span></span><span class=line><span class=cl><span class=cp>#define SEM_MUTEX_NAME &#34;/sem_mutex&#34;
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* Error handling macro */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CHECK(x, msg) \
</span></span></span><span class=line><span class=cl><span class=cp>    do { \
</span></span></span><span class=line><span class=cl><span class=cp>        if (!(x)) { \
</span></span></span><span class=line><span class=cl><span class=cp>            perror(msg); \
</span></span></span><span class=line><span class=cl><span class=cp>            exit(EXIT_FAILURE); \
</span></span></span><span class=line><span class=cl><span class=cp>        } \
</span></span></span><span class=line><span class=cl><span class=cp>    } while (0)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>buffer</span><span class=p>[</span><span class=n>BUFFER_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>in</span><span class=p>;</span>  <span class=cm>/* Position where producer inserts next item */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>count</span><span class=p>;</span> <span class=cm>/* Current number of items in buffer */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>shared_data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Create or open shared memory */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>shm_fd</span> <span class=o>=</span> <span class=nf>shm_open</span><span class=p>(</span><span class=n>SHM_NAME</span><span class=p>,</span> <span class=n>O_CREAT</span> <span class=o>|</span> <span class=n>O_RDWR</span><span class=p>,</span> <span class=mo>0666</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>CHECK</span><span class=p>(</span><span class=n>shm_fd</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=s>&#34;shm_open failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/* Set the size of the shared memory object */</span>
</span></span><span class=line><span class=cl>    <span class=nf>CHECK</span><span class=p>(</span><span class=nf>ftruncate</span><span class=p>(</span><span class=n>shm_fd</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>shared_data</span><span class=p>))</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=s>&#34;ftruncate failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/* Map the shared memory object into the address space */</span>
</span></span><span class=line><span class=cl>    <span class=n>shared_data</span> <span class=o>*</span><span class=n>data</span> <span class=o>=</span> <span class=nf>mmap</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>shared_data</span><span class=p>),</span> <span class=n>PROT_READ</span> <span class=o>|</span> <span class=n>PROT_WRITE</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                            <span class=n>MAP_SHARED</span><span class=p>,</span> <span class=n>shm_fd</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>CHECK</span><span class=p>(</span><span class=n>data</span> <span class=o>!=</span> <span class=n>MAP_FAILED</span><span class=p>,</span> <span class=s>&#34;mmap failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/* Initialize the buffer */</span>
</span></span><span class=line><span class=cl>    <span class=n>data</span><span class=o>-&gt;</span><span class=n>in</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>data</span><span class=o>-&gt;</span><span class=n>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Producer starting. Buffer size: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>BUFFER_SIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/* Create and initialize semaphores */</span>
</span></span><span class=line><span class=cl>    <span class=kt>sem_t</span> <span class=o>*</span><span class=n>empty</span> <span class=o>=</span> <span class=nf>sem_open</span><span class=p>(</span><span class=n>SEM_EMPTY_NAME</span><span class=p>,</span> <span class=n>O_CREAT</span><span class=p>,</span> <span class=mo>0666</span><span class=p>,</span> <span class=n>BUFFER_SIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>CHECK</span><span class=p>(</span><span class=n>empty</span> <span class=o>!=</span> <span class=n>SEM_FAILED</span><span class=p>,</span> <span class=s>&#34;sem_open empty failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>sem_t</span> <span class=o>*</span><span class=n>full</span> <span class=o>=</span> <span class=nf>sem_open</span><span class=p>(</span><span class=n>SEM_FULL_NAME</span><span class=p>,</span> <span class=n>O_CREAT</span><span class=p>,</span> <span class=mo>0666</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>CHECK</span><span class=p>(</span><span class=n>full</span> <span class=o>!=</span> <span class=n>SEM_FAILED</span><span class=p>,</span> <span class=s>&#34;sem_open full failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>sem_t</span> <span class=o>*</span><span class=n>mutex</span> <span class=o>=</span> <span class=nf>sem_open</span><span class=p>(</span><span class=n>SEM_MUTEX_NAME</span><span class=p>,</span> <span class=n>O_CREAT</span><span class=p>,</span> <span class=mo>0666</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>CHECK</span><span class=p>(</span><span class=n>mutex</span> <span class=o>!=</span> <span class=n>SEM_FAILED</span><span class=p>,</span> <span class=s>&#34;sem_open mutex failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/* Setup cleanup handler for graceful termination */</span>
</span></span><span class=line><span class=cl>    <span class=nf>atexit</span><span class=p>(</span><span class=n>cleanup</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>signal</span><span class=p>(</span><span class=n>SIGINT</span><span class=p>,</span> <span class=n>handle_signal</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>item</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Produce an item */</span>
</span></span><span class=line><span class=cl>        <span class=n>item</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Producer is generating item: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>item</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=cm>/* Wait for an empty slot */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>sem_wait</span><span class=p>(</span><span class=n>empty</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>errno</span> <span class=o>==</span> <span class=n>EINTR</span><span class=p>)</span> <span class=k>continue</span><span class=p>;</span> <span class=cm>/* Handle interruption by signal */</span>
</span></span><span class=line><span class=cl>            <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;sem_wait empty failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=cm>/* Enter critical section - access shared buffer */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>sem_wait</span><span class=p>(</span><span class=n>mutex</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;sem_wait mutex failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nf>sem_post</span><span class=p>(</span><span class=n>empty</span><span class=p>);</span> <span class=cm>/* Give back the empty slot */</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=cm>/* Add item to buffer */</span>
</span></span><span class=line><span class=cl>        <span class=n>data</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=p>[</span><span class=n>data</span><span class=o>-&gt;</span><span class=n>in</span><span class=p>]</span> <span class=o>=</span> <span class=n>item</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Producer added item %d at position %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>item</span><span class=p>,</span> <span class=n>data</span><span class=o>-&gt;</span><span class=n>in</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=cm>/* Update buffer position */</span>
</span></span><span class=line><span class=cl>        <span class=n>data</span><span class=o>-&gt;</span><span class=n>in</span> <span class=o>=</span> <span class=p>(</span><span class=n>data</span><span class=o>-&gt;</span><span class=n>in</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=n>BUFFER_SIZE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>data</span><span class=o>-&gt;</span><span class=n>count</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=cm>/* Exit critical section */</span>
</span></span><span class=line><span class=cl>        <span class=nf>sem_post</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=cm>/* Signal that a new item is in the buffer */</span>
</span></span><span class=line><span class=cl>        <span class=nf>sem_post</span><span class=p>(</span><span class=n>full</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=cm>/* Simulate production time */</span>
</span></span><span class=line><span class=cl>        <span class=nf>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/* Clean up resources - should not reach here due to infinite loop */</span>
</span></span><span class=line><span class=cl>    <span class=nf>cleanup_resources</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>shm_fd</span><span class=p>,</span> <span class=n>empty</span><span class=p>,</span> <span class=n>full</span><span class=p>,</span> <span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Signal handler for graceful termination */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>handle_signal</span><span class=p>(</span><span class=kt>int</span> <span class=n>sig</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Producer terminating...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>exit</span><span class=p>(</span><span class=n>EXIT_SUCCESS</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Clean up resources */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>cleanup_resources</span><span class=p>(</span><span class=n>shared_data</span> <span class=o>*</span><span class=n>data</span><span class=p>,</span> <span class=kt>int</span> <span class=n>shm_fd</span><span class=p>,</span> <span class=kt>sem_t</span> <span class=o>*</span><span class=n>empty</span><span class=p>,</span> <span class=kt>sem_t</span> <span class=o>*</span><span class=n>full</span><span class=p>,</span> <span class=kt>sem_t</span> <span class=o>*</span><span class=n>mutex</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Unmap shared memory */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>data</span> <span class=o>!=</span> <span class=n>MAP_FAILED</span> <span class=o>&amp;&amp;</span> <span class=nf>munmap</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>shared_data</span><span class=p>))</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;munmap failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/* Close shared memory */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>shm_fd</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=nf>close</span><span class=p>(</span><span class=n>shm_fd</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;close failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/* Close semaphores */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>empty</span> <span class=o>!=</span> <span class=n>SEM_FAILED</span> <span class=o>&amp;&amp;</span> <span class=nf>sem_close</span><span class=p>(</span><span class=n>empty</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;sem_close empty failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>full</span> <span class=o>!=</span> <span class=n>SEM_FAILED</span> <span class=o>&amp;&amp;</span> <span class=nf>sem_close</span><span class=p>(</span><span class=n>full</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;sem_close full failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>mutex</span> <span class=o>!=</span> <span class=n>SEM_FAILED</span> <span class=o>&amp;&amp;</span> <span class=nf>sem_close</span><span class=p>(</span><span class=n>mutex</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;sem_close mutex failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Cleanup function registered with atexit */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>cleanup</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Unlink shared memory and semaphores */</span>
</span></span><span class=line><span class=cl>    <span class=nf>shm_unlink</span><span class=p>(</span><span class=n>SHM_NAME</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>sem_unlink</span><span class=p>(</span><span class=n>SEM_EMPTY_NAME</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>sem_unlink</span><span class=p>(</span><span class=n>SEM_FULL_NAME</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>sem_unlink</span><span class=p>(</span><span class=n>SEM_MUTEX_NAME</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Producer cleaned up resources</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><hr><h3 id=consumer-code-consumerc>Consumer Code (<code>consumer.c</code>):<a hidden class=anchor aria-hidden=true href=#consumer-code-consumerc>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/mman.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;semaphore.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/stat.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;errno.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define BUFFER_SIZE 10
</span></span></span><span class=line><span class=cl><span class=cp>#define SHM_NAME &#34;/shm_buffer&#34;
</span></span></span><span class=line><span class=cl><span class=cp>#define SEM_EMPTY_NAME &#34;/sem_empty&#34;
</span></span></span><span class=line><span class=cl><span class=cp>#define SEM_FULL_NAME &#34;/sem_full&#34;
</span></span></span><span class=line><span class=cl><span class=cp>#define SEM_MUTEX_NAME &#34;/sem_mutex&#34;
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* Error handling macro */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CHECK(x, msg) \
</span></span></span><span class=line><span class=cl><span class=cp>    do { \
</span></span></span><span class=line><span class=cl><span class=cp>        if (!(x)) { \
</span></span></span><span class=line><span class=cl><span class=cp>            perror(msg); \
</span></span></span><span class=line><span class=cl><span class=cp>            exit(EXIT_FAILURE); \
</span></span></span><span class=line><span class=cl><span class=cp>        } \
</span></span></span><span class=line><span class=cl><span class=cp>    } while (0)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>buffer</span><span class=p>[</span><span class=n>BUFFER_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>in</span><span class=p>;</span>  <span class=cm>/* Position where producer inserts next item */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>count</span><span class=p>;</span> <span class=cm>/* Current number of items in buffer */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>shared_data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>handle_signal</span><span class=p>(</span><span class=kt>int</span> <span class=n>sig</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>cleanup_resources</span><span class=p>(</span><span class=n>shared_data</span> <span class=o>*</span><span class=n>data</span><span class=p>,</span> <span class=kt>int</span> <span class=n>shm_fd</span><span class=p>,</span> <span class=kt>sem_t</span> <span class=o>*</span><span class=n>empty</span><span class=p>,</span> <span class=kt>sem_t</span> <span class=o>*</span><span class=n>full</span><span class=p>,</span> <span class=kt>sem_t</span> <span class=o>*</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Open existing shared memory */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>shm_fd</span> <span class=o>=</span> <span class=nf>shm_open</span><span class=p>(</span><span class=n>SHM_NAME</span><span class=p>,</span> <span class=n>O_RDWR</span><span class=p>,</span> <span class=mo>0666</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>CHECK</span><span class=p>(</span><span class=n>shm_fd</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=s>&#34;shm_open failed - ensure producer is running&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/* Map shared memory object */</span>
</span></span><span class=line><span class=cl>    <span class=n>shared_data</span> <span class=o>*</span><span class=n>data</span> <span class=o>=</span> <span class=nf>mmap</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>shared_data</span><span class=p>),</span> <span class=n>PROT_READ</span> <span class=o>|</span> <span class=n>PROT_WRITE</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                            <span class=n>MAP_SHARED</span><span class=p>,</span> <span class=n>shm_fd</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>CHECK</span><span class=p>(</span><span class=n>data</span> <span class=o>!=</span> <span class=n>MAP_FAILED</span><span class=p>,</span> <span class=s>&#34;mmap failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/* Open existing semaphores */</span>
</span></span><span class=line><span class=cl>    <span class=kt>sem_t</span> <span class=o>*</span><span class=n>empty</span> <span class=o>=</span> <span class=nf>sem_open</span><span class=p>(</span><span class=n>SEM_EMPTY_NAME</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>CHECK</span><span class=p>(</span><span class=n>empty</span> <span class=o>!=</span> <span class=n>SEM_FAILED</span><span class=p>,</span> <span class=s>&#34;sem_open empty failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>sem_t</span> <span class=o>*</span><span class=n>full</span> <span class=o>=</span> <span class=nf>sem_open</span><span class=p>(</span><span class=n>SEM_FULL_NAME</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>CHECK</span><span class=p>(</span><span class=n>full</span> <span class=o>!=</span> <span class=n>SEM_FAILED</span><span class=p>,</span> <span class=s>&#34;sem_open full failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>sem_t</span> <span class=o>*</span><span class=n>mutex</span> <span class=o>=</span> <span class=nf>sem_open</span><span class=p>(</span><span class=n>SEM_MUTEX_NAME</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>CHECK</span><span class=p>(</span><span class=n>mutex</span> <span class=o>!=</span> <span class=n>SEM_FAILED</span><span class=p>,</span> <span class=s>&#34;sem_open mutex failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/* Setup signal handler for graceful termination */</span>
</span></span><span class=line><span class=cl>    <span class=nf>signal</span><span class=p>(</span><span class=n>SIGINT</span><span class=p>,</span> <span class=n>handle_signal</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Consumer starting. Waiting for items...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>out</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>  <span class=cm>/* Position where consumer removes items */</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Wait for an item to be available */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>sem_wait</span><span class=p>(</span><span class=n>full</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>errno</span> <span class=o>==</span> <span class=n>EINTR</span><span class=p>)</span> <span class=k>continue</span><span class=p>;</span> <span class=cm>/* Handle interruption by signal */</span>
</span></span><span class=line><span class=cl>            <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;sem_wait full failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=cm>/* Enter critical section - access shared buffer */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>sem_wait</span><span class=p>(</span><span class=n>mutex</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;sem_wait mutex failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nf>sem_post</span><span class=p>(</span><span class=n>full</span><span class=p>);</span> <span class=cm>/* Give back the full slot signal */</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=cm>/* Get item from buffer */</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>item</span> <span class=o>=</span> <span class=n>data</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=p>[</span><span class=n>out</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Consumer got item %d from position %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>item</span><span class=p>,</span> <span class=n>out</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=cm>/* Update buffer position */</span>
</span></span><span class=line><span class=cl>        <span class=n>out</span> <span class=o>=</span> <span class=p>(</span><span class=n>out</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=n>BUFFER_SIZE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>data</span><span class=o>-&gt;</span><span class=n>count</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=cm>/* Exit critical section */</span>
</span></span><span class=line><span class=cl>        <span class=nf>sem_post</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=cm>/* Signal that an empty slot is available */</span>
</span></span><span class=line><span class=cl>        <span class=nf>sem_post</span><span class=p>(</span><span class=n>empty</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=cm>/* Simulate consumption time */</span>
</span></span><span class=line><span class=cl>        <span class=nf>sleep</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Consumer finished processing item %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>item</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/* Clean up resources - should not reach here due to infinite loop */</span>
</span></span><span class=line><span class=cl>    <span class=nf>cleanup_resources</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>shm_fd</span><span class=p>,</span> <span class=n>empty</span><span class=p>,</span> <span class=n>full</span><span class=p>,</span> <span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Signal handler for graceful termination */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>handle_signal</span><span class=p>(</span><span class=kt>int</span> <span class=n>sig</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Consumer terminating...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>exit</span><span class=p>(</span><span class=n>EXIT_SUCCESS</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Clean up resources */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>cleanup_resources</span><span class=p>(</span><span class=n>shared_data</span> <span class=o>*</span><span class=n>data</span><span class=p>,</span> <span class=kt>int</span> <span class=n>shm_fd</span><span class=p>,</span> <span class=kt>sem_t</span> <span class=o>*</span><span class=n>empty</span><span class=p>,</span> <span class=kt>sem_t</span> <span class=o>*</span><span class=n>full</span><span class=p>,</span> <span class=kt>sem_t</span> <span class=o>*</span><span class=n>mutex</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Unmap shared memory */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>data</span> <span class=o>!=</span> <span class=n>MAP_FAILED</span> <span class=o>&amp;&amp;</span> <span class=nf>munmap</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>shared_data</span><span class=p>))</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;munmap failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/* Close shared memory */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>shm_fd</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=nf>close</span><span class=p>(</span><span class=n>shm_fd</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;close failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/* Close semaphores */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>empty</span> <span class=o>!=</span> <span class=n>SEM_FAILED</span> <span class=o>&amp;&amp;</span> <span class=nf>sem_close</span><span class=p>(</span><span class=n>empty</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;sem_close empty failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>full</span> <span class=o>!=</span> <span class=n>SEM_FAILED</span> <span class=o>&amp;&amp;</span> <span class=nf>sem_close</span><span class=p>(</span><span class=n>full</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;sem_close full failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>mutex</span> <span class=o>!=</span> <span class=n>SEM_FAILED</span> <span class=o>&amp;&amp;</span> <span class=nf>sem_close</span><span class=p>(</span><span class=n>mutex</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;sem_close mutex failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Consumer cleaned up resources</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><hr><h2 id=understanding-how-the-solution-works>Understanding How the Solution Works<a hidden class=anchor aria-hidden=true href=#understanding-how-the-solution-works>#</a></h2><p>Our implementation carefully orchestrates the producer and consumer processes to work harmoniously while avoiding common pitfalls in concurrent programming. Let&rsquo;s explore how the various components work together to create a robust solution.</p><h3 id=the-dance-of-semaphores>The Dance of Semaphores<a hidden class=anchor aria-hidden=true href=#the-dance-of-semaphores>#</a></h3><p>At the heart of our solution lies a system of three semaphores that coordinate access to the shared buffer. These semaphores act like traffic lights, telling processes when to proceed and when to wait.</p><p>The <strong><code>empty</code> semaphore</strong> starts with a value equal to the buffer size (10 in our example). It represents the number of free slots available in the buffer. Each time the producer wants to add an item, it first calls <code>sem_wait(empty)</code>, which decreases this counter by one. If the buffer is already full (meaning the counter has reached zero), this operation will block the producer until space becomes available. This elegant mechanism prevents buffer overflow without requiring the producer to constantly check the buffer&rsquo;s state.</p><p>The <strong><code>full</code> semaphore</strong> works in the opposite direction. Starting at zero (an empty buffer), it counts how many items are currently in the buffer. When the producer adds an item, it calls <code>sem_post(full)</code> to increment this counter. When the consumer wants to retrieve an item, it first calls <code>sem_wait(full)</code>, which blocks if no items are available. This prevents the consumer from trying to access an empty buffer.</p><p>The <strong><code>mutex</code> semaphore</strong> serves a different but equally critical role. While the other semaphores control the buffer capacity, the mutex ensures that only one process can modify the buffer at any given time. Both processes follow the same protocol: acquire the mutex before touching the buffer, then release it when done. This prevents race conditions where simultaneous access could lead to data corruption.</p><h3 id=the-circular-buffer-an-elegant-data-structure>The Circular Buffer: An Elegant Data Structure<a hidden class=anchor aria-hidden=true href=#the-circular-buffer-an-elegant-data-structure>#</a></h3><p>Our shared data lives in a circular buffer, which is particularly well-suited for producer-consumer scenarios. Rather than a simple array where we might run out of space at the end, a circular buffer allows us to wrap around and reuse space from the beginning.</p><p>We track the current state with two indices: <code>in</code> (where the producer will add the next item) and <code>out</code> (where the consumer will remove the next item). As these indices reach the end of the buffer, they wrap around to the beginning using the modulo operation (<code>position % BUFFER_SIZE</code>). We&rsquo;ve also added a <code>count</code> field that tracks the current number of items, which helps with debugging and monitoring.</p><h3 id=preventing-concurrency-hazards>Preventing Concurrency Hazards<a hidden class=anchor aria-hidden=true href=#preventing-concurrency-hazards>#</a></h3><p>Our solution carefully addresses three common hazards in concurrent programming:</p><p><strong>Race conditions</strong> occur when the outcome depends on the precise timing of operations. By using the mutex semaphore to guard all access to the shared buffer, we ensure that only one process can modify it at a time, making the operations atomic from the perspective of the other process.</p><p><strong>Deadlocks</strong> happen when processes are waiting for each other indefinitely. We prevent deadlocks by ensuring that the acquisition and release of semaphores follows a consistent order in both processes. Additionally, no process ever holds one semaphore while waiting for another, which is a common cause of deadlocks.</p><p><strong>Starvation</strong> occurs when a process is perpetually denied access to required resources. Our solution uses semaphores in a fair manner that naturally alternates access between producer and consumer, preventing any process from being indefinitely blocked while the other makes progress.</p><h3 id=robustness-through-error-handling-and-cleanup>Robustness Through Error Handling and Cleanup<a hidden class=anchor aria-hidden=true href=#robustness-through-error-handling-and-cleanup>#</a></h3><p>A production-quality solution must handle errors gracefully and clean up resources properly. Our implementation includes comprehensive error checking for all system calls, with a convenient <code>CHECK</code> macro that simplifies error handling code.</p><p>We&rsquo;ve also implemented signal handlers that catch interruption signals (like when a user presses Ctrl+C), allowing for graceful termination. The <code>cleanup_resources</code> function ensures all resources are properly released, and the producer registers an <code>atexit</code> handler to clean up shared resources when terminated, preventing resource leaks even in unexpected scenarios.</p><hr><h2 id=putting-it-all-into-practice>Putting It All Into Practice<a hidden class=anchor aria-hidden=true href=#putting-it-all-into-practice>#</a></h2><p>Now that we understand the theory and implementation details of our producer-consumer solution, let&rsquo;s see how to build and run it on a real system. This section provides practical guidance for compiling, executing, and managing the code we&rsquo;ve developed.</p><h3 id=compiling-the-programs>Compiling the Programs<a hidden class=anchor aria-hidden=true href=#compiling-the-programs>#</a></h3><p>Our solution uses POSIX shared memory and semaphores, which are part of the real-time extensions library (<code>librt</code>) and POSIX threads library (<code>libpthread</code>). To compile the programs with these dependencies, use:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>gcc -o producer producer.c -lrt -pthread
</span></span><span class=line><span class=cl>gcc -o consumer consumer.c -lrt -pthread
</span></span></code></pre></div><p>The <code>-lrt</code> flag links against the real-time library (needed for shared memory functions), while <code>-pthread</code> links against the POSIX threads library (needed for semaphores).</p><h3 id=running-the-solution>Running the Solution<a hidden class=anchor aria-hidden=true href=#running-the-solution>#</a></h3><p>To see our producer-consumer solution in action, you&rsquo;ll need to run the producer and consumer processes simultaneously. Open two terminal windows:</p><ol><li><p>In the first terminal, start the producer:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>./producer
</span></span></code></pre></div><p>You should see messages indicating that the producer is creating items and placing them in the buffer.</p></li><li><p>In the second terminal, start the consumer:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>./consumer
</span></span></code></pre></div><p>The consumer will start retrieving items from the buffer and processing them.</p></li></ol><p>Watch both terminals to observe the interaction between the processes. You&rsquo;ll see how the producer adds items to the buffer and the consumer removes them, all coordinated through our synchronization mechanisms.</p><h3 id=proper-resource-management>Proper Resource Management<a hidden class=anchor aria-hidden=true href=#proper-resource-management>#</a></h3><p>One of the strengths of our implementation is its careful management of system resources. Even so, if a program is terminated abnormally (e.g., with Ctrl+C), there&rsquo;s a small chance that some resources might not be cleaned up properly.</p><p>In such cases, you can manually remove the shared memory and semaphore resources:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>rm /dev/shm/shm_buffer
</span></span><span class=line><span class=cl>rm /dev/shm/sem.sem_empty /dev/shm/sem.sem_full /dev/shm/sem.sem_mutex
</span></span></code></pre></div><p>These commands remove the shared memory object and the three semaphores we created. It&rsquo;s good practice to run these commands if you encounter any issues restarting the programs.</p><h3 id=beyond-the-basic-implementation>Beyond the Basic Implementation<a hidden class=anchor aria-hidden=true href=#beyond-the-basic-implementation>#</a></h3><p>The solution we&rsquo;ve presented provides a solid foundation for understanding the producer-consumer problem and implementing a practical solution. However, real-world applications might require additional features:</p><ul><li><strong>Multiple producers or consumers:</strong> Extending the solution to handle multiple producers and/or consumers would involve additional synchronization considerations.</li><li><strong>Dynamic buffer sizing:</strong> Implementing a buffer that can grow or shrink based on demand would require more sophisticated memory management.</li><li><strong>Priority scheduling:</strong> Adding priority to certain items in the buffer would require a more complex data structure than a simple circular buffer.</li></ul><p>These extensions would build upon the core principles we&rsquo;ve covered: proper synchronization, careful memory management, and robust error handling.</p><hr><h2 id=the-architecture-of-shared-memory-communication>The Architecture of Shared Memory Communication<a hidden class=anchor aria-hidden=true href=#the-architecture-of-shared-memory-communication>#</a></h2><p>When two separate processes need to communicate, they face a fundamental challenge: by default, each process has its own isolated memory space. To bridge this gap, we use shared memory—a powerful inter-process communication mechanism that allows multiple processes to access the same region of memory.</p><h3 id=designing-the-shared-data-structure>Designing the Shared Data Structure<a hidden class=anchor aria-hidden=true href=#designing-the-shared-data-structure>#</a></h3><p>The foundation of our solution is a carefully designed shared data structure that both processes can access and manipulate:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>buffer</span><span class=p>[</span><span class=n>BUFFER_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>in</span><span class=p>;</span>  <span class=cm>/* Position where producer inserts next item */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>count</span><span class=p>;</span> <span class=cm>/* Current number of items in buffer */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>shared_data</span><span class=p>;</span>
</span></span></code></pre></div><p>This seemingly simple structure embodies several important design decisions:</p><p>The <strong>buffer array</strong> forms the heart of our shared memory, providing the actual storage space where data flows from producer to consumer. By embedding this array directly within the structure (rather than using a pointer to an external array), we ensure that all the data resides within the shared memory region.</p><p>The <strong>in index</strong> tracks where the producer should place the next item. In the consumer code, we use a separate <code>out</code>variable to track where items should be removed. This separation of concerns makes the code clearer and more maintainable.</p><p>The <strong>count field</strong> provides an additional safety mechanism that tracks how many items are currently in the buffer. While not strictly necessary for functionality (the semaphores handle the synchronization), it provides valuable information for debugging and monitoring the system&rsquo;s state.</p><p>What makes this structure special is that the entire thing—buffer, indices, and all—gets mapped into a shared memory region that both processes can see and modify. It becomes a shared whiteboard where our processes can coordinate their actions.</p><h3 id=creating-the-shared-memory-bridge>Creating the Shared Memory Bridge<a hidden class=anchor aria-hidden=true href=#creating-the-shared-memory-bridge>#</a></h3><p>Setting up shared memory involves three key steps that establish the communication channel between our processes:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* Create or open shared memory */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>shm_fd</span> <span class=o>=</span> <span class=nf>shm_open</span><span class=p>(</span><span class=n>SHM_NAME</span><span class=p>,</span> <span class=n>O_CREAT</span> <span class=o>|</span> <span class=n>O_RDWR</span><span class=p>,</span> <span class=mo>0666</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>CHECK</span><span class=p>(</span><span class=n>shm_fd</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=s>&#34;shm_open failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Set the size of the shared memory object */</span>
</span></span><span class=line><span class=cl><span class=nf>CHECK</span><span class=p>(</span><span class=nf>ftruncate</span><span class=p>(</span><span class=n>shm_fd</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>shared_data</span><span class=p>))</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=s>&#34;ftruncate failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Map the shared memory object into the address space */</span>
</span></span><span class=line><span class=cl><span class=n>shared_data</span> <span class=o>*</span><span class=n>data</span> <span class=o>=</span> <span class=nf>mmap</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>shared_data</span><span class=p>),</span> <span class=n>PROT_READ</span> <span class=o>|</span> <span class=n>PROT_WRITE</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                        <span class=n>MAP_SHARED</span><span class=p>,</span> <span class=n>shm_fd</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>CHECK</span><span class=p>(</span><span class=n>data</span> <span class=o>!=</span> <span class=n>MAP_FAILED</span><span class=p>,</span> <span class=s>&#34;mmap failed&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>First, we call <code>shm_open</code> to create a named shared memory object. This is like creating a file, but it lives in memory rather than on disk. The name (in our case, &ldquo;/shm_buffer&rdquo;) serves as an identifier that both processes can use to access the same memory region.</p><p>Next, we use <code>ftruncate</code> to set the size of this memory object. This is a crucial step—we must ensure the region is large enough to hold our entire <code>shared_data</code> structure.</p><p>Finally, the <code>mmap</code> call is where the magic happens. It maps the shared memory object into our process&rsquo;s address space, returning a pointer that we can use just like any other pointer in our program. The key difference is that when we modify the memory this pointer points to, those changes are visible to any other process that has mapped the same shared memory object.</p><p>The producer creates this shared memory and initializes it, while the consumer simply opens and maps the existing region. Despite running as separate processes, they now have a common space where they can communicate and coordinate their actions.</p><hr><h2 id=the-pitfall-of-pointers-in-shared-memory>The Pitfall of Pointers in Shared Memory<a hidden class=anchor aria-hidden=true href=#the-pitfall-of-pointers-in-shared-memory>#</a></h2><p>In developing our solution, we made a critical design choice that might not be immediately obvious: embedding the buffer directly in our shared structure rather than using a pointer. This decision helps us avoid one of the most common and insidious traps in shared memory programming.</p><h3 id=the-temptation-of-pointers>The Temptation of Pointers<a hidden class=anchor aria-hidden=true href=#the-temptation-of-pointers>#</a></h3><p>You might naturally consider defining our shared data structure like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span><span class=o>*</span> <span class=n>buffer</span><span class=p>;</span>  <span class=c1>// Pointer to a buffer allocated elsewhere
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>in</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>shared_data</span><span class=p>;</span>
</span></span></code></pre></div><p>This approach might seem more flexible—after all, we could dynamically allocate the buffer to any size we need. However, it introduces a fundamental problem that stems from how operating systems manage process memory.</p><h3 id=why-pointers-break-across-process-boundaries>Why Pointers Break Across Process Boundaries<a hidden class=anchor aria-hidden=true href=#why-pointers-break-across-process-boundaries>#</a></h3><p>The issue lies in the nature of virtual memory. Each process in a modern operating system has its own virtual address space—a mapping between the addresses a process &ldquo;sees&rdquo; and the actual physical memory locations. This provides isolation and protection between processes, but it means that the same virtual address in two different processes typically points to different physical memory locations.</p><p>When process A stores a pointer (like <code>buffer = malloc(...)</code>) in shared memory, what it&rsquo;s actually storing is an address that&rsquo;s meaningful only within process A&rsquo;s address space. When process B reads this pointer from shared memory, it gets the same numeric value—but in process B&rsquo;s address space, this value points to an entirely different memory location (or possibly to none at all).</p><p>Let&rsquo;s visualize what happens:</p><ol><li><p><strong>Producer process</strong> (Process A):</p><ul><li>Allocates memory with <code>malloc(BUFFER_SIZE * sizeof(int))</code>, getting address <code>0x7f8e42c00000</code></li><li>Stores this address in <code>data->buffer</code> in shared memory</li><li>In Process A&rsquo;s memory map, <code>0x7f8e42c00000</code> points to the allocated buffer</li></ul></li><li><p><strong>Consumer process</strong> (Process B):</p><ul><li>Reads <code>data->buffer</code> from shared memory, getting <code>0x7f8e42c00000</code></li><li>In Process B&rsquo;s memory map, this address either points to completely different memory or is invalid</li><li>When Process B tries to access <code>data->buffer[i]</code>, it either reads random data or crashes with a segmentation fault</li></ul></li></ol><h3 id=the-elegant-solution-embedding-the-array>The Elegant Solution: Embedding the Array<a hidden class=anchor aria-hidden=true href=#the-elegant-solution-embedding-the-array>#</a></h3><p>By embedding the buffer array directly within our shared structure:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>buffer</span><span class=p>[</span><span class=n>BUFFER_SIZE</span><span class=p>];</span>  <span class=c1>// The actual buffer, not a pointer
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>in</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>shared_data</span><span class=p>;</span>
</span></span></code></pre></div><p>We ensure that the data itself—not just a reference to it—is part of the shared memory. When the entire structure is mapped into both processes&rsquo; address spaces, they both have direct access to the same physical memory locations representing the buffer. This sidesteps the virtual addressing problem entirely.</p><h3 id=advanced-techniques-for-dynamic-memory-in-shared-contexts>Advanced Techniques for Dynamic Memory in Shared Contexts<a hidden class=anchor aria-hidden=true href=#advanced-techniques-for-dynamic-memory-in-shared-contexts>#</a></h3><p>For cases where more flexibility is needed (like a dynamically sized buffer), more advanced techniques exist but require careful implementation:</p><p><strong>Offset-based addressing:</strong> Instead of storing absolute pointers, store offsets from the beginning of the shared memory region. Both processes can then calculate the actual address in their own address space by adding the offset to the base address of their shared memory mapping.</p><p><strong>Memory pools:</strong> Allocate a large chunk of memory at the beginning of the shared region and implement a custom memory allocator that tracks allocations using offsets.</p><p><strong>Shared memory allocation:</strong> Some systems provide specialized allocation functions (like <code>shm_malloc</code>) that work with shared memory, but these are non-standard and less portable.</p><h3 id=the-principle-of-simplicity>The Principle of Simplicity<a hidden class=anchor aria-hidden=true href=#the-principle-of-simplicity>#</a></h3><p>For our producer-consumer implementation, embedding the buffer directly in the structure offers significant advantages:</p><ol><li><strong>Reliability:</strong> The code is less prone to subtle bugs that can occur with cross-process pointers.</li><li><strong>Simplicity:</strong> We avoid the need for complex offset calculations or custom allocators.</li><li><strong>Portability:</strong> The solution works across different operating systems and architectures that support POSIX shared memory.</li></ol><p>This design choice exemplifies an important principle in systems programming: sometimes the simplest approach is also the most robust. By avoiding pointers in our shared structure, we&rsquo;ve created a solution that is both easier to understand and less likely to fail in unexpected ways.</p><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://lcs-developer.com/tags/operating-systems/>Operating-Systems</a></li><li><a href=https://lcs-developer.com/tags/virtual-memory/>Virtual-Memory</a></li><li><a href=https://lcs-developer.com/tags/coding/>Coding</a></li></ul><nav class=paginav><a class=prev href=https://lcs-developer.com/posts/memory-pagination---a-comprehensive-guide/><span class=title>« Prev</span><br><span>Memory Pagination - A Comprehensive Guide</span>
</a><a class=next href=https://lcs-developer.com/posts/why-this-blog-and-how-i-manage-it/><span class=title>Next »</span><br><span>Why this blog and how I manage it</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Producer-Consumer Problem with POSIX Synchronization on x" href="https://x.com/intent/tweet/?text=Producer-Consumer%20Problem%20with%20POSIX%20Synchronization&amp;url=https%3a%2f%2flcs-developer.com%2fposts%2fproducer---consumer-posix%2f&amp;hashtags=Operating-Systems%2cVirtual-Memory%2cCoding"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Producer-Consumer Problem with POSIX Synchronization on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flcs-developer.com%2fposts%2fproducer---consumer-posix%2f&amp;title=Producer-Consumer%20Problem%20with%20POSIX%20Synchronization&amp;summary=Producer-Consumer%20Problem%20with%20POSIX%20Synchronization&amp;source=https%3a%2f%2flcs-developer.com%2fposts%2fproducer---consumer-posix%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Producer-Consumer Problem with POSIX Synchronization on reddit" href="https://reddit.com/submit?url=https%3a%2f%2flcs-developer.com%2fposts%2fproducer---consumer-posix%2f&title=Producer-Consumer%20Problem%20with%20POSIX%20Synchronization"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Producer-Consumer Problem with POSIX Synchronization on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flcs-developer.com%2fposts%2fproducer---consumer-posix%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Producer-Consumer Problem with POSIX Synchronization on whatsapp" href="https://api.whatsapp.com/send?text=Producer-Consumer%20Problem%20with%20POSIX%20Synchronization%20-%20https%3a%2f%2flcs-developer.com%2fposts%2fproducer---consumer-posix%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Producer-Consumer Problem with POSIX Synchronization on telegram" href="https://telegram.me/share/url?text=Producer-Consumer%20Problem%20with%20POSIX%20Synchronization&amp;url=https%3a%2f%2flcs-developer.com%2fposts%2fproducer---consumer-posix%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Producer-Consumer Problem with POSIX Synchronization on ycombinator" href="https://news.ycombinator.com/submitlink?t=Producer-Consumer%20Problem%20with%20POSIX%20Synchronization&u=https%3a%2f%2flcs-developer.com%2fposts%2fproducer---consumer-posix%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://lcs-developer.com/>LCS.Developer</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/XtremeXSPC/ rel=noopener target=_blank>Made with ❤️ by XtremeXSPC</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>