<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Produttore - Consumatore Posix | LCS.Developer</title>
<meta name=keywords content="Operating-Systems,Virtual-Memory,Coding"><meta name=description content="A simple solution to avoid race conditions."><meta name=author content="LCS.Dev"><link rel=canonical href=https://lcs-developer.it/posts/produttore---consumatore-posix/><meta name=google-site-verification content="CPQPKX3QPR"><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://lcs-developer.it/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lcs-developer.it/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lcs-developer.it/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://lcs-developer.it/favicon/apple-touch-icon.png><link rel=mask-icon href=https://lcs-developer.it/favicon/safari-pinned-tab.svg><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#ffffff"><link rel=alternate hreflang=en href=https://lcs-developer.it/posts/produttore---consumatore-posix/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.18/dist/katex.min.css integrity=sha384-veTAhWILPOotXm+kbR5uY7dRamYLJf58I7P+hJhjeuc7hsMAkJHTsPahAl0hBST0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.18/dist/katex.min.js integrity=sha384-v6mkHYHfY/4BWq54f7lQAdtIsoZZIByznQ3ZqN38OL4KCsrxo31SLlPiak7cj/Mg crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.18/dist/contrib/auto-render.min.js integrity=sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!0})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-CPQPKX3QPR"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-CPQPKX3QPR")}</script><meta property="og:url" content="https://lcs-developer.it/posts/produttore---consumatore-posix/"><meta property="og:site_name" content="LCS.Developer"><meta property="og:title" content="Produttore - Consumatore Posix"><meta property="og:description" content="A simple solution to avoid race conditions."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-19T00:36:58+00:00"><meta property="article:modified_time" content="2024-12-19T00:36:58+00:00"><meta property="article:tag" content="Operating-Systems"><meta property="article:tag" content="Virtual-Memory"><meta property="article:tag" content="Coding"><meta property="og:image" content="https://lcs-developer.it/images/LCS.Dev-Logo.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://lcs-developer.it/images/LCS.Dev-Logo.jpg"><meta name=twitter:title content="Produttore - Consumatore Posix"><meta name=twitter:description content="A simple solution to avoid race conditions."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://lcs-developer.it/posts/"},{"@type":"ListItem","position":2,"name":"Produttore - Consumatore Posix","item":"https://lcs-developer.it/posts/produttore---consumatore-posix/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Produttore - Consumatore Posix","name":"Produttore - Consumatore Posix","description":"A simple solution to avoid race conditions.","keywords":["Operating-Systems","Virtual-Memory","Coding"],"articleBody":"Soluzione al problema del produttore/consumatore con sincronizzazione Per risolvere il problema del produttore/consumatore evitando condizioni di gara (race condition), starvation o deadlock, utilizzeremo i semafori POSIX per sincronizzare l’accesso al buffer condiviso.\nStrumenti di sincronizzazione utilizzati:\nSemaforo empty: indica il numero di posti vuoti nel buffer. Semaforo full: indica il numero di elementi presenti nel buffer. Semaforo mutex: garantisce l’accesso esclusivo al buffer condiviso per evitare condizioni di gara. Implementazione del buffer condiviso:\nIl buffer sarà un buffer circolare implementato in memoria condivisa.\nCodice del Produttore (producer.c): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include #include #include #include #include #include #include #include #define BUFFER_SIZE 10 #define SHM_NAME \"/shm_buffer\" #define SEM_EMPTY_NAME \"/sem_empty\" #define SEM_FULL_NAME \"/sem_full\" #define SEM_MUTEX_NAME \"/sem_mutex\" typedef struct { int buffer[BUFFER_SIZE]; int in; } shared_data; int main() { /* Creazione della memoria condivisa */ int shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, 0666); ftruncate(shm_fd, sizeof(shared_data)); shared_data *data = mmap(0, sizeof(shared_data), PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0); /* Inizializzazione del buffer */ data-\u003ein = 0; /* Creazione dei semafori */ sem_t *empty = sem_open(SEM_EMPTY_NAME, O_CREAT, 0666, BUFFER_SIZE); sem_t *full = sem_open(SEM_FULL_NAME, O_CREAT, 0666, 0); sem_t *mutex = sem_open(SEM_MUTEX_NAME, O_CREAT, 0666, 1); int item = 0; while(1) { /* Produzione di un elemento */ item++; /* Attende che ci sia spazio nel buffer */ sem_wait(empty); /* Sezione critica: accesso al buffer condiviso */ sem_wait(mutex); data-\u003ebuffer[data-\u003ein % BUFFER_SIZE] = item; printf(\"Produttore ha prodotto: %d\\n\", item); data-\u003ein++; sem_post(mutex); /* Incrementa il contatore degli elementi nel buffer */ sem_post(full); sleep(1); /* Simula tempo di produzione */ } /* Chiusura e rimozione delle risorse */ sem_close(empty); sem_close(full); sem_close(mutex); munmap(data, sizeof(shared_data)); close(shm_fd); shm_unlink(SHM_NAME); sem_unlink(SEM_EMPTY_NAME); sem_unlink(SEM_FULL_NAME); sem_unlink(SEM_MUTEX_NAME); return 0; } Codice del Consumatore (consumer.c): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include #include #include #include #include #include #include #define BUFFER_SIZE 10 #define SHM_NAME \"/shm_buffer\" #define SEM_EMPTY_NAME \"/sem_empty\" #define SEM_FULL_NAME \"/sem_full\" #define SEM_MUTEX_NAME \"/sem_mutex\" typedef struct { int buffer[BUFFER_SIZE]; int out; } shared_data; int main() { /* Apertura della memoria condivisa */ int shm_fd = shm_open(SHM_NAME, O_RDWR, 0666); shared_data *data = mmap(0, sizeof(shared_data), PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0); /* Apertura dei semafori */ sem_t *empty = sem_open(SEM_EMPTY_NAME, 0); sem_t *full = sem_open(SEM_FULL_NAME, 0); sem_t *mutex = sem_open(SEM_MUTEX_NAME, 0); data-\u003eout = 0; while(1) { /* Attende che ci sia almeno un elemento nel buffer */ sem_wait(full); /* Sezione critica: accesso al buffer condiviso */ sem_wait(mutex); int item = data-\u003ebuffer[data-\u003eout % BUFFER_SIZE]; printf(\"Consumatore ha consumato: %d\\n\", item); data-\u003eout++; sem_post(mutex); /* Incrementa il contatore dei posti vuoti nel buffer */ sem_post(empty); sleep(2); /* Simula tempo di consumo */ } /* Chiusura e rimozione delle risorse */ sem_close(empty); sem_close(full); sem_close(mutex); munmap(data, sizeof(shared_data)); close(shm_fd); return 0; } Spiegazione dettagliata: 1. Semafori utilizzati:\nempty: inizializzato a BUFFER_SIZE, rappresenta il numero di posti vuoti nel buffer. Il produttore esegue sem_wait(empty) prima di produrre un elemento, decrementando il contatore. Se il buffer è pieno (empty == 0), il produttore si blocca finché il consumatore non consuma un elemento.\nfull: inizializzato a 0, rappresenta il numero di elementi presenti nel buffer. Il consumatore esegue sem_wait(full) prima di consumare un elemento. Se il buffer è vuoto (full == 0), il consumatore si blocca finché il produttore non produce un nuovo elemento.\nmutex: inizializzato a 1, garantisce l’accesso esclusivo al buffer condiviso. Entrambi i processi eseguono sem_wait(mutex) prima di accedere al buffer e sem_post(mutex) dopo aver terminato.\n2. Buffer circolare:\nIl buffer è implementato come un array di dimensione BUFFER_SIZE. Gli indici in e out gestiscono rispettivamente l’inserimento e la rimozione degli elementi nel buffer in modo circolare. 3. Prevenzione di condizioni di gara:\nL’uso del semaforo mutex assicura che solo un processo alla volta possa accedere al buffer condiviso, prevenendo condizioni di gara. 4. Prevenzione di deadlock:\nL’ordine di acquisizione e rilascio dei semafori è consistente in entrambi i processi. Nessun processo mantiene il possesso di un semaforo mentre attende un altro, evitando così un deadlock. 5. Prevenzione di starvation:\nI semafori vengono utilizzati in modo equo, e ogni processo attende il suo turno, evitando che uno dei due rimanga in attesa indefinitamente. Note aggiuntive: Compilazione: per compilare i programmi, utilizzare: gcc -o producer producer.c -lrt -pthread gcc -o consumer consumer.c -lrt -pthread Esecuzione: eseguire prima il produttore e poi il consumatore in due terminali separati: ./producer ./consumer Pulizia delle risorse: assicurarsi che, in caso di interruzione dei programmi, le risorse (memoria condivisa e semafori) vengano rimosse utilizzando shm_unlink e sem_unlink. Con questa implementazione, il problema del produttore/consumatore viene risolto utilizzando i classici strumenti di sincronizzazione per evitare condizioni di gara, starvation o deadlock.\nSpiegazione dettagliata delle istruzioni nel codice del produttore Vediamo passo per passo le istruzioni chiave nel codice del produttore, focalizzandoci sulla struttura shared_data e sul motivo per cui è definita in un certo modo.\nDefinizione della struttura shared_data 1 2 3 4 typedef struct { int buffer[BUFFER_SIZE]; int in; } shared_data; Spiegazione:\nint buffer[BUFFER_SIZE];: dichiara un array di interi di dimensione BUFFER_SIZE all’interno della struttura. Questo array rappresenta il buffer circolare condiviso tra il produttore e il consumatore.\nint in;: è un indice che il produttore utilizza per tenere traccia della posizione corrente in cui inserire il prossimo elemento nel buffer.\nLa struttura shared_data viene mappata interamente nella memoria condivisa, garantendo che sia il buffer che l’indice in siano accessibili e consistenti tra il produttore e il consumatore.\nCreazione e mappatura della memoria condivisa 1 2 3 4 /* Creazione della memoria condivisa */ int shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, 0666); ftruncate(shm_fd, sizeof(shared_data)); shared_data *data = mmap(0, sizeof(shared_data), PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0); Spiegazione:\nshm_open: crea un nuovo oggetto di memoria condivisa o apre uno esistente con il nome SHM_NAME. ftruncate: imposta la dimensione dell’oggetto di memoria condivisa a sizeof(shared_data). mmap: mappa l’oggetto di memoria condivisa nel proprio spazio di indirizzamento, restituendo un puntatore a shared_data. Con questa mappatura, sia il produttore che il consumatore accedono alla stessa istanza di shared_data in memoria condivisa.\nInizializzazione dei semafori 1 2 3 4 /* Creazione dei semafori */ sem_t *empty = sem_open(SEM_EMPTY_NAME, O_CREAT, 0666, BUFFER_SIZE); sem_t *full = sem_open(SEM_FULL_NAME, O_CREAT, 0666, 0); sem_t *mutex = sem_open(SEM_MUTEX_NAME, O_CREAT, 0666, 1); Spiegazione:\nempty: inizializzato a BUFFER_SIZE, rappresenta il numero di posti vuoti nel buffer. full: inizializzato a 0, rappresenta il numero di elementi presenti nel buffer. mutex: inizializzato a 1, garantisce l’accesso esclusivo al buffer condiviso. Ciclo di produzione 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 while(1) { /* Produzione di un elemento */ item++; /* Attende che ci sia spazio nel buffer */ sem_wait(empty); /* Sezione critica: accesso al buffer condiviso */ sem_wait(mutex); data-\u003ebuffer[data-\u003ein % BUFFER_SIZE] = item; printf(\"Produttore ha prodotto: %d\\n\", item); data-\u003ein++; sem_post(mutex); /* Incrementa il contatore degli elementi nel buffer */ sem_post(full); sleep(1); /* Simula tempo di produzione */ } Spiegazione:\nsem_wait(empty);: il produttore attende finché c’è almeno un posto vuoto nel buffer.\nSezione critica:\nsem_wait(mutex);: acquisisce il semaforo mutex per garantire accesso esclusivo al buffer. Inserimento dell’elemento: l’elemento item viene inserito nella posizione data-\u003ein % BUFFER_SIZE del buffer. Aggiornamento dell’indice in: viene incrementato per puntare alla prossima posizione libera. sem_post(mutex);: rilascia il semaforo mutex. sem_post(full);: incrementa il semaforo full per indicare che c’è un nuovo elemento nel buffer.\nMotivo per cui non è consigliabile usare int* buffer; nella struttura shared_data Definizione alternativa:\n1 2 3 4 typedef struct { int* buffer; int in; } shared_data; Motivazione:\nProblema dei puntatori in memoria condivisa:\nI puntatori memorizzano indirizzi di memoria relativi allo spazio di indirizzamento del processo che li ha creati. Se si utilizza un puntatore all’interno della memoria condivisa, l’indirizzo a cui punta è valido solo nel processo che ha assegnato quel puntatore. Conseguenze:\nInconsistenza: il puntatore buffer assegnato nel produttore non sarà valido nel consumatore, poiché i due processi hanno spazi di indirizzamento separati. Accesso non valido: il consumatore tenterà di accedere a un indirizzo di memoria non valido o errato, causando comportamenti indefiniti o crash. Soluzione con array interno:\nDefinendo buffer come un array all’interno della struttura, l’intero buffer viene memorizzato nella memoria condivisa. Sia il produttore che il consumatore accedono allo stesso array in memoria condivisa, senza problemi di indirizzamento. Esempio del problema con int* buffer;:\nAllocazione nel produttore:\nSe nel produttore si fa data-\u003ebuffer = malloc(BUFFER_SIZE * sizeof(int));, la memoria allocata da malloc non è condivisa, ma locale al processo. Accesso nel consumatore:\nIl consumatore accederà a data-\u003ebuffer, che contiene un indirizzo di memoria valido solo nel produttore, portando a errori. Come utilizzare un puntatore in memoria condivisa (non consigliato in questo caso) Se si desidera utilizzare un puntatore all’interno di una struttura in memoria condivisa, è necessario assicurarsi che:\nAllocazione nella memoria condivisa:\nLa memoria a cui punta il puntatore deve essere allocata all’interno della stessa memoria condivisa. Gestione degli offset:\nInvece di utilizzare indirizzi assoluti, si possono utilizzare offset relativi all’inizio della memoria condivisa. Implementazione complessa e soggetta a errori:\nRichiede una gestione manuale degli indirizzi e degli offset. Aumenta la complessità del codice e la possibilità di introdurre bug. Perché usare un array invece di un puntatore:\nSemplicità: l’array è direttamente incorporato nella struttura shared_data, che è interamente mappata nella memoria condivisa. Sicurezza: evita problemi di indirizzamento e accesso non valido alla memoria. Portabilità: il codice è più portabile e meno soggetto a errori legati all’architettura o al sistema operativo. Raccomandazione:\nEvitare l’uso di puntatori in strutture condivise tra processi, a meno che non sia strettamente necessario e si abbia una solida comprensione della gestione della memoria tra processi.\nUtilizzare strutture di dati che possono essere completamente mappate nella memoria condivisa, come array o strutture senza puntatori interni.\nNon è consigliabile utilizzare la struttura proposta con int* buffer; perché i puntatori non sono validi attraverso i confini dei processi quando si utilizza la memoria condivisa. Definire buffer come un array all’interno della struttura shared_data garantisce che l’intero buffer sia effettivamente condiviso tra il produttore e il consumatore, evitando problemi di indirizzamento e garantendo la corretta sincronizzazione e comunicazione tra i processi.\n","wordCount":"1774","inLanguage":"en","image":"https://lcs-developer.it/images/LCS.Dev-Logo.jpg","datePublished":"2024-12-19T00:36:58.458443Z","dateModified":"2024-12-19T00:36:58.458443Z","author":{"@type":"Person","name":"LCS.Dev"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lcs-developer.it/posts/produttore---consumatore-posix/"},"publisher":{"@type":"Organization","name":"LCS.Developer","logo":{"@type":"ImageObject","url":"https://lcs-developer.it/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://lcs-developer.it/ accesskey=h title="LCS.Dev - CS Topics (Alt + H)"><img src=https://lcs-developer.it/%F0%9F%91%A8%E2%80%8D%F0%9F%92%BB alt aria-label=logo height=35>LCS.Dev - CS Topics</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://lcs-developer.it/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://lcs-developer.it/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://lcs-developer.it/about/ title=About><span>About</span></a></li><li><a href=https://lcs-developer.it/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://lcs-developer.it/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://lcs-developer.it/>Home</a>&nbsp;»&nbsp;<a href=https://lcs-developer.it/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Produttore - Consumatore Posix</h1><div class=post-description>A simple solution to avoid race conditions.</div><div class=post-meta><span title='2024-12-19 00:36:58.458443 +0000 UTC'>December 19, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1774 words&nbsp;·&nbsp;LCS.Dev&nbsp;|&nbsp;<a href=https://github.com/XtremeXSPC/LCS.Dev-Blog/tree/hostinger//posts/Produttore%20-%20Consumatore%20POSIX.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#soluzione-al-problema-del-produttoreconsumatore-con-sincronizzazione>Soluzione al problema del produttore/consumatore con sincronizzazione</a><ul><li></li><li><a href=#spiegazione-dettagliata-delle-istruzioni-nel-codice-del-produttore>Spiegazione dettagliata delle istruzioni nel codice del produttore</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=soluzione-al-problema-del-produttoreconsumatore-con-sincronizzazione>Soluzione al problema del produttore/consumatore con sincronizzazione<a hidden class=anchor aria-hidden=true href=#soluzione-al-problema-del-produttoreconsumatore-con-sincronizzazione>#</a></h2><p>Per risolvere il problema del produttore/consumatore evitando condizioni di gara (<em>race condition</em>), <em>starvation</em> o <em>deadlock</em>, utilizzeremo i semafori POSIX per sincronizzare l&rsquo;accesso al buffer condiviso.</p><p><strong>Strumenti di sincronizzazione utilizzati:</strong></p><ul><li><strong>Semaforo <code>empty</code></strong>: indica il numero di posti vuoti nel buffer.</li><li><strong>Semaforo <code>full</code></strong>: indica il numero di elementi presenti nel buffer.</li><li><strong>Semaforo <code>mutex</code></strong>: garantisce l&rsquo;accesso esclusivo al buffer condiviso per evitare condizioni di gara.</li></ul><p><strong>Implementazione del buffer condiviso:</strong></p><p>Il buffer sarà un buffer circolare implementato in memoria condivisa.</p><hr><h4 id=codice-del-produttore-producerc>Codice del Produttore (<code>producer.c</code>):<a hidden class=anchor aria-hidden=true href=#codice-del-produttore-producerc>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;           </span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/mman.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;semaphore.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/stat.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define BUFFER_SIZE 10
</span></span></span><span class=line><span class=cl><span class=cp>#define SHM_NAME &#34;/shm_buffer&#34;
</span></span></span><span class=line><span class=cl><span class=cp>#define SEM_EMPTY_NAME &#34;/sem_empty&#34;
</span></span></span><span class=line><span class=cl><span class=cp>#define SEM_FULL_NAME &#34;/sem_full&#34;
</span></span></span><span class=line><span class=cl><span class=cp>#define SEM_MUTEX_NAME &#34;/sem_mutex&#34;
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>buffer</span><span class=p>[</span><span class=n>BUFFER_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>in</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>shared_data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Creazione della memoria condivisa */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>shm_fd</span> <span class=o>=</span> <span class=nf>shm_open</span><span class=p>(</span><span class=n>SHM_NAME</span><span class=p>,</span> <span class=n>O_CREAT</span> <span class=o>|</span> <span class=n>O_RDWR</span><span class=p>,</span> <span class=mo>0666</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>ftruncate</span><span class=p>(</span><span class=n>shm_fd</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>shared_data</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>shared_data</span> <span class=o>*</span><span class=n>data</span> <span class=o>=</span> <span class=nf>mmap</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>shared_data</span><span class=p>),</span> <span class=n>PROT_READ</span> <span class=o>|</span> <span class=n>PROT_WRITE</span><span class=p>,</span> <span class=n>MAP_SHARED</span><span class=p>,</span> <span class=n>shm_fd</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/* Inizializzazione del buffer */</span>
</span></span><span class=line><span class=cl>    <span class=n>data</span><span class=o>-&gt;</span><span class=n>in</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/* Creazione dei semafori */</span>
</span></span><span class=line><span class=cl>    <span class=kt>sem_t</span> <span class=o>*</span><span class=n>empty</span> <span class=o>=</span> <span class=nf>sem_open</span><span class=p>(</span><span class=n>SEM_EMPTY_NAME</span><span class=p>,</span> <span class=n>O_CREAT</span><span class=p>,</span> <span class=mo>0666</span><span class=p>,</span> <span class=n>BUFFER_SIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>sem_t</span> <span class=o>*</span><span class=n>full</span> <span class=o>=</span> <span class=nf>sem_open</span><span class=p>(</span><span class=n>SEM_FULL_NAME</span><span class=p>,</span> <span class=n>O_CREAT</span><span class=p>,</span> <span class=mo>0666</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>sem_t</span> <span class=o>*</span><span class=n>mutex</span> <span class=o>=</span> <span class=nf>sem_open</span><span class=p>(</span><span class=n>SEM_MUTEX_NAME</span><span class=p>,</span> <span class=n>O_CREAT</span><span class=p>,</span> <span class=mo>0666</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>item</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Produzione di un elemento */</span>
</span></span><span class=line><span class=cl>        <span class=n>item</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=cm>/* Attende che ci sia spazio nel buffer */</span>
</span></span><span class=line><span class=cl>        <span class=nf>sem_wait</span><span class=p>(</span><span class=n>empty</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=cm>/* Sezione critica: accesso al buffer condiviso */</span>
</span></span><span class=line><span class=cl>        <span class=nf>sem_wait</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>data</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=p>[</span><span class=n>data</span><span class=o>-&gt;</span><span class=n>in</span> <span class=o>%</span> <span class=n>BUFFER_SIZE</span><span class=p>]</span> <span class=o>=</span> <span class=n>item</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Produttore ha prodotto: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>item</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>data</span><span class=o>-&gt;</span><span class=n>in</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>sem_post</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=cm>/* Incrementa il contatore degli elementi nel buffer */</span>
</span></span><span class=line><span class=cl>        <span class=nf>sem_post</span><span class=p>(</span><span class=n>full</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=nf>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span> <span class=cm>/* Simula tempo di produzione */</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/* Chiusura e rimozione delle risorse */</span>
</span></span><span class=line><span class=cl>    <span class=nf>sem_close</span><span class=p>(</span><span class=n>empty</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>sem_close</span><span class=p>(</span><span class=n>full</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>sem_close</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>munmap</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>shared_data</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=nf>close</span><span class=p>(</span><span class=n>shm_fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>shm_unlink</span><span class=p>(</span><span class=n>SHM_NAME</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>sem_unlink</span><span class=p>(</span><span class=n>SEM_EMPTY_NAME</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>sem_unlink</span><span class=p>(</span><span class=n>SEM_FULL_NAME</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>sem_unlink</span><span class=p>(</span><span class=n>SEM_MUTEX_NAME</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><hr><h4 id=codice-del-consumatore-consumerc>Codice del Consumatore (<code>consumer.c</code>):<a hidden class=anchor aria-hidden=true href=#codice-del-consumatore-consumerc>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;           </span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/mman.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;semaphore.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/stat.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define BUFFER_SIZE 10
</span></span></span><span class=line><span class=cl><span class=cp>#define SHM_NAME &#34;/shm_buffer&#34;
</span></span></span><span class=line><span class=cl><span class=cp>#define SEM_EMPTY_NAME &#34;/sem_empty&#34;
</span></span></span><span class=line><span class=cl><span class=cp>#define SEM_FULL_NAME &#34;/sem_full&#34;
</span></span></span><span class=line><span class=cl><span class=cp>#define SEM_MUTEX_NAME &#34;/sem_mutex&#34;
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>buffer</span><span class=p>[</span><span class=n>BUFFER_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>out</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>shared_data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Apertura della memoria condivisa */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>shm_fd</span> <span class=o>=</span> <span class=nf>shm_open</span><span class=p>(</span><span class=n>SHM_NAME</span><span class=p>,</span> <span class=n>O_RDWR</span><span class=p>,</span> <span class=mo>0666</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>shared_data</span> <span class=o>*</span><span class=n>data</span> <span class=o>=</span> <span class=nf>mmap</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>shared_data</span><span class=p>),</span> <span class=n>PROT_READ</span> <span class=o>|</span> <span class=n>PROT_WRITE</span><span class=p>,</span> <span class=n>MAP_SHARED</span><span class=p>,</span> <span class=n>shm_fd</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/* Apertura dei semafori */</span>
</span></span><span class=line><span class=cl>    <span class=kt>sem_t</span> <span class=o>*</span><span class=n>empty</span> <span class=o>=</span> <span class=nf>sem_open</span><span class=p>(</span><span class=n>SEM_EMPTY_NAME</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>sem_t</span> <span class=o>*</span><span class=n>full</span> <span class=o>=</span> <span class=nf>sem_open</span><span class=p>(</span><span class=n>SEM_FULL_NAME</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>sem_t</span> <span class=o>*</span><span class=n>mutex</span> <span class=o>=</span> <span class=nf>sem_open</span><span class=p>(</span><span class=n>SEM_MUTEX_NAME</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>data</span><span class=o>-&gt;</span><span class=n>out</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Attende che ci sia almeno un elemento nel buffer */</span>
</span></span><span class=line><span class=cl>        <span class=nf>sem_wait</span><span class=p>(</span><span class=n>full</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=cm>/* Sezione critica: accesso al buffer condiviso */</span>
</span></span><span class=line><span class=cl>        <span class=nf>sem_wait</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>item</span> <span class=o>=</span> <span class=n>data</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=p>[</span><span class=n>data</span><span class=o>-&gt;</span><span class=n>out</span> <span class=o>%</span> <span class=n>BUFFER_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Consumatore ha consumato: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>item</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>data</span><span class=o>-&gt;</span><span class=n>out</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>sem_post</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=cm>/* Incrementa il contatore dei posti vuoti nel buffer */</span>
</span></span><span class=line><span class=cl>        <span class=nf>sem_post</span><span class=p>(</span><span class=n>empty</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=nf>sleep</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span> <span class=cm>/* Simula tempo di consumo */</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/* Chiusura e rimozione delle risorse */</span>
</span></span><span class=line><span class=cl>    <span class=nf>sem_close</span><span class=p>(</span><span class=n>empty</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>sem_close</span><span class=p>(</span><span class=n>full</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>sem_close</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>munmap</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>shared_data</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=nf>close</span><span class=p>(</span><span class=n>shm_fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><hr><h4 id=spiegazione-dettagliata>Spiegazione dettagliata:<a hidden class=anchor aria-hidden=true href=#spiegazione-dettagliata>#</a></h4><p><strong>1. Semafori utilizzati:</strong></p><ul><li><p><strong><code>empty</code></strong>: inizializzato a <code>BUFFER_SIZE</code>, rappresenta il numero di posti vuoti nel buffer. Il produttore esegue <code>sem_wait(empty)</code> prima di produrre un elemento, decrementando il contatore. Se il buffer è pieno (<code>empty == 0</code>), il produttore si blocca finché il consumatore non consuma un elemento.</p></li><li><p><strong><code>full</code></strong>: inizializzato a <code>0</code>, rappresenta il numero di elementi presenti nel buffer. Il consumatore esegue <code>sem_wait(full)</code> prima di consumare un elemento. Se il buffer è vuoto (<code>full == 0</code>), il consumatore si blocca finché il produttore non produce un nuovo elemento.</p></li><li><p><strong><code>mutex</code></strong>: inizializzato a <code>1</code>, garantisce l&rsquo;accesso esclusivo al buffer condiviso. Entrambi i processi eseguono <code>sem_wait(mutex)</code> prima di accedere al buffer e <code>sem_post(mutex)</code> dopo aver terminato.</p></li></ul><p><strong>2. Buffer circolare:</strong></p><ul><li>Il buffer è implementato come un array di dimensione <code>BUFFER_SIZE</code>.</li><li>Gli indici <code>in</code> e <code>out</code> gestiscono rispettivamente l&rsquo;inserimento e la rimozione degli elementi nel buffer in modo circolare.</li></ul><p><strong>3. Prevenzione di condizioni di gara:</strong></p><ul><li>L&rsquo;uso del semaforo <code>mutex</code> assicura che solo un processo alla volta possa accedere al buffer condiviso, prevenendo condizioni di gara.</li></ul><p><strong>4. Prevenzione di deadlock:</strong></p><ul><li>L&rsquo;ordine di acquisizione e rilascio dei semafori è consistente in entrambi i processi.</li><li>Nessun processo mantiene il possesso di un semaforo mentre attende un altro, evitando così un deadlock.</li></ul><p><strong>5. Prevenzione di starvation:</strong></p><ul><li>I semafori vengono utilizzati in modo equo, e ogni processo attende il suo turno, evitando che uno dei due rimanga in attesa indefinitamente.</li></ul><hr><h4 id=note-aggiuntive>Note aggiuntive:<a hidden class=anchor aria-hidden=true href=#note-aggiuntive>#</a></h4><ul><li><strong>Compilazione</strong>: per compilare i programmi, utilizzare:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>  gcc -o producer producer.c -lrt -pthread
</span></span><span class=line><span class=cl>  gcc -o consumer consumer.c -lrt -pthread
</span></span></code></pre></div><ul><li><strong>Esecuzione</strong>: eseguire prima il produttore e poi il consumatore in due terminali separati:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>  ./producer
</span></span><span class=line><span class=cl>  ./consumer
</span></span></code></pre></div><ul><li><strong>Pulizia delle risorse</strong>: assicurarsi che, in caso di interruzione dei programmi, le risorse (memoria condivisa e semafori) vengano rimosse utilizzando <code>shm_unlink</code> e <code>sem_unlink</code>.</li></ul><hr><p>Con questa implementazione, il problema del produttore/consumatore viene risolto utilizzando i classici strumenti di sincronizzazione per evitare condizioni di gara, <em>starvation</em> o <em>deadlock</em>.</p><hr><h3 id=spiegazione-dettagliata-delle-istruzioni-nel-codice-del-produttore>Spiegazione dettagliata delle istruzioni nel codice del produttore<a hidden class=anchor aria-hidden=true href=#spiegazione-dettagliata-delle-istruzioni-nel-codice-del-produttore>#</a></h3><p>Vediamo passo per passo le istruzioni chiave nel codice del produttore, focalizzandoci sulla struttura <code>shared_data</code> e sul motivo per cui è definita in un certo modo.</p><hr><h4 id=definizione-della-struttura-shared_data>Definizione della struttura <code>shared_data</code><a hidden class=anchor aria-hidden=true href=#definizione-della-struttura-shared_data>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>buffer</span><span class=p>[</span><span class=n>BUFFER_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>in</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>shared_data</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>Spiegazione:</strong></p><ul><li><p><strong><code>int buffer[BUFFER_SIZE];</code></strong>: dichiara un array di interi di dimensione <code>BUFFER_SIZE</code> all&rsquo;interno della struttura. Questo array rappresenta il buffer circolare condiviso tra il produttore e il consumatore.</p></li><li><p><strong><code>int in;</code></strong>: è un indice che il produttore utilizza per tenere traccia della posizione corrente in cui inserire il prossimo elemento nel buffer.</p></li></ul><p>La struttura <code>shared_data</code> viene mappata interamente nella memoria condivisa, garantendo che sia il buffer che l&rsquo;indice <code>in</code> siano accessibili e consistenti tra il produttore e il consumatore.</p><hr><h4 id=creazione-e-mappatura-della-memoria-condivisa>Creazione e mappatura della memoria condivisa<a hidden class=anchor aria-hidden=true href=#creazione-e-mappatura-della-memoria-condivisa>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* Creazione della memoria condivisa */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>shm_fd</span> <span class=o>=</span> <span class=nf>shm_open</span><span class=p>(</span><span class=n>SHM_NAME</span><span class=p>,</span> <span class=n>O_CREAT</span> <span class=o>|</span> <span class=n>O_RDWR</span><span class=p>,</span> <span class=mo>0666</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>ftruncate</span><span class=p>(</span><span class=n>shm_fd</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>shared_data</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=n>shared_data</span> <span class=o>*</span><span class=n>data</span> <span class=o>=</span> <span class=nf>mmap</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>shared_data</span><span class=p>),</span> <span class=n>PROT_READ</span> <span class=o>|</span> <span class=n>PROT_WRITE</span><span class=p>,</span> <span class=n>MAP_SHARED</span><span class=p>,</span> <span class=n>shm_fd</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>Spiegazione:</strong></p><ul><li><strong><code>shm_open</code></strong>: crea un nuovo oggetto di memoria condivisa o apre uno esistente con il nome <code>SHM_NAME</code>.</li><li><strong><code>ftruncate</code></strong>: imposta la dimensione dell&rsquo;oggetto di memoria condivisa a <code>sizeof(shared_data)</code>.</li><li><strong><code>mmap</code></strong>: mappa l&rsquo;oggetto di memoria condivisa nel proprio spazio di indirizzamento, restituendo un puntatore a <code>shared_data</code>.</li></ul><p>Con questa mappatura, sia il produttore che il consumatore accedono alla stessa istanza di <code>shared_data</code> in memoria condivisa.</p><hr><h4 id=inizializzazione-dei-semafori>Inizializzazione dei semafori<a hidden class=anchor aria-hidden=true href=#inizializzazione-dei-semafori>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* Creazione dei semafori */</span>
</span></span><span class=line><span class=cl><span class=kt>sem_t</span> <span class=o>*</span><span class=n>empty</span> <span class=o>=</span> <span class=nf>sem_open</span><span class=p>(</span><span class=n>SEM_EMPTY_NAME</span><span class=p>,</span> <span class=n>O_CREAT</span><span class=p>,</span> <span class=mo>0666</span><span class=p>,</span> <span class=n>BUFFER_SIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>sem_t</span> <span class=o>*</span><span class=n>full</span> <span class=o>=</span> <span class=nf>sem_open</span><span class=p>(</span><span class=n>SEM_FULL_NAME</span><span class=p>,</span> <span class=n>O_CREAT</span><span class=p>,</span> <span class=mo>0666</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>sem_t</span> <span class=o>*</span><span class=n>mutex</span> <span class=o>=</span> <span class=nf>sem_open</span><span class=p>(</span><span class=n>SEM_MUTEX_NAME</span><span class=p>,</span> <span class=n>O_CREAT</span><span class=p>,</span> <span class=mo>0666</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>Spiegazione:</strong></p><ul><li><strong><code>empty</code></strong>: inizializzato a <code>BUFFER_SIZE</code>, rappresenta il numero di posti vuoti nel buffer.</li><li><strong><code>full</code></strong>: inizializzato a <code>0</code>, rappresenta il numero di elementi presenti nel buffer.</li><li><strong><code>mutex</code></strong>: inizializzato a <code>1</code>, garantisce l&rsquo;accesso esclusivo al buffer condiviso.</li></ul><hr><h4 id=ciclo-di-produzione>Ciclo di produzione<a hidden class=anchor aria-hidden=true href=#ciclo-di-produzione>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>while</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Produzione di un elemento */</span>
</span></span><span class=line><span class=cl>    <span class=n>item</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/* Attende che ci sia spazio nel buffer */</span>
</span></span><span class=line><span class=cl>    <span class=nf>sem_wait</span><span class=p>(</span><span class=n>empty</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/* Sezione critica: accesso al buffer condiviso */</span>
</span></span><span class=line><span class=cl>    <span class=nf>sem_wait</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>data</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=p>[</span><span class=n>data</span><span class=o>-&gt;</span><span class=n>in</span> <span class=o>%</span> <span class=n>BUFFER_SIZE</span><span class=p>]</span> <span class=o>=</span> <span class=n>item</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Produttore ha prodotto: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>item</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>data</span><span class=o>-&gt;</span><span class=n>in</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>sem_post</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/* Incrementa il contatore degli elementi nel buffer */</span>
</span></span><span class=line><span class=cl>    <span class=nf>sem_post</span><span class=p>(</span><span class=n>full</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nf>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span> <span class=cm>/* Simula tempo di produzione */</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>Spiegazione:</strong></p><ul><li><p><strong><code>sem_wait(empty);</code></strong>: il produttore attende finché c&rsquo;è almeno un posto vuoto nel buffer.</p></li><li><p><strong>Sezione critica</strong>:</p><ul><li><strong><code>sem_wait(mutex);</code></strong>: acquisisce il semaforo <code>mutex</code> per garantire accesso esclusivo al buffer.</li><li><strong>Inserimento dell&rsquo;elemento</strong>: l&rsquo;elemento <code>item</code> viene inserito nella posizione <code>data->in % BUFFER_SIZE</code> del buffer.</li><li><strong>Aggiornamento dell&rsquo;indice <code>in</code></strong>: viene incrementato per puntare alla prossima posizione libera.</li><li><strong><code>sem_post(mutex);</code></strong>: rilascia il semaforo <code>mutex</code>.</li></ul></li><li><p><strong><code>sem_post(full);</code></strong>: incrementa il semaforo <code>full</code> per indicare che c&rsquo;è un nuovo elemento nel buffer.</p></li></ul><hr><h4 id=motivo-per-cui-non-è-consigliabile-usare-int-buffer-nella-struttura-shared_data>Motivo per cui non è consigliabile usare <code>int* buffer;</code> nella struttura <code>shared_data</code><a hidden class=anchor aria-hidden=true href=#motivo-per-cui-non-è-consigliabile-usare-int-buffer-nella-struttura-shared_data>#</a></h4><p><strong>Definizione alternativa:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span><span class=o>*</span> <span class=n>buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>in</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>shared_data</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>Motivazione:</strong></p><ul><li><p><strong>Problema dei puntatori in memoria condivisa</strong>:</p><ul><li>I puntatori memorizzano indirizzi di memoria relativi allo spazio di indirizzamento del processo che li ha creati.</li><li>Se si utilizza un puntatore all&rsquo;interno della memoria condivisa, l&rsquo;indirizzo a cui punta è valido solo nel processo che ha assegnato quel puntatore.</li></ul></li><li><p><strong>Conseguenze</strong>:</p><ul><li><strong>Inconsistenza</strong>: il puntatore <code>buffer</code> assegnato nel produttore non sarà valido nel consumatore, poiché i due processi hanno spazi di indirizzamento separati.</li><li><strong>Accesso non valido</strong>: il consumatore tenterà di accedere a un indirizzo di memoria non valido o errato, causando comportamenti indefiniti o crash.</li></ul></li><li><p><strong>Soluzione con array interno</strong>:</p><ul><li>Definendo <code>buffer</code> come un array all&rsquo;interno della struttura, l&rsquo;intero buffer viene memorizzato nella memoria condivisa.</li><li>Sia il produttore che il consumatore accedono allo stesso array in memoria condivisa, senza problemi di indirizzamento.</li></ul></li></ul><p><strong>Esempio del problema con <code>int* buffer;</code>:</strong></p><ol><li><p><strong>Allocazione nel produttore</strong>:</p><ul><li>Se nel produttore si fa <code>data->buffer = malloc(BUFFER_SIZE * sizeof(int));</code>, la memoria allocata da <code>malloc</code> non è condivisa, ma locale al processo.</li></ul></li><li><p><strong>Accesso nel consumatore</strong>:</p><ul><li>Il consumatore accederà a <code>data->buffer</code>, che contiene un indirizzo di memoria valido solo nel produttore, portando a errori.</li></ul></li></ol><hr><h4 id=come-utilizzare-un-puntatore-in-memoria-condivisa-non-consigliato-in-questo-caso>Come utilizzare un puntatore in memoria condivisa (non consigliato in questo caso)<a hidden class=anchor aria-hidden=true href=#come-utilizzare-un-puntatore-in-memoria-condivisa-non-consigliato-in-questo-caso>#</a></h4><p>Se si desidera utilizzare un puntatore all&rsquo;interno di una struttura in memoria condivisa, è necessario assicurarsi che:</p><ul><li><p><strong>Allocazione nella memoria condivisa</strong>:</p><ul><li>La memoria a cui punta il puntatore deve essere allocata all&rsquo;interno della stessa memoria condivisa.</li></ul></li><li><p><strong>Gestione degli offset</strong>:</p><ul><li>Invece di utilizzare indirizzi assoluti, si possono utilizzare offset relativi all&rsquo;inizio della memoria condivisa.</li></ul></li></ul><p><strong>Implementazione complessa e soggetta a errori</strong>:</p><ul><li>Richiede una gestione manuale degli indirizzi e degli offset.</li><li>Aumenta la complessità del codice e la possibilità di introdurre bug.</li></ul><p><strong>Perché usare un array invece di un puntatore:</strong></p><ul><li><strong>Semplicità</strong>: l&rsquo;array è direttamente incorporato nella struttura <code>shared_data</code>, che è interamente mappata nella memoria condivisa.</li><li><strong>Sicurezza</strong>: evita problemi di indirizzamento e accesso non valido alla memoria.</li><li><strong>Portabilità</strong>: il codice è più portabile e meno soggetto a errori legati all&rsquo;architettura o al sistema operativo.</li></ul><p><strong>Raccomandazione:</strong></p><ul><li><p><strong>Evitare l&rsquo;uso di puntatori in strutture condivise tra processi</strong>, a meno che non sia strettamente necessario e si abbia una solida comprensione della gestione della memoria tra processi.</p></li><li><p><strong>Utilizzare strutture di dati che possono essere completamente mappate nella memoria condivisa</strong>, come array o strutture senza puntatori interni.</p></li></ul><hr><p>Non è consigliabile utilizzare la struttura proposta con <code>int* buffer;</code> perché i puntatori non sono validi attraverso i confini dei processi quando si utilizza la memoria condivisa. Definire <code>buffer</code> come un array all&rsquo;interno della struttura <code>shared_data</code> garantisce che l&rsquo;intero buffer sia effettivamente condiviso tra il produttore e il consumatore, evitando problemi di indirizzamento e garantendo la corretta sincronizzazione e comunicazione tra i processi.</p><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://lcs-developer.it/tags/operating-systems/>Operating-Systems</a></li><li><a href=https://lcs-developer.it/tags/virtual-memory/>Virtual-Memory</a></li><li><a href=https://lcs-developer.it/tags/coding/>Coding</a></li></ul><nav class=paginav><a class=prev href=https://lcs-developer.it/posts/how-memory-pagination-works/><span class=title>« Prev</span><br><span>How Memory Pagination Works</span>
</a><a class=next href=https://lcs-developer.it/posts/why-this-blog-and-how-i-manage-it/><span class=title>Next »</span><br><span>Why this blog and how I manage it</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Produttore - Consumatore Posix on x" href="https://x.com/intent/tweet/?text=Produttore%20-%20Consumatore%20Posix&amp;url=https%3a%2f%2flcs-developer.it%2fposts%2fproduttore---consumatore-posix%2f&amp;hashtags=Operating-Systems%2cVirtual-Memory%2cCoding"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Produttore - Consumatore Posix on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flcs-developer.it%2fposts%2fproduttore---consumatore-posix%2f&amp;title=Produttore%20-%20Consumatore%20Posix&amp;summary=Produttore%20-%20Consumatore%20Posix&amp;source=https%3a%2f%2flcs-developer.it%2fposts%2fproduttore---consumatore-posix%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Produttore - Consumatore Posix on reddit" href="https://reddit.com/submit?url=https%3a%2f%2flcs-developer.it%2fposts%2fproduttore---consumatore-posix%2f&title=Produttore%20-%20Consumatore%20Posix"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Produttore - Consumatore Posix on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flcs-developer.it%2fposts%2fproduttore---consumatore-posix%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Produttore - Consumatore Posix on whatsapp" href="https://api.whatsapp.com/send?text=Produttore%20-%20Consumatore%20Posix%20-%20https%3a%2f%2flcs-developer.it%2fposts%2fproduttore---consumatore-posix%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Produttore - Consumatore Posix on telegram" href="https://telegram.me/share/url?text=Produttore%20-%20Consumatore%20Posix&amp;url=https%3a%2f%2flcs-developer.it%2fposts%2fproduttore---consumatore-posix%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Produttore - Consumatore Posix on ycombinator" href="https://news.ycombinator.com/submitlink?t=Produttore%20-%20Consumatore%20Posix&u=https%3a%2f%2flcs-developer.it%2fposts%2fproduttore---consumatore-posix%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://lcs-developer.it/>LCS.Developer</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/XtremeXSPC/ rel=noopener target=_blank>Made with ❤️ XtremeXSPC</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>