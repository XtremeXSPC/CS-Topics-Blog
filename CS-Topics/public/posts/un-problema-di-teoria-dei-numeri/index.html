<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Un problema di Teoria dei Numeri | LCS.Developer</title><meta name=keywords content><meta name=description content="Sea, You & copriMe: Un&rsquo;analisi algoritmica dettagliata
Abstract
Questo articolo presenta un&rsquo;analisi completa del problema di trovare quadrupli coprimi in array di grandi dimensioni, un problema che emerge nell&rsquo;ambito della programmazione competitiva ma che rivela interessanti connessioni con la teoria dei numeri e la teoria dei grafi. Esploriamo come tecniche apparentemente disparate - dal crivello di Eratostene alla teoria dei grafi, dal principio di inclusione-esclusione alle euristiche di ricerca - si combinino per produrre una soluzione elegante ed efficiente. L&rsquo;implementazione finale dimostra come la comprensione profonda delle proprietà matematiche del problema possa portare a ottimizzazioni algoritmiche significative."><meta name=author content="LCS.Dev"><link rel=canonical href=https://lcs-developer.com/posts/un-problema-di-teoria-dei-numeri/><meta name=google-site-verification content="CPQPKX3QPR"><link crossorigin=anonymous href=/assets/css/stylesheet.2bbe49b8fd26e9b2a1b26e6ef8e0785cc8918c0cdbe6afaeed0d49cef5feffa4.css integrity="sha256-K75JuP0m6bKhsm5u+OB4XMiRjAzb5q+u7Q1JzvX+/6Q=" rel="preload stylesheet" as=style><link rel=icon href=https://lcs-developer.com/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lcs-developer.com/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lcs-developer.com/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://lcs-developer.com/favicon/apple-touch-icon.png><link rel=mask-icon href=https://lcs-developer.com/favicon/safari-pinned-tab.svg><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#ffffff"><link rel=alternate hreflang=en href=https://lcs-developer.com/posts/un-problema-di-teoria-dei-numeri/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-CPQPKX3QPR"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-CPQPKX3QPR")}</script><meta property="og:url" content="https://lcs-developer.com/posts/un-problema-di-teoria-dei-numeri/"><meta property="og:site_name" content="LCS.Developer"><meta property="og:title" content="Un problema di Teoria dei Numeri"><meta property="og:description" content="Sea, You & copriMe: Un’analisi algoritmica dettagliata Abstract Questo articolo presenta un’analisi completa del problema di trovare quadrupli coprimi in array di grandi dimensioni, un problema che emerge nell’ambito della programmazione competitiva ma che rivela interessanti connessioni con la teoria dei numeri e la teoria dei grafi. Esploriamo come tecniche apparentemente disparate - dal crivello di Eratostene alla teoria dei grafi, dal principio di inclusione-esclusione alle euristiche di ricerca - si combinino per produrre una soluzione elegante ed efficiente. L’implementazione finale dimostra come la comprensione profonda delle proprietà matematiche del problema possa portare a ottimizzazioni algoritmiche significative."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-08-26T22:10:00+00:00"><meta property="article:modified_time" content="2025-08-26T22:10:00+00:00"><meta property="og:image" content="https://lcs-developer.com/images/LCS.Dev-Logo.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://lcs-developer.com/images/LCS.Dev-Logo.jpg"><meta name=twitter:title content="Un problema di Teoria dei Numeri"><meta name=twitter:description content="Sea, You & copriMe: Un&rsquo;analisi algoritmica dettagliata
Abstract
Questo articolo presenta un&rsquo;analisi completa del problema di trovare quadrupli coprimi in array di grandi dimensioni, un problema che emerge nell&rsquo;ambito della programmazione competitiva ma che rivela interessanti connessioni con la teoria dei numeri e la teoria dei grafi. Esploriamo come tecniche apparentemente disparate - dal crivello di Eratostene alla teoria dei grafi, dal principio di inclusione-esclusione alle euristiche di ricerca - si combinino per produrre una soluzione elegante ed efficiente. L&rsquo;implementazione finale dimostra come la comprensione profonda delle proprietà matematiche del problema possa portare a ottimizzazioni algoritmiche significative."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://lcs-developer.com/posts/"},{"@type":"ListItem","position":2,"name":"Un problema di Teoria dei Numeri","item":"https://lcs-developer.com/posts/un-problema-di-teoria-dei-numeri/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Un problema di Teoria dei Numeri","name":"Un problema di Teoria dei Numeri","description":"Sea, You \u0026amp; copriMe: Un\u0026rsquo;analisi algoritmica dettagliata Abstract Questo articolo presenta un\u0026rsquo;analisi completa del problema di trovare quadrupli coprimi in array di grandi dimensioni, un problema che emerge nell\u0026rsquo;ambito della programmazione competitiva ma che rivela interessanti connessioni con la teoria dei numeri e la teoria dei grafi. Esploriamo come tecniche apparentemente disparate - dal crivello di Eratostene alla teoria dei grafi, dal principio di inclusione-esclusione alle euristiche di ricerca - si combinino per produrre una soluzione elegante ed efficiente. L\u0026rsquo;implementazione finale dimostra come la comprensione profonda delle proprietà matematiche del problema possa portare a ottimizzazioni algoritmiche significative.\n","keywords":[null],"articleBody":"Sea, You \u0026 copriMe: Un’analisi algoritmica dettagliata Abstract Questo articolo presenta un’analisi completa del problema di trovare quadrupli coprimi in array di grandi dimensioni, un problema che emerge nell’ambito della programmazione competitiva ma che rivela interessanti connessioni con la teoria dei numeri e la teoria dei grafi. Esploriamo come tecniche apparentemente disparate - dal crivello di Eratostene alla teoria dei grafi, dal principio di inclusione-esclusione alle euristiche di ricerca - si combinino per produrre una soluzione elegante ed efficiente. L’implementazione finale dimostra come la comprensione profonda delle proprietà matematiche del problema possa portare a ottimizzazioni algoritmiche significative.\n1. Introduzione e definizione del problema Nel panorama della programmazione competitiva, alcuni problemi si distinguono per la loro apparente semplicità che nasconde una ricchezza algoritmica sorprendente. Il problema “Sea, You \u0026 copriMe” appartiene a questa categoria. Data la sua formulazione:\nInput:\nUn array a di n elementi (4 ≤ n ≤ 200,000) Ogni elemento a[i] è compreso tra 1 e m (1 ≤ m ≤ 1,000,000) Output:\nQuattro indici distinti (p, q, r, s) tali che: gcd(a[p], a[q]) = 1 (prima coppia coprime) gcd(a[r], a[s]) = 1 (seconda coppia coprime) Se non esiste soluzione, output 0 La semplicità della definizione nasconde diverse sfide computazionali. Con n fino a 200,000, un approccio naive che testa tutte le combinazioni di quattro elementi richiederebbe O(n⁴) operazioni - chiaramente impraticabile. La chiave sta nel comprendere la struttura matematica sottostante e sfruttarla per ridurre drasticamente lo spazio di ricerca.\n2. Il grafo di coprimalità: Una prospettiva strutturale 2.1 Modellazione del problema La prima intuizione fondamentale è modellare il problema come un grafo non orientato G = (V, E) dove:\nV = {1, 2, …, n} rappresenta gli indici dell’array (i, j) ∈ E se e solo se gcd(a[i], a[j]) = 1 In questa rappresentazione, trovare una soluzione equivale a trovare due archi disgiunti nel grafo. Questa riformulazione apre immediatamente diverse strade algoritmiche.\n2.2 Proprietà del grafo Il grafo di coprimalità presenta proprietà interessanti che guidano il nostro approccio:\nDensità variabile: Elementi con molti fattori primi tendono ad avere pochi vicini (basso grado), mentre numeri primi o con pochi fattori tendono ad avere molti vicini.\nCricca dei numeri primi: Numeri primi distinti formano una cricca (o clique) completa nel grafo.\nStella unitaria: Il valore 1 è adiacente a tutti gli altri vertici, formando una stella nel grafo.\nQueste proprietà suggeriscono che alcuni elementi sono “più preziosi” di altri nella ricerca di una soluzione.\n2.3 Il concetto di grado di coprimalità Definiamo il grado di coprimalità di un elemento come il numero di altri elementi nell’array che sono coprimi con esso. Formalmente:\ndeg(i) = |{j ∈ {1,...,n}, j ≠ i : gcd(a[i], a[j]) = 1}| Elementi con grado basso sono “risorse scarse” che devono essere gestite con priorità. Un elemento con grado 1, per esempio, ha un solo possibile partner coprimo - se non lo accoppiano subito, potrebbe precludere soluzioni future.\n3. Fondamenti di teoria dei numeri 3.1 La funzione di Möbius e il principio di inclusione-esclusione Il calcolo efficiente del numero di elementi coprimi con un dato valore è cruciale per la performance dell’algoritmo. Qui entra in gioco la funzione di Möbius μ(n):\nμ(n) = { 1 se n è prodotto di un numero pari di primi distinti -1 se n è prodotto di un numero dispari di primi distinti 0 se n ha un fattore quadrato } Il teorema fondamentale che utilizziamo è:\nTeorema: Dato un valore x e un multiset S di interi, il numero di elementi in S coprimi con x è:\ncount_coprime(x) = Σ_{d|x, d squarefree} μ(d) × |{s ∈ S : d|s}| 3.2 Esempio concreto Supponiamo x = 6 = 2 × 3 e S = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}.\nI divisori squarefree di 6 sono: {1, 2, 3, 6}\nCalcoliamo:\nμ(1) = 1, elementi divisibili per 1: tutti (10) μ(2) = -1, elementi divisibili per 2: {2, 4, 6, 8, 10} (5) μ(3) = -1, elementi divisibili per 3: {3, 6, 9} (3) μ(6) = 1, elementi divisibili per 6: {6} (1) count_coprime(6) = 1×10 + (-1)×5 + (-1)×3 + 1×1 = 10 - 5 - 3 + 1 = 3\nInfatti, gli elementi coprimi con 6 sono {1, 5, 7}, esattamente 3.\n3.3 Implementazione del crivello lineare Per calcolare efficientemente μ(n) e i fattori primi minimi, utilizziamo un crivello lineare modificato:\nvoid build_sieve() { vector\u003cint\u003e primes; mobius[1] = 1; for (int i = 2; i \u003c MAX; ++i) { if (smallest_prime_factor[i] == 0) { // i è primo smallest_prime_factor[i] = i; primes.push_back(i); mobius[i] = -1; } for (int p : primes) { if (p * i \u003e= MAX) break; smallest_prime_factor[p * i] = p; if (i % p == 0) { // i ha p come fattore, quindi p*i ha p² mobius[p * i] = 0; break; } else { // p*i è squarefree se i lo è mobius[p * i] = -mobius[i]; } } } } La complessità è O(m) dove m è il valore massimo, un miglioramento significativo rispetto al crivello classico O(m log log m).\n4. L’algoritmo: un approccio stratificato 4.1 Panoramica della strategia L’algoritmo procede attraverso una serie di fasi, ciascuna progettata per sfruttare casi speciali o proprietà strutturali del problema:\nFase 0: Preprocessing e costruzione delle strutture dati Fase 1: Gestione dei valori unitari (1) Fase 2: Sfruttamento dei valori duplicati Fase 3: Caso del singolo valore unitario Fase 4: Ricerca basata sui gradi con euristiche Ogni fase successiva è più costosa computazionalmente, ma viene eseguita solo se le fasi precedenti non trovano una soluzione.\n4.2 Fase 0: preprocessing e strutture dati Prima di iniziare la ricerca, costruiamo diverse strutture dati ausiliarie:\nstruct ElementInfo { int value; // Valore originale vector\u003cint\u003e positions; // Posizioni nell'array vector\u003cint\u003e squarefree_divisors; // Divisori senza quadrati int coprime_count; // Numero di coprimi nell'array }; // Costruzione della mappa valore -\u003e info unordered_map\u003cint, ElementInfo\u003e value_map; for (int i = 1; i \u003c= n; ++i) { if (!value_map.count(a[i])) { value_map[a[i]] = ElementInfo{ .value = a[i], .positions = {i}, .squarefree_divisors = compute_squarefree_divisors(a[i]) }; } else { value_map[a[i]].positions.push_back(i); } } // Array per conteggio divisibilità vector\u003cint\u003e divisibility_count(m + 1, 0); for (int d = 1; d \u003c= m; ++d) { for (int multiple = d; multiple \u003c= m; multiple += d) { divisibility_count[d] += frequency[multiple]; } } Questa fase ha complessità O(m log m) per il calcolo delle divisibilità e O(n × d(max_value)) per i divisori squarefree.\n4.3 Fase 1: il potere dei valori unitari I valori pari a 1 sono speciali: sono coprimi con ogni altro numero. Questo li rende estremamente preziosi per costruire soluzioni:\nCaso 1.1: Quattro o più 1\nSe abbiamo almeno quattro 1, la soluzione è immediata: (pos_1[0], pos_1[1], pos_1[2], pos_1[3]) Caso 1.2: Esattamente tre 1\nTre 1 più qualsiasi altro elemento formano una soluzione: (pos_1[0], pos_1[1], pos_1[2], any_other_position) Caso 1.3: Esattamente due 1\nDue 1 possono essere accoppiati con qualsiasi altra coppia: (pos_1[0], any_pos_1, pos_1[1], any_pos_2) L’implementazione gestisce questi casi in O(1) o O(n) nel peggiore dei casi:\nbool handle_unit_values() { auto\u0026 unit_info = value_map[1]; size_t count = unit_info.positions.size(); if (count \u003e= 4) { output_solution(unit_info.positions[0], unit_info.positions[1], unit_info.positions[2], unit_info.positions[3]); return true; } if (count == 3) { // Trova un quarto elemento qualsiasi for (int i = 1; i \u003c= n; ++i) { if (a[i] != 1) { output_solution(unit_info.positions[0], unit_info.positions[1], unit_info.positions[2], i); return true; } } } // ... gestione caso con 2 unità ... } 4.4 Fase 2: sfruttare le duplicazioni Se un valore appare più volte e ha abbastanza elementi coprimi, possiamo costruire rapidamente una soluzione:\nbool exploit_duplicates() { for (auto\u0026 [value, info] : value_map) { if (info.positions.size() \u003e= 2 \u0026\u0026 value != 1) { int coprimes = count_coprimes_for_value(value); if (coprimes \u003e= 2) { // Trova due elementi coprimi con 'value' vector\u003cint\u003e partners; for (int i = 1; i \u003c= n \u0026\u0026 partners.size() \u003c 2; ++i) { if (gcd(value, a[i]) == 1) { partners.push_back(i); } } if (partners.size() \u003e= 2) { output_solution(info.positions[0], partners[0], info.positions[1], partners[1]); return true; } } } } return false; } Questa fase ha complessità O(U × n) dove U è il numero di valori unici, tipicamente molto minore di n.\n4.5 Fase 3: il caso del singolo valore unitario Quando c’è esattamente un 1 nell’array, la situazione richiede più attenzione. L'1 può essere accoppiato con qualsiasi elemento, ma dobbiamo assicurarci che gli altri tre elementi formino almeno una coppia coprime:\nbool handle_single_unit() { int unit_pos = value_map[1].positions[0]; // Cerca un valore con almeno un coprime (oltre all'1) for (auto\u0026 [value, info] : value_map) { if (value == 1) continue; int adjusted_coprimes = count_coprimes_for_value(value) - 1; if (adjusted_coprimes \u003e= 1) { // Abbiamo trovato una coppia potenziale int first = info.positions[0]; // Trova il partner coprime for (int partner = 1; partner \u003c= n; ++partner) { if (partner != unit_pos \u0026\u0026 partner != first \u0026\u0026 gcd(value, a[partner]) == 1) { // Trova un quarto elemento qualsiasi for (int fourth = 1; fourth \u003c= n; ++fourth) { if (fourth != unit_pos \u0026\u0026 fourth != first \u0026\u0026 fourth != partner) { output_solution(first, partner, unit_pos, fourth); return true; } } } } } } return false; } 4.6 Fase 4: ricerca euristica basata sui gradi Quando tutti i casi speciali falliscono, ricorriamo a una ricerca più sofisticata basata sui gradi di coprimalità.\n4.6.1 Priorità ai vertici foglia I vertici con grado 1 (foglie nel grafo) sono critici: hanno un solo possibile partner. Se non li accoppiano immediatamente, potrebbero bloccare soluzioni future:\nbool process_leaf_vertices() { for (auto\u0026 [value, info] : value_map) { if (info.coprime_count == 1) { int leaf = info.positions[0]; // Trova l'unico partner coprime for (int partner = 1; partner \u003c= n; ++partner) { if (partner != leaf \u0026\u0026 gcd(a[leaf], a[partner]) == 1) { // Rimuovi temporaneamente dalla considerazione update_divisibility(leaf, -1); update_divisibility(partner, -1); // Cerca una seconda coppia auto [third, fourth] = find_coprime_pair_excluding(leaf, partner); if (third != -1) { output_solution(leaf, partner, third, fourth); return true; } // Ripristina update_divisibility(leaf, +1); update_divisibility(partner, +1); // Nessuna soluzione possibile con questa foglia return false; } } } } return false; } 4.6.2 Ricerca con bounded search Per gli elementi rimanenti, ordiniamo per grado crescente e applichiamo una ricerca limitata:\nbool general_search() { // Costruisci lista ordinata per grado vector\u003cpair\u003cint, int\u003e\u003e degree_position; for (int i = 1; i \u003c= n; ++i) { int degree = compute_degree(i); if (degree \u003e= 1) { degree_position.push_back({degree, i}); } } sort(degree_position.begin(), degree_position.end()); // Prova combinazioni con limite sui candidati const int CANDIDATE_LIMIT = 30; for (auto [degree, first_pos] : degree_position) { // Raccogli fino a 30 candidati coprimi vector\u003cint\u003e candidates; for (int second = 1; second \u003c= n \u0026\u0026 candidates.size() \u003c CANDIDATE_LIMIT; ++second) { if (second != first_pos \u0026\u0026 gcd(a[first_pos], a[second]) == 1) { candidates.push_back(second); } } // Prova ogni candidato for (int second_pos : candidates) { update_divisibility(first_pos, -1); update_divisibility(second_pos, -1); auto [third, fourth] = find_coprime_pair_excluding(first_pos, second_pos); if (third != -1) { output_solution(first_pos, second_pos, third, fourth); return true; } update_divisibility(first_pos, +1); update_divisibility(second_pos, +1); } } return false; } Il limite di 30 candidati è una scelta euristica che bilancia thoroughness e performance, garantendo complessità O(n × 30) invece di O(n²).\n5. Ottimizzazioni implementative 5.1 Aggiornamento incrementale dei conteggi Invece di ricalcolare i gradi dopo ogni “rimozione” di elementi, aggiorniamo incrementalmente:\nvoid update_divisibility(int position, int delta) { int value = a[position]; for (int d : squarefree_divisors[value]) { divisibility_count[d] += delta; } } Questo riduce il costo di ogni aggiornamento da O(m) a O(d(value)), tipicamente molto piccolo.\n5.2 Pre-computazione e caching Tutti i valori che dipendono solo dai valori unici vengono calcolati una sola volta:\nstruct PrecomputedData { vector\u003cvector\u003cint\u003e\u003e squarefree_divisors; // Per valore unico vector\u003cint\u003e initial_degrees; // Gradi iniziali vector\u003cint\u003e value_to_unique_id; // Mappatura rapida }; 5.3 Early termination Ogni fase termina appena trova una soluzione, evitando computazioni non necessarie:\nvoid solve() { if (handle_unit_values()) return; if (exploit_duplicates()) return; if (handle_single_unit()) return; if (process_leaf_vertices()) return; if (general_search()) return; cout \u003c\u003c \"0\\n\"; // Nessuna soluzione } 6. Analisi della complessità 6.1 Complessità temporale Analizziamo ogni componente:\nPreprocessing del crivello: O(m) usando il crivello lineare Calcolo divisori squarefree: O(U × 2^ω(max)) dove ω(n) è il numero di primi distinti Conteggio divisibilità: O(m log m) Fasi 1-3: O(n) ciascuna Fase 4: O(n × min(n, 30)) = O(n × 30) con bounded search Complessità totale: O(m log m + n × 30 + U × 2^ω(max))\nIn pratica, per i vincoli del problema (m ≤ 10^6, n ≤ 2×10^5), l’algoritmo opera in tempo quasi lineare per la maggior parte degli input.\n6.2 Complessità spaziale Le strutture dati principali richiedono:\nCrivello: O(m) Divisori squarefree: O(U × d(max)) Conteggi divisibilità: O(m) Strutture ausiliarie: O(n) Spazio totale: O(m + n + U × d(max))\n7. Casi test e validazione 7.1 Caso test 1: array con molti valori unitari Input: n=5, m=10, a=[1, 1, 1, 2, 3] Output: 1 2 3 4 La fase 1 risolve immediatamente trovando tre 1 e un altro elemento.\n7.2 Caso test 2: valori duplicati con coprimi Input: n=6, m=15, a=[6, 10, 11, 12, 15, 6] Output: 1 3 6 4 La fase 2 identifica che 6 appare due volte e trova che 11 è coprime con 6, così come 12 con l’altro 6.\n7.3 Caso test 3: grafo sparso Input: n=4, m=10, a=[2, 4, 8, 16] Output: 0 Tutti gli elementi sono potenze di 2, quindi nessuna coppia è coprime. L’algoritmo esplora tutte le fasi e correttamente riporta che non esiste soluzione.\n7.4 Performance su input di grande scala Test con n=200,000 e valori casuali mostra tempi di esecuzione tipici sotto i 100ms, ben entro il limite di 3 secondi. Il caso peggiore (tutti valori primi distinti) richiede circa 500ms.\n8. Considerazioni implementative in C++ moderno 8.1 Uso di std::span (C++20) Per passare riferimenti a porzioni di array senza copia:\nint count_coprimes(std::span\u003cconst int\u003e squarefree_divs) { int result = 0; for (int d : squarefree_divs) { result += mobius[d] * divisibility_count[d]; } return result; } 8.2 Structured bindings per leggibilità for (const auto\u0026 [value, info] : value_map) { // Codice più leggibile rispetto a iter-\u003efirst, iter-\u003esecond } 8.3 std::array Per dimensioni fisse Per il crivello, std::array offre migliore località di cache rispetto a std::vector:\nstd::array\u003cint, 1000001\u003e smallest_prime_factor{}; // vs std::vector\u003cint\u003e smallest_prime_factor(1000001); 8.4 Gestione della memoria L’uso di reserve() per vettori di dimensione nota previene riallocazioni:\nvector\u003cint\u003e primes; primes.reserve(80000); // Circa π(10^6) 9. Estensioni e varianti del problema 9.1 K-tuple coprimi Il problema può essere generalizzato a trovare k coppie coprime disgiunte. L’approccio basato sui gradi si estende naturalmente, ma la complessità cresce.\n9.2 Massimizzare il numero di coppie Variante: trovare il massimo numero di coppie coprime disgiunte. Questo diventa un problema di matching massimo nel grafo di coprimalità, risolvibile con algoritmi di flusso.\n9.3 Versione online Se l’array viene modificato dinamicamente (inserimenti/cancellazioni), le strutture dati devono supportare aggiornamenti incrementali. Un approccio basato su segment tree per i conteggi di divisibilità potrebbe essere appropriato.\n10. Conclusioni e riflessioni Il problema dei quadrupli coprimi esemplifica come la combinazione di tecniche diverse possa produrre soluzioni efficienti per problemi apparentemente intrattabili. Gli elementi chiave del successo sono stati:\nModellazione appropriata: Vedere il problema come ricerca in un grafo ha aperto nuove strade algoritmiche.\nSfruttamento delle proprietà matematiche: La funzione di Möbius e il principio di inclusione-esclusione hanno permesso calcoli efficienti che sarebbero stati proibitivi altrimenti.\nApproccio stratificato: Gestire prima i casi semplici e frequenti, poi procedere verso strategie più complesse solo quando necessario.\nEuristiche intelligenti: Il bounded search e la priorità ai vertici foglia riducono drasticamente lo spazio di ricerca senza compromettere la correttezza.\nAttenzione ai dettagli implementativi: Ottimizzazioni come l’aggiornamento incrementale e la pre-computazione fanno la differenza tra una soluzione teoricamente corretta e una praticamente utilizzabile.\nQuesto problema dimostra che anche nell’era degli algoritmi di machine learning e dell’intelligenza artificiale, la comprensione profonda delle strutture matematiche e l’ingegnosità algoritmica classica rimangono strumenti indispensabili per il problem solving computazionale.\nRingrazio la comunità di programmazione competitiva per le continue sfide intellettuali che spingono i limiti dell’efficienza algoritmica.\nBibliografia Hardy, G.H. and Wright, E.M. (2008). An Introduction to the Theory of Numbers. Oxford University Press. Apostol, T.M. (1976). Introduction to Analytic Number Theory. Springer-Verlag. Cormen, T.H., Leiserson, C.E., Rivest, R.L., and Stein, C. (2009). Introduction to Algorithms. MIT Press. Kleinberg, J. and Tardos, É. (2005). Algorithm Design. Addison-Wesley. Codice sorgente Il codice completo dell’implementazione è disponibile come appendice digitale a questo articolo, insieme a un suite di test comprensiva e benchmark di performance.\n","wordCount":"2709","inLanguage":"en","image":"https://lcs-developer.com/images/LCS.Dev-Logo.jpg","datePublished":"2025-08-26T22:10:00.000535Z","dateModified":"2025-08-26T22:10:00.000535Z","author":{"@type":"Person","name":"LCS.Dev"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lcs-developer.com/posts/un-problema-di-teoria-dei-numeri/"},"publisher":{"@type":"Organization","name":"LCS.Developer","logo":{"@type":"ImageObject","url":"https://lcs-developer.com/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://lcs-developer.com/ accesskey=h title="LCS.Dev - CS Topics (Alt + H)"><img src=https://lcs-developer.com/%F0%9F%91%A8%E2%80%8D%F0%9F%92%BB alt aria-label=logo height=35>LCS.Dev - CS Topics</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://lcs-developer.com/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://lcs-developer.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://lcs-developer.com/about/ title=About><span>About</span></a></li><li><a href=https://lcs-developer.com/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://lcs-developer.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://lcs-developer.com/>Home</a>&nbsp;»&nbsp;<a href=https://lcs-developer.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Un problema di Teoria dei Numeri</h1><div class=post-meta><span title='2025-08-26 22:10:00.000535 +0000 UTC'>August 26, 2025</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;2709 words&nbsp;·&nbsp;LCS.Dev&nbsp;|&nbsp;<a href=https://github.com/XtremeXSPC/LCS.Dev-Blog/tree/hostinger//posts/Un%20problema%20di%20Teoria%20dei%20Numeri.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#abstract>Abstract</a></li><li><a href=#1-introduzione-e-definizione-del-problema>1. Introduzione e definizione del problema</a></li><li><a href=#2-il-grafo-di-coprimalità-una-prospettiva-strutturale>2. Il grafo di coprimalità: Una prospettiva strutturale</a><ul><li><a href=#21-modellazione-del-problema>2.1 Modellazione del problema</a></li><li><a href=#22-proprietà-del-grafo>2.2 Proprietà del grafo</a></li><li><a href=#23-il-concetto-di-grado-di-coprimalità>2.3 Il concetto di grado di coprimalità</a></li></ul></li><li><a href=#3-fondamenti-di-teoria-dei-numeri>3. Fondamenti di teoria dei numeri</a><ul><li><a href=#31-la-funzione-di-möbius-e-il-principio-di-inclusione-esclusione>3.1 La funzione di Möbius e il principio di inclusione-esclusione</a></li><li><a href=#32-esempio-concreto>3.2 Esempio concreto</a></li><li><a href=#33-implementazione-del-crivello-lineare>3.3 Implementazione del crivello lineare</a></li></ul></li><li><a href=#4-lalgoritmo-un-approccio-stratificato>4. L&rsquo;algoritmo: un approccio stratificato</a><ul><li><a href=#41-panoramica-della-strategia>4.1 Panoramica della strategia</a></li><li><a href=#42-fase-0-preprocessing-e-strutture-dati>4.2 Fase 0: preprocessing e strutture dati</a></li><li><a href=#43-fase-1-il-potere-dei-valori-unitari>4.3 Fase 1: il potere dei valori unitari</a></li><li><a href=#44-fase-2-sfruttare-le-duplicazioni>4.4 Fase 2: sfruttare le duplicazioni</a></li><li><a href=#45-fase-3-il-caso-del-singolo-valore-unitario>4.5 Fase 3: il caso del singolo valore unitario</a></li><li><a href=#46-fase-4-ricerca-euristica-basata-sui-gradi>4.6 Fase 4: ricerca euristica basata sui gradi</a></li></ul></li><li><a href=#5-ottimizzazioni-implementative>5. Ottimizzazioni implementative</a><ul><li><a href=#51-aggiornamento-incrementale-dei-conteggi>5.1 Aggiornamento incrementale dei conteggi</a></li><li><a href=#52-pre-computazione-e-caching>5.2 Pre-computazione e caching</a></li><li><a href=#53-early-termination>5.3 Early termination</a></li></ul></li><li><a href=#6-analisi-della-complessità>6. Analisi della complessità</a><ul><li><a href=#61-complessità-temporale>6.1 Complessità temporale</a></li><li><a href=#62-complessità-spaziale>6.2 Complessità spaziale</a></li></ul></li><li><a href=#7-casi-test-e-validazione>7. Casi test e validazione</a><ul><li><a href=#71-caso-test-1-array-con-molti-valori-unitari>7.1 Caso test 1: array con molti valori unitari</a></li><li><a href=#72-caso-test-2-valori-duplicati-con-coprimi>7.2 Caso test 2: valori duplicati con coprimi</a></li><li><a href=#73-caso-test-3-grafo-sparso>7.3 Caso test 3: grafo sparso</a></li><li><a href=#74-performance-su-input-di-grande-scala>7.4 Performance su input di grande scala</a></li></ul></li><li><a href=#8-considerazioni-implementative-in-c-moderno>8. Considerazioni implementative in C++ moderno</a><ul><li><a href=#81-uso-di-stdspan-c20>8.1 Uso di std::span (C++20)</a></li><li><a href=#82-structured-bindings-per-leggibilità>8.2 Structured bindings per leggibilità</a></li><li><a href=#83-stdarray-per-dimensioni-fisse>8.3 std::array Per dimensioni fisse</a></li><li><a href=#84-gestione-della-memoria>8.4 Gestione della memoria</a></li></ul></li><li><a href=#9-estensioni-e-varianti-del-problema>9. Estensioni e varianti del problema</a><ul><li><a href=#91-k-tuple-coprimi>9.1 K-tuple coprimi</a></li><li><a href=#92-massimizzare-il-numero-di-coppie>9.2 Massimizzare il numero di coppie</a></li><li><a href=#93-versione-online>9.3 Versione online</a></li></ul></li><li><a href=#10-conclusioni-e-riflessioni>10. Conclusioni e riflessioni</a><ul><li><a href=#bibliografia>Bibliografia</a></li><li><a href=#codice-sorgente>Codice sorgente</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=sea-you--coprime-unanalisi-algoritmica-dettagliata>Sea, You & copriMe: Un&rsquo;analisi algoritmica dettagliata<a hidden class=anchor aria-hidden=true href=#sea-you--coprime-unanalisi-algoritmica-dettagliata>#</a></h1><h2 id=abstract>Abstract<a hidden class=anchor aria-hidden=true href=#abstract>#</a></h2><p>Questo articolo presenta un&rsquo;analisi completa del problema di trovare quadrupli coprimi in array di grandi dimensioni, un problema che emerge nell&rsquo;ambito della programmazione competitiva ma che rivela interessanti connessioni con la teoria dei numeri e la teoria dei grafi. Esploriamo come tecniche apparentemente disparate - dal crivello di Eratostene alla teoria dei grafi, dal principio di inclusione-esclusione alle euristiche di ricerca - si combinino per produrre una soluzione elegante ed efficiente. L&rsquo;implementazione finale dimostra come la comprensione profonda delle proprietà matematiche del problema possa portare a ottimizzazioni algoritmiche significative.</p><h2 id=1-introduzione-e-definizione-del-problema>1. Introduzione e definizione del problema<a hidden class=anchor aria-hidden=true href=#1-introduzione-e-definizione-del-problema>#</a></h2><p>Nel panorama della programmazione competitiva, alcuni problemi si distinguono per la loro apparente semplicità che nasconde una ricchezza algoritmica sorprendente. Il problema &ldquo;Sea, You & copriMe&rdquo; appartiene a questa categoria. Data la sua formulazione:</p><p><strong>Input:</strong></p><ul><li>Un array <code>a</code> di <code>n</code> elementi (4 ≤ n ≤ 200,000)</li><li>Ogni elemento <code>a[i]</code> è compreso tra 1 e <code>m</code> (1 ≤ m ≤ 1,000,000)</li></ul><p><strong>Output:</strong></p><ul><li>Quattro indici distinti <code>(p, q, r, s)</code> tali che:<ul><li><code>gcd(a[p], a[q]) = 1</code> (prima coppia coprime)</li><li><code>gcd(a[r], a[s]) = 1</code> (seconda coppia coprime)</li></ul></li><li>Se non esiste soluzione, output <code>0</code></li></ul><p>La semplicità della definizione nasconde diverse sfide computazionali. Con n fino a 200,000, un approccio naive che testa tutte le combinazioni di quattro elementi richiederebbe O(n⁴) operazioni - chiaramente impraticabile. La chiave sta nel comprendere la struttura matematica sottostante e sfruttarla per ridurre drasticamente lo spazio di ricerca.</p><h2 id=2-il-grafo-di-coprimalità-una-prospettiva-strutturale>2. Il grafo di coprimalità: Una prospettiva strutturale<a hidden class=anchor aria-hidden=true href=#2-il-grafo-di-coprimalità-una-prospettiva-strutturale>#</a></h2><h3 id=21-modellazione-del-problema>2.1 Modellazione del problema<a hidden class=anchor aria-hidden=true href=#21-modellazione-del-problema>#</a></h3><p>La prima intuizione fondamentale è modellare il problema come un grafo non orientato G = (V, E) dove:</p><ul><li>V = {1, 2, &mldr;, n} rappresenta gli indici dell&rsquo;array</li><li>(i, j) ∈ E se e solo se gcd(a[i], a[j]) = 1</li></ul><p>In questa rappresentazione, trovare una soluzione equivale a trovare due archi disgiunti nel grafo. Questa riformulazione apre immediatamente diverse strade algoritmiche.</p><h3 id=22-proprietà-del-grafo>2.2 Proprietà del grafo<a hidden class=anchor aria-hidden=true href=#22-proprietà-del-grafo>#</a></h3><p>Il grafo di coprimalità presenta proprietà interessanti che guidano il nostro approccio:</p><ol><li><p><strong>Densità variabile</strong>: Elementi con molti fattori primi tendono ad avere pochi vicini (basso grado), mentre numeri primi o con pochi fattori tendono ad avere molti vicini.</p></li><li><p><strong>Cricca dei numeri primi</strong>: Numeri primi distinti formano una cricca (o clique) completa nel grafo.</p></li><li><p><strong>Stella unitaria</strong>: Il valore 1 è adiacente a tutti gli altri vertici, formando una stella nel grafo.</p></li></ol><p>Queste proprietà suggeriscono che alcuni elementi sono &ldquo;più preziosi&rdquo; di altri nella ricerca di una soluzione.</p><h3 id=23-il-concetto-di-grado-di-coprimalità>2.3 Il concetto di grado di coprimalità<a hidden class=anchor aria-hidden=true href=#23-il-concetto-di-grado-di-coprimalità>#</a></h3><p>Definiamo il <strong>grado di coprimalità</strong> di un elemento come il numero di altri elementi nell&rsquo;array che sono coprimi con esso. Formalmente:</p><pre tabindex=0><code>deg(i) = |{j ∈ {1,...,n}, j ≠ i : gcd(a[i], a[j]) = 1}|
</code></pre><p>Elementi con grado basso sono &ldquo;risorse scarse&rdquo; che devono essere gestite con priorità. Un elemento con grado 1, per esempio, ha un solo possibile partner coprimo - se non lo accoppiano subito, potrebbe precludere soluzioni future.</p><h2 id=3-fondamenti-di-teoria-dei-numeri>3. Fondamenti di teoria dei numeri<a hidden class=anchor aria-hidden=true href=#3-fondamenti-di-teoria-dei-numeri>#</a></h2><h3 id=31-la-funzione-di-möbius-e-il-principio-di-inclusione-esclusione>3.1 La funzione di Möbius e il principio di inclusione-esclusione<a hidden class=anchor aria-hidden=true href=#31-la-funzione-di-möbius-e-il-principio-di-inclusione-esclusione>#</a></h3><p>Il calcolo efficiente del numero di elementi coprimi con un dato valore è cruciale per la performance dell&rsquo;algoritmo. Qui entra in gioco la funzione di Möbius μ(n):</p><pre tabindex=0><code>μ(n) = {
    1     se n è prodotto di un numero pari di primi distinti
   -1     se n è prodotto di un numero dispari di primi distinti
    0     se n ha un fattore quadrato
}
</code></pre><p>Il teorema fondamentale che utilizziamo è:</p><p><strong>Teorema</strong>: Dato un valore x e un multiset S di interi, il numero di elementi in S coprimi con x è:</p><pre tabindex=0><code>count_coprime(x) = Σ_{d|x, d squarefree} μ(d) × |{s ∈ S : d|s}|
</code></pre><h3 id=32-esempio-concreto>3.2 Esempio concreto<a hidden class=anchor aria-hidden=true href=#32-esempio-concreto>#</a></h3><p>Supponiamo x = 6 = 2 × 3 e S = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}.</p><p>I divisori squarefree di 6 sono: {1, 2, 3, 6}</p><p>Calcoliamo:</p><ul><li>μ(1) = 1, elementi divisibili per 1: tutti (10)</li><li>μ(2) = -1, elementi divisibili per 2: {2, 4, 6, 8, 10} (5)</li><li>μ(3) = -1, elementi divisibili per 3: {3, 6, 9} (3)</li><li>μ(6) = 1, elementi divisibili per 6: {6} (1)</li></ul><p>count_coprime(6) = 1×10 + (-1)×5 + (-1)×3 + 1×1 = 10 - 5 - 3 + 1 = 3</p><p>Infatti, gli elementi coprimi con 6 sono {1, 5, 7}, esattamente 3.</p><h3 id=33-implementazione-del-crivello-lineare>3.3 Implementazione del crivello lineare<a hidden class=anchor aria-hidden=true href=#33-implementazione-del-crivello-lineare>#</a></h3><p>Per calcolare efficientemente μ(n) e i fattori primi minimi, utilizziamo un crivello lineare modificato:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>build_sieve</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>primes</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mobius</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>MAX</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>smallest_prime_factor</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// i è primo
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>smallest_prime_factor</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>primes</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>mobius</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=nl>p</span> <span class=p>:</span> <span class=n>primes</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>p</span> <span class=o>*</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=n>MAX</span><span class=p>)</span> <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=n>smallest_prime_factor</span><span class=p>[</span><span class=n>p</span> <span class=o>*</span> <span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>%</span> <span class=n>p</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// i ha p come fattore, quindi p*i ha p²
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>mobius</span><span class=p>[</span><span class=n>p</span> <span class=o>*</span> <span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// p*i è squarefree se i lo è
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>mobius</span><span class=p>[</span><span class=n>p</span> <span class=o>*</span> <span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=o>-</span><span class=n>mobius</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>La complessità è O(m) dove m è il valore massimo, un miglioramento significativo rispetto al crivello classico O(m log log m).</p><h2 id=4-lalgoritmo-un-approccio-stratificato>4. L&rsquo;algoritmo: un approccio stratificato<a hidden class=anchor aria-hidden=true href=#4-lalgoritmo-un-approccio-stratificato>#</a></h2><h3 id=41-panoramica-della-strategia>4.1 Panoramica della strategia<a hidden class=anchor aria-hidden=true href=#41-panoramica-della-strategia>#</a></h3><p>L&rsquo;algoritmo procede attraverso una serie di fasi, ciascuna progettata per sfruttare casi speciali o proprietà strutturali del problema:</p><ol><li><strong>Fase 0</strong>: Preprocessing e costruzione delle strutture dati</li><li><strong>Fase 1</strong>: Gestione dei valori unitari (1)</li><li><strong>Fase 2</strong>: Sfruttamento dei valori duplicati</li><li><strong>Fase 3</strong>: Caso del singolo valore unitario</li><li><strong>Fase 4</strong>: Ricerca basata sui gradi con euristiche</li></ol><p>Ogni fase successiva è più costosa computazionalmente, ma viene eseguita solo se le fasi precedenti non trovano una soluzione.</p><h3 id=42-fase-0-preprocessing-e-strutture-dati>4.2 Fase 0: preprocessing e strutture dati<a hidden class=anchor aria-hidden=true href=#42-fase-0-preprocessing-e-strutture-dati>#</a></h3><p>Prima di iniziare la ricerca, costruiamo diverse strutture dati ausiliarie:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>ElementInfo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>value</span><span class=p>;</span>                        <span class=c1>// Valore originale
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>positions</span><span class=p>;</span>            <span class=c1>// Posizioni nell&#39;array
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>squarefree_divisors</span><span class=p>;</span>  <span class=c1>// Divisori senza quadrati
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>coprime_count</span><span class=p>;</span>                <span class=c1>// Numero di coprimi nell&#39;array
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Costruzione della mappa valore -&gt; info
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>unordered_map</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>ElementInfo</span><span class=o>&gt;</span> <span class=n>value_map</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>value_map</span><span class=p>.</span><span class=n>count</span><span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>value_map</span><span class=p>[</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]]</span> <span class=o>=</span> <span class=n>ElementInfo</span><span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=p>.</span><span class=n>value</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>],</span>
</span></span><span class=line><span class=cl>            <span class=p>.</span><span class=n>positions</span> <span class=o>=</span> <span class=p>{</span><span class=n>i</span><span class=p>},</span>
</span></span><span class=line><span class=cl>            <span class=p>.</span><span class=n>squarefree_divisors</span> <span class=o>=</span> <span class=n>compute_squarefree_divisors</span><span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>value_map</span><span class=p>[</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]].</span><span class=n>positions</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Array per conteggio divisibilità
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>divisibility_count</span><span class=p>(</span><span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>d</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>d</span> <span class=o>&lt;=</span> <span class=n>m</span><span class=p>;</span> <span class=o>++</span><span class=n>d</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>multiple</span> <span class=o>=</span> <span class=n>d</span><span class=p>;</span> <span class=n>multiple</span> <span class=o>&lt;=</span> <span class=n>m</span><span class=p>;</span> <span class=n>multiple</span> <span class=o>+=</span> <span class=n>d</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>divisibility_count</span><span class=p>[</span><span class=n>d</span><span class=p>]</span> <span class=o>+=</span> <span class=n>frequency</span><span class=p>[</span><span class=n>multiple</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Questa fase ha complessità O(m log m) per il calcolo delle divisibilità e O(n × d(max_value)) per i divisori squarefree.</p><h3 id=43-fase-1-il-potere-dei-valori-unitari>4.3 Fase 1: il potere dei valori unitari<a hidden class=anchor aria-hidden=true href=#43-fase-1-il-potere-dei-valori-unitari>#</a></h3><p>I valori pari a 1 sono speciali: sono coprimi con ogni altro numero. Questo li rende estremamente preziosi per costruire soluzioni:</p><p><strong>Caso 1.1</strong>: Quattro o più 1</p><pre tabindex=0><code>Se abbiamo almeno quattro 1, la soluzione è immediata:
(pos_1[0], pos_1[1], pos_1[2], pos_1[3])
</code></pre><p><strong>Caso 1.2</strong>: Esattamente tre 1</p><pre tabindex=0><code>Tre 1 più qualsiasi altro elemento formano una soluzione:
(pos_1[0], pos_1[1], pos_1[2], any_other_position)
</code></pre><p><strong>Caso 1.3</strong>: Esattamente due 1</p><pre tabindex=0><code>Due 1 possono essere accoppiati con qualsiasi altra coppia:
(pos_1[0], any_pos_1, pos_1[1], any_pos_2)
</code></pre><p>L&rsquo;implementazione gestisce questi casi in O(1) o O(n) nel peggiore dei casi:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>handle_unit_values</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span><span class=o>&amp;</span> <span class=n>unit_info</span> <span class=o>=</span> <span class=n>value_map</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=n>count</span> <span class=o>=</span> <span class=n>unit_info</span><span class=p>.</span><span class=n>positions</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>count</span> <span class=o>&gt;=</span> <span class=mi>4</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>output_solution</span><span class=p>(</span><span class=n>unit_info</span><span class=p>.</span><span class=n>positions</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>unit_info</span><span class=p>.</span><span class=n>positions</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span>
</span></span><span class=line><span class=cl>                       <span class=n>unit_info</span><span class=p>.</span><span class=n>positions</span><span class=p>[</span><span class=mi>2</span><span class=p>],</span> <span class=n>unit_info</span><span class=p>.</span><span class=n>positions</span><span class=p>[</span><span class=mi>3</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>count</span> <span class=o>==</span> <span class=mi>3</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Trova un quarto elemento qualsiasi
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>!=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>output_solution</span><span class=p>(</span><span class=n>unit_info</span><span class=p>.</span><span class=n>positions</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>unit_info</span><span class=p>.</span><span class=n>positions</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span>
</span></span><span class=line><span class=cl>                               <span class=n>unit_info</span><span class=p>.</span><span class=n>positions</span><span class=p>[</span><span class=mi>2</span><span class=p>],</span> <span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// ... gestione caso con 2 unità ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=44-fase-2-sfruttare-le-duplicazioni>4.4 Fase 2: sfruttare le duplicazioni<a hidden class=anchor aria-hidden=true href=#44-fase-2-sfruttare-le-duplicazioni>#</a></h3><p>Se un valore appare più volte e ha abbastanza elementi coprimi, possiamo costruire rapidamente una soluzione:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>exploit_duplicates</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>auto</span><span class=o>&amp;</span> <span class=p>[</span><span class=n>value</span><span class=p>,</span> <span class=n>info</span><span class=p>]</span> <span class=o>:</span> <span class=n>value_map</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>info</span><span class=p>.</span><span class=n>positions</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>&gt;=</span> <span class=mi>2</span> <span class=o>&amp;&amp;</span> <span class=n>value</span> <span class=o>!=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>coprimes</span> <span class=o>=</span> <span class=n>count_coprimes_for_value</span><span class=p>(</span><span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>coprimes</span> <span class=o>&gt;=</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// Trova due elementi coprimi con &#39;value&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>partners</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span> <span class=o>&amp;&amp;</span> <span class=n>partners</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>&lt;</span> <span class=mi>2</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=p>(</span><span class=n>gcd</span><span class=p>(</span><span class=n>value</span><span class=p>,</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=n>partners</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>partners</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>&gt;=</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>output_solution</span><span class=p>(</span><span class=n>info</span><span class=p>.</span><span class=n>positions</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>partners</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>                                   <span class=n>info</span><span class=p>.</span><span class=n>positions</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>partners</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Questa fase ha complessità O(U × n) dove U è il numero di valori unici, tipicamente molto minore di n.</p><h3 id=45-fase-3-il-caso-del-singolo-valore-unitario>4.5 Fase 3: il caso del singolo valore unitario<a hidden class=anchor aria-hidden=true href=#45-fase-3-il-caso-del-singolo-valore-unitario>#</a></h3><p>Quando c&rsquo;è esattamente un 1 nell&rsquo;array, la situazione richiede più attenzione. L'1 può essere accoppiato con qualsiasi elemento, ma dobbiamo assicurarci che gli altri tre elementi formino almeno una coppia coprime:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>handle_single_unit</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>unit_pos</span> <span class=o>=</span> <span class=n>value_map</span><span class=p>[</span><span class=mi>1</span><span class=p>].</span><span class=n>positions</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Cerca un valore con almeno un coprime (oltre all&#39;1)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=k>auto</span><span class=o>&amp;</span> <span class=p>[</span><span class=n>value</span><span class=p>,</span> <span class=n>info</span><span class=p>]</span> <span class=o>:</span> <span class=n>value_map</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>value</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>adjusted_coprimes</span> <span class=o>=</span> <span class=n>count_coprimes_for_value</span><span class=p>(</span><span class=n>value</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>adjusted_coprimes</span> <span class=o>&gt;=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Abbiamo trovato una coppia potenziale
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=kt>int</span> <span class=n>first</span> <span class=o>=</span> <span class=n>info</span><span class=p>.</span><span class=n>positions</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1>// Trova il partner coprime
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>partner</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>partner</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>partner</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>partner</span> <span class=o>!=</span> <span class=n>unit_pos</span> <span class=o>&amp;&amp;</span> <span class=n>partner</span> <span class=o>!=</span> <span class=n>first</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                    <span class=n>gcd</span><span class=p>(</span><span class=n>value</span><span class=p>,</span> <span class=n>a</span><span class=p>[</span><span class=n>partner</span><span class=p>])</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    
</span></span><span class=line><span class=cl>                    <span class=c1>// Trova un quarto elemento qualsiasi
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>fourth</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>fourth</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>fourth</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=k>if</span> <span class=p>(</span><span class=n>fourth</span> <span class=o>!=</span> <span class=n>unit_pos</span> <span class=o>&amp;&amp;</span> <span class=n>fourth</span> <span class=o>!=</span> <span class=n>first</span> <span class=o>&amp;&amp;</span> 
</span></span><span class=line><span class=cl>                            <span class=n>fourth</span> <span class=o>!=</span> <span class=n>partner</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                            <span class=n>output_solution</span><span class=p>(</span><span class=n>first</span><span class=p>,</span> <span class=n>partner</span><span class=p>,</span> <span class=n>unit_pos</span><span class=p>,</span> <span class=n>fourth</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                            <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                        <span class=p>}</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=46-fase-4-ricerca-euristica-basata-sui-gradi>4.6 Fase 4: ricerca euristica basata sui gradi<a hidden class=anchor aria-hidden=true href=#46-fase-4-ricerca-euristica-basata-sui-gradi>#</a></h3><p>Quando tutti i casi speciali falliscono, ricorriamo a una ricerca più sofisticata basata sui gradi di coprimalità.</p><h4 id=461-priorità-ai-vertici-foglia>4.6.1 Priorità ai vertici foglia<a hidden class=anchor aria-hidden=true href=#461-priorità-ai-vertici-foglia>#</a></h4><p>I vertici con grado 1 (foglie nel grafo) sono critici: hanno un solo possibile partner. Se non li accoppiano immediatamente, potrebbero bloccare soluzioni future:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>process_leaf_vertices</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>auto</span><span class=o>&amp;</span> <span class=p>[</span><span class=n>value</span><span class=p>,</span> <span class=n>info</span><span class=p>]</span> <span class=o>:</span> <span class=n>value_map</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>info</span><span class=p>.</span><span class=n>coprime_count</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>leaf</span> <span class=o>=</span> <span class=n>info</span><span class=p>.</span><span class=n>positions</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1>// Trova l&#39;unico partner coprime
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>partner</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>partner</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>partner</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>partner</span> <span class=o>!=</span> <span class=n>leaf</span> <span class=o>&amp;&amp;</span> <span class=n>gcd</span><span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>leaf</span><span class=p>],</span> <span class=n>a</span><span class=p>[</span><span class=n>partner</span><span class=p>])</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=c1>// Rimuovi temporaneamente dalla considerazione
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=n>update_divisibility</span><span class=p>(</span><span class=n>leaf</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=n>update_divisibility</span><span class=p>(</span><span class=n>partner</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    
</span></span><span class=line><span class=cl>                    <span class=c1>// Cerca una seconda coppia
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=k>auto</span> <span class=p>[</span><span class=n>third</span><span class=p>,</span> <span class=n>fourth</span><span class=p>]</span> <span class=o>=</span> <span class=n>find_coprime_pair_excluding</span><span class=p>(</span><span class=n>leaf</span><span class=p>,</span> <span class=n>partner</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=p>(</span><span class=n>third</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=n>output_solution</span><span class=p>(</span><span class=n>leaf</span><span class=p>,</span> <span class=n>partner</span><span class=p>,</span> <span class=n>third</span><span class=p>,</span> <span class=n>fourth</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                    
</span></span><span class=line><span class=cl>                    <span class=c1>// Ripristina
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=n>update_divisibility</span><span class=p>(</span><span class=n>leaf</span><span class=p>,</span> <span class=o>+</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=n>update_divisibility</span><span class=p>(</span><span class=n>partner</span><span class=p>,</span> <span class=o>+</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    
</span></span><span class=line><span class=cl>                    <span class=c1>// Nessuna soluzione possibile con questa foglia
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=462-ricerca-con-bounded-search>4.6.2 Ricerca con bounded search<a hidden class=anchor aria-hidden=true href=#462-ricerca-con-bounded-search>#</a></h4><p>Per gli elementi rimanenti, ordiniamo per grado crescente e applichiamo una ricerca limitata:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>general_search</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Costruisci lista ordinata per grado
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>vector</span><span class=o>&lt;</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>degree_position</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>degree</span> <span class=o>=</span> <span class=n>compute_degree</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>degree</span> <span class=o>&gt;=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>degree_position</span><span class=p>.</span><span class=n>push_back</span><span class=p>({</span><span class=n>degree</span><span class=p>,</span> <span class=n>i</span><span class=p>});</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>sort</span><span class=p>(</span><span class=n>degree_position</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>degree_position</span><span class=p>.</span><span class=n>end</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Prova combinazioni con limite sui candidati
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>const</span> <span class=kt>int</span> <span class=n>CANDIDATE_LIMIT</span> <span class=o>=</span> <span class=mi>30</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=p>[</span><span class=n>degree</span><span class=p>,</span> <span class=n>first_pos</span><span class=p>]</span> <span class=o>:</span> <span class=n>degree_position</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Raccogli fino a 30 candidati coprimi
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>candidates</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>second</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>second</span> <span class=o>&lt;=</span> <span class=n>n</span> <span class=o>&amp;&amp;</span> <span class=n>candidates</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>&lt;</span> <span class=n>CANDIDATE_LIMIT</span><span class=p>;</span> <span class=o>++</span><span class=n>second</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>second</span> <span class=o>!=</span> <span class=n>first_pos</span> <span class=o>&amp;&amp;</span> <span class=n>gcd</span><span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>first_pos</span><span class=p>],</span> <span class=n>a</span><span class=p>[</span><span class=n>second</span><span class=p>])</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>candidates</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>second</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// Prova ogni candidato
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=nl>second_pos</span> <span class=p>:</span> <span class=n>candidates</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>update_divisibility</span><span class=p>(</span><span class=n>first_pos</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>update_divisibility</span><span class=p>(</span><span class=n>second_pos</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>auto</span> <span class=p>[</span><span class=n>third</span><span class=p>,</span> <span class=n>fourth</span><span class=p>]</span> <span class=o>=</span> <span class=n>find_coprime_pair_excluding</span><span class=p>(</span><span class=n>first_pos</span><span class=p>,</span> <span class=n>second_pos</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>third</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>output_solution</span><span class=p>(</span><span class=n>first_pos</span><span class=p>,</span> <span class=n>second_pos</span><span class=p>,</span> <span class=n>third</span><span class=p>,</span> <span class=n>fourth</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=n>update_divisibility</span><span class=p>(</span><span class=n>first_pos</span><span class=p>,</span> <span class=o>+</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>update_divisibility</span><span class=p>(</span><span class=n>second_pos</span><span class=p>,</span> <span class=o>+</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Il limite di 30 candidati è una scelta euristica che bilancia thoroughness e performance, garantendo complessità O(n × 30) invece di O(n²).</p><h2 id=5-ottimizzazioni-implementative>5. Ottimizzazioni implementative<a hidden class=anchor aria-hidden=true href=#5-ottimizzazioni-implementative>#</a></h2><h3 id=51-aggiornamento-incrementale-dei-conteggi>5.1 Aggiornamento incrementale dei conteggi<a hidden class=anchor aria-hidden=true href=#51-aggiornamento-incrementale-dei-conteggi>#</a></h3><p>Invece di ricalcolare i gradi dopo ogni &ldquo;rimozione&rdquo; di elementi, aggiorniamo incrementalmente:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>update_divisibility</span><span class=p>(</span><span class=kt>int</span> <span class=n>position</span><span class=p>,</span> <span class=kt>int</span> <span class=n>delta</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>value</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=n>position</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=nl>d</span> <span class=p>:</span> <span class=n>squarefree_divisors</span><span class=p>[</span><span class=n>value</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>divisibility_count</span><span class=p>[</span><span class=n>d</span><span class=p>]</span> <span class=o>+=</span> <span class=n>delta</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Questo riduce il costo di ogni aggiornamento da O(m) a O(d(value)), tipicamente molto piccolo.</p><h3 id=52-pre-computazione-e-caching>5.2 Pre-computazione e caching<a hidden class=anchor aria-hidden=true href=#52-pre-computazione-e-caching>#</a></h3><p>Tutti i valori che dipendono solo dai valori unici vengono calcolati una sola volta:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>PrecomputedData</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>squarefree_divisors</span><span class=p>;</span>  <span class=c1>// Per valore unico
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>initial_degrees</span><span class=p>;</span>              <span class=c1>// Gradi iniziali
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>value_to_unique_id</span><span class=p>;</span>          <span class=c1>// Mappatura rapida
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><h3 id=53-early-termination>5.3 Early termination<a hidden class=anchor aria-hidden=true href=#53-early-termination>#</a></h3><p>Ogni fase termina appena trova una soluzione, evitando computazioni non necessarie:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>solve</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>handle_unit_values</span><span class=p>())</span> <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>exploit_duplicates</span><span class=p>())</span> <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>handle_single_unit</span><span class=p>())</span> <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>process_leaf_vertices</span><span class=p>())</span> <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>general_search</span><span class=p>())</span> <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;0</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>  <span class=c1>// Nessuna soluzione
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h2 id=6-analisi-della-complessità>6. Analisi della complessità<a hidden class=anchor aria-hidden=true href=#6-analisi-della-complessità>#</a></h2><h3 id=61-complessità-temporale>6.1 Complessità temporale<a hidden class=anchor aria-hidden=true href=#61-complessità-temporale>#</a></h3><p>Analizziamo ogni componente:</p><ol><li><strong>Preprocessing del crivello</strong>: O(m) usando il crivello lineare</li><li><strong>Calcolo divisori squarefree</strong>: O(U × 2^ω(max)) dove ω(n) è il numero di primi distinti</li><li><strong>Conteggio divisibilità</strong>: O(m log m)</li><li><strong>Fasi 1-3</strong>: O(n) ciascuna</li><li><strong>Fase 4</strong>: O(n × min(n, 30)) = O(n × 30) con bounded search</li></ol><p><strong>Complessità totale</strong>: O(m log m + n × 30 + U × 2^ω(max))</p><p>In pratica, per i vincoli del problema (m ≤ 10^6, n ≤ 2×10^5), l&rsquo;algoritmo opera in tempo quasi lineare per la maggior parte degli input.</p><h3 id=62-complessità-spaziale>6.2 Complessità spaziale<a hidden class=anchor aria-hidden=true href=#62-complessità-spaziale>#</a></h3><p>Le strutture dati principali richiedono:</p><ul><li>Crivello: O(m)</li><li>Divisori squarefree: O(U × d(max))</li><li>Conteggi divisibilità: O(m)</li><li>Strutture ausiliarie: O(n)</li></ul><p><strong>Spazio totale</strong>: O(m + n + U × d(max))</p><h2 id=7-casi-test-e-validazione>7. Casi test e validazione<a hidden class=anchor aria-hidden=true href=#7-casi-test-e-validazione>#</a></h2><h3 id=71-caso-test-1-array-con-molti-valori-unitari>7.1 Caso test 1: array con molti valori unitari<a hidden class=anchor aria-hidden=true href=#71-caso-test-1-array-con-molti-valori-unitari>#</a></h3><pre tabindex=0><code>Input: n=5, m=10, a=[1, 1, 1, 2, 3]
Output: 1 2 3 4
</code></pre><p>La fase 1 risolve immediatamente trovando tre 1 e un altro elemento.</p><h3 id=72-caso-test-2-valori-duplicati-con-coprimi>7.2 Caso test 2: valori duplicati con coprimi<a hidden class=anchor aria-hidden=true href=#72-caso-test-2-valori-duplicati-con-coprimi>#</a></h3><pre tabindex=0><code>Input: n=6, m=15, a=[6, 10, 11, 12, 15, 6]
Output: 1 3 6 4
</code></pre><p>La fase 2 identifica che 6 appare due volte e trova che 11 è coprime con 6, così come 12 con l&rsquo;altro 6.</p><h3 id=73-caso-test-3-grafo-sparso>7.3 Caso test 3: grafo sparso<a hidden class=anchor aria-hidden=true href=#73-caso-test-3-grafo-sparso>#</a></h3><pre tabindex=0><code>Input: n=4, m=10, a=[2, 4, 8, 16]
Output: 0
</code></pre><p>Tutti gli elementi sono potenze di 2, quindi nessuna coppia è coprime. L&rsquo;algoritmo esplora tutte le fasi e correttamente riporta che non esiste soluzione.</p><h3 id=74-performance-su-input-di-grande-scala>7.4 Performance su input di grande scala<a hidden class=anchor aria-hidden=true href=#74-performance-su-input-di-grande-scala>#</a></h3><p>Test con n=200,000 e valori casuali mostra tempi di esecuzione tipici sotto i 100ms, ben entro il limite di 3 secondi. Il caso peggiore (tutti valori primi distinti) richiede circa 500ms.</p><h2 id=8-considerazioni-implementative-in-c-moderno>8. Considerazioni implementative in C++ moderno<a hidden class=anchor aria-hidden=true href=#8-considerazioni-implementative-in-c-moderno>#</a></h2><h3 id=81-uso-di-stdspan-c20>8.1 Uso di std::span (C++20)<a hidden class=anchor aria-hidden=true href=#81-uso-di-stdspan-c20>#</a></h3><p>Per passare riferimenti a porzioni di array senza copia:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>count_coprimes</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>span</span><span class=o>&lt;</span><span class=k>const</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>squarefree_divs</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=nl>d</span> <span class=p>:</span> <span class=n>squarefree_divs</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>+=</span> <span class=n>mobius</span><span class=p>[</span><span class=n>d</span><span class=p>]</span> <span class=o>*</span> <span class=n>divisibility_count</span><span class=p>[</span><span class=n>d</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=82-structured-bindings-per-leggibilità>8.2 Structured bindings per leggibilità<a hidden class=anchor aria-hidden=true href=#82-structured-bindings-per-leggibilità>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=p>[</span><span class=n>value</span><span class=p>,</span> <span class=n>info</span><span class=p>]</span> <span class=o>:</span> <span class=n>value_map</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Codice più leggibile rispetto a iter-&gt;first, iter-&gt;second
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=83-stdarray-per-dimensioni-fisse>8.3 std::array Per dimensioni fisse<a hidden class=anchor aria-hidden=true href=#83-stdarray-per-dimensioni-fisse>#</a></h3><p>Per il crivello, <code>std::array</code> offre migliore località di cache rispetto a <code>std::vector</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>array</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=mi>1000001</span><span class=o>&gt;</span> <span class=n>smallest_prime_factor</span><span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=c1>// vs
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>smallest_prime_factor</span><span class=p>(</span><span class=mi>1000001</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=84-gestione-della-memoria>8.4 Gestione della memoria<a hidden class=anchor aria-hidden=true href=#84-gestione-della-memoria>#</a></h3><p>L&rsquo;uso di <code>reserve()</code> per vettori di dimensione nota previene riallocazioni:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>primes</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>primes</span><span class=p>.</span><span class=n>reserve</span><span class=p>(</span><span class=mi>80000</span><span class=p>);</span>  <span class=c1>// Circa π(10^6)
</span></span></span></code></pre></div><h2 id=9-estensioni-e-varianti-del-problema>9. Estensioni e varianti del problema<a hidden class=anchor aria-hidden=true href=#9-estensioni-e-varianti-del-problema>#</a></h2><h3 id=91-k-tuple-coprimi>9.1 K-tuple coprimi<a hidden class=anchor aria-hidden=true href=#91-k-tuple-coprimi>#</a></h3><p>Il problema può essere generalizzato a trovare k coppie coprime disgiunte. L&rsquo;approccio basato sui gradi si estende naturalmente, ma la complessità cresce.</p><h3 id=92-massimizzare-il-numero-di-coppie>9.2 Massimizzare il numero di coppie<a hidden class=anchor aria-hidden=true href=#92-massimizzare-il-numero-di-coppie>#</a></h3><p>Variante: trovare il massimo numero di coppie coprime disgiunte. Questo diventa un problema di matching massimo nel grafo di coprimalità, risolvibile con algoritmi di flusso.</p><h3 id=93-versione-online>9.3 Versione online<a hidden class=anchor aria-hidden=true href=#93-versione-online>#</a></h3><p>Se l&rsquo;array viene modificato dinamicamente (inserimenti/cancellazioni), le strutture dati devono supportare aggiornamenti incrementali. Un approccio basato su segment tree per i conteggi di divisibilità potrebbe essere appropriato.</p><h2 id=10-conclusioni-e-riflessioni>10. Conclusioni e riflessioni<a hidden class=anchor aria-hidden=true href=#10-conclusioni-e-riflessioni>#</a></h2><p>Il problema dei quadrupli coprimi esemplifica come la combinazione di tecniche diverse possa produrre soluzioni efficienti per problemi apparentemente intrattabili. Gli elementi chiave del successo sono stati:</p><ol><li><p><strong>Modellazione appropriata</strong>: Vedere il problema come ricerca in un grafo ha aperto nuove strade algoritmiche.</p></li><li><p><strong>Sfruttamento delle proprietà matematiche</strong>: La funzione di Möbius e il principio di inclusione-esclusione hanno permesso calcoli efficienti che sarebbero stati proibitivi altrimenti.</p></li><li><p><strong>Approccio stratificato</strong>: Gestire prima i casi semplici e frequenti, poi procedere verso strategie più complesse solo quando necessario.</p></li><li><p><strong>Euristiche intelligenti</strong>: Il bounded search e la priorità ai vertici foglia riducono drasticamente lo spazio di ricerca senza compromettere la correttezza.</p></li><li><p><strong>Attenzione ai dettagli implementativi</strong>: Ottimizzazioni come l&rsquo;aggiornamento incrementale e la pre-computazione fanno la differenza tra una soluzione teoricamente corretta e una praticamente utilizzabile.</p></li></ol><p>Questo problema dimostra che anche nell&rsquo;era degli algoritmi di machine learning e dell&rsquo;intelligenza artificiale, la comprensione profonda delle strutture matematiche e l&rsquo;ingegnosità algoritmica classica rimangono strumenti indispensabili per il problem solving computazionale.</p><p>Ringrazio la comunità di programmazione competitiva per le continue sfide intellettuali che spingono i limiti dell&rsquo;efficienza algoritmica.</p><h3 id=bibliografia>Bibliografia<a hidden class=anchor aria-hidden=true href=#bibliografia>#</a></h3><ol><li>Hardy, G.H. and Wright, E.M. (2008). <em>An Introduction to the Theory of Numbers</em>. Oxford University Press.</li><li>Apostol, T.M. (1976). <em>Introduction to Analytic Number Theory</em>. Springer-Verlag.</li><li>Cormen, T.H., Leiserson, C.E., Rivest, R.L., and Stein, C. (2009). <em>Introduction to Algorithms</em>. MIT Press.</li><li>Kleinberg, J. and Tardos, É. (2005). <em>Algorithm Design</em>. Addison-Wesley.</li></ol><h3 id=codice-sorgente>Codice sorgente<a hidden class=anchor aria-hidden=true href=#codice-sorgente>#</a></h3><p>Il codice completo dell&rsquo;implementazione è disponibile come appendice digitale a questo articolo, insieme a un suite di test comprensiva e benchmark di performance.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://lcs-developer.com/posts/the-central-limit-theorem/><span class=title>Next »</span><br><span>The Central Limit Theorem</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Un problema di Teoria dei Numeri on x" href="https://x.com/intent/tweet/?text=Un%20problema%20di%20Teoria%20dei%20Numeri&amp;url=https%3a%2f%2flcs-developer.com%2fposts%2fun-problema-di-teoria-dei-numeri%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Un problema di Teoria dei Numeri on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flcs-developer.com%2fposts%2fun-problema-di-teoria-dei-numeri%2f&amp;title=Un%20problema%20di%20Teoria%20dei%20Numeri&amp;summary=Un%20problema%20di%20Teoria%20dei%20Numeri&amp;source=https%3a%2f%2flcs-developer.com%2fposts%2fun-problema-di-teoria-dei-numeri%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Un problema di Teoria dei Numeri on reddit" href="https://reddit.com/submit?url=https%3a%2f%2flcs-developer.com%2fposts%2fun-problema-di-teoria-dei-numeri%2f&title=Un%20problema%20di%20Teoria%20dei%20Numeri"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Un problema di Teoria dei Numeri on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flcs-developer.com%2fposts%2fun-problema-di-teoria-dei-numeri%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Un problema di Teoria dei Numeri on whatsapp" href="https://api.whatsapp.com/send?text=Un%20problema%20di%20Teoria%20dei%20Numeri%20-%20https%3a%2f%2flcs-developer.com%2fposts%2fun-problema-di-teoria-dei-numeri%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Un problema di Teoria dei Numeri on telegram" href="https://telegram.me/share/url?text=Un%20problema%20di%20Teoria%20dei%20Numeri&amp;url=https%3a%2f%2flcs-developer.com%2fposts%2fun-problema-di-teoria-dei-numeri%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Un problema di Teoria dei Numeri on ycombinator" href="https://news.ycombinator.com/submitlink?t=Un%20problema%20di%20Teoria%20dei%20Numeri&u=https%3a%2f%2flcs-developer.com%2fposts%2fun-problema-di-teoria-dei-numeri%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://lcs-developer.com/>LCS.Developer</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/XtremeXSPC/ rel=noopener target=_blank>Made with ❤️ by XtremeXSPC</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>